<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ניסוי חיבור נקודות — גרסה מותאמת</title>
  <style>
    :root{
      --bg:#020617;
      --panel:#0b1120;
      --ink:#e5e7eb;
      --muted:#94a3b8;
      --accent:#60a5fa;
      --accent-soft:rgba(96,165,250,0.4);
      --wrong:#f97373;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      display:grid;
      grid-template-rows:auto 1fr auto;
    }
    header,footer{
      background:var(--panel);
      padding:10px 16px;
      border-bottom:1px solid #111827;
    }
    footer{
      border-top:1px solid #111827;
      border-bottom:none;
      font-size:0.8rem;
      color:var(--muted);
      text-align:center;
    }
    .top{
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:center;
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      justify-content:center;
      align-items:center;
    }
    label{font-size:0.9rem;color:var(--muted);}
    input{
      background:#020617;
      border:1px solid #334155;
      color:var(--ink);
      padding:4px 8px;
      border-radius:8px;
      min-width:120px;
    }
    input[readonly]{
      opacity:0.8;
    }
    button{
      border-radius:999px;
      border:1px solid #334155;
      background:#111827;
      color:var(--ink);
      padding:6px 14px;
      cursor:pointer;
      font-size:0.9rem;
    }
    button:disabled{
      opacity:0.4;
      cursor:not-allowed;
    }
    button:hover:not(:disabled){
      border-color:var(--accent);
    }
    #stageWrap{
      padding:10px 16px 16px;
      position:relative;
    }
    #stage{
      width:100%;
      height:70vh;
      display:block;
      background:#020617;
      border-radius:18px;
      border:1px solid #1f2937;
    }
    #overlay{
      position:absolute;
      inset:10px 16px 16px;
      display:none;
      place-items:center;
      background:rgba(15,23,42,0.82);
      border-radius:18px;
    }
    #overlay .box{
      background:#020617;
      border-radius:16px;
      border:1px solid #1f2937;
      padding:20px 24px;
      max-width:360px;
      text-align:center;
    }
    #overlay h2{
      margin-top:0;
      margin-bottom:8px;
    }
    .muted{color:var(--muted);}
    .hidden{display:none !important;}
  </style>
</head>
<body>
  <header>
    <div class="top">
      <div class="muted">
        המשימה תימשך עד <b>10 דקות</b> או עד לחיצה על "סיום מוקדם".
      </div>
      <div class="controls">
        <label for="pid">מזהה נבדק:</label>
        <input id="pid" type="text" placeholder="לדוגמה OR010125" />
        <button id="startBtn">התחל סשן</button>
        <button id="endBtn" disabled>סיום מוקדם</button>
      </div>
    </div>
  </header>

  <div id="stageWrap">
    <canvas id="stage"></canvas>
    <div id="overlay">
      <div class="box">
        <h2 id="overlayTitle">סיום סשן</h2>
        <p id="overlayText" class="muted"></p>
        <button id="overlayContinue">המשך</button>
      </div>
    </div>
  </div>

  <footer>
    הקווים נחברים תמיד לפי סדר מספרים עולה. ניתן לבטל בחירה שגויה בלחיצה נוספת על אותה ספרה.
  </footer>

<script>
(() => {
  const CONFIG = {
    sessionMinutes: 10,       // משך סשן בדקות
    initialPoints: 20,        // כמות נקודות התחלתית
    incrementBy: 5,           // כמה נקודות להוסיף בכל משימה שהושלמה
    minDistance: 70,          // מרחק מינימלי בין נקודות
    lineAvoidDistance: 24,    // מרחק מינימלי של נקודה מקטע קו
    margin: 40
  };

  // טופס 2 – עם השדה של ה-PID
  const FORM_BASE_URL =
    "https://docs.google.com/forms/d/e/1FAIpQLSdTCgLVjt4LXsNAkXP1H8jxIC5MPsdv1sD93v5lmglckCAzrA/viewform?usp=pp_url&entry.404955311=";

  // DOM
  const canvas = document.getElementById("stage");
  const ctx = canvas.getContext("2d");
  const pidInput = document.getElementById("pid");
  const startBtn = document.getElementById("startBtn");
  const endBtn = document.getElementById("endBtn");
  const overlay = document.getElementById("overlay");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlayText = document.getElementById("overlayText");
  const overlayContinue = document.getElementById("overlayContinue");

  // State
  let running = false;
  let sessionStart = null;
  let tickId = null;
  let tasks = [];
  let taskIndex = 0;
  let currentTask = null; // {points, correctSeq, wrongSet, errors, startTime, endTime}

  // --- Helpers ---

  function getPidFromUrl(){
    const params = new URLSearchParams(window.location.search);
    return params.get("pid") || "";
  }

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  function now(){
    return performance.now();
  }

  function randomBetween(min,max){
    return min + Math.random() * (max - min);
  }

  function distance(a,b){
    return Math.hypot(a.x - b.x, a.y - b.y);
  }

  function pointToSegmentDistance(p,a,b){
    // מרחק מנקודה p למקטע a-b
    const vx = b.x - a.x;
    const vy = b.y - a.y;
    const wx = p.x - a.x;
    const wy = p.y - a.y;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(p.x-a.x, p.y-a.y);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(p.x-b.x, p.y-b.y);
    const t = c1 / c2;
    const projX = a.x + t*vx;
    const projY = a.y + t*vy;
    return Math.hypot(p.x-projX, p.y-projY);
  }

  // --- Task generation ---

  function generateTask(n){
    const rect = canvas.getBoundingClientRect();
    const m = CONFIG.margin;
    const W = Math.max(rect.width - 2*m, 100);
    const H = Math.max(rect.height - 2*m, 100);

    const points = [];
    let attempts = 0;

    // נקודה ראשונה
    points.push({
      x: randomBetween(m, m+W),
      y: randomBetween(m, m+H)
    });

    while(points.length < n && attempts < 5000){
      attempts++;
      const candidate = {
        x: randomBetween(m, m+W),
        y: randomBetween(m, m+H)
      };

      // מרחק מנקודות קיימות
      let ok = points.every(p => distance(p, candidate) >= CONFIG.minDistance);
      if (!ok) continue;

      // לוודא שאין נקודה אחרת שיושבת כמעט על הקו בין הנקודה האחרונה למועמדת
      const last = points[points.length-1];
      for(let i=0;i<points.length;i++){
        const p = points[i];
        const d = pointToSegmentDistance(p, last, candidate);
        if (d < CONFIG.lineAvoidDistance){
          ok = false;
          break;
        }
      }
      if (!ok) continue;

      points.push(candidate);
    }

    return {
      index: ++taskIndex,
      points,
      correctSeq: [],
      wrongSet: new Set(),
      errors: 0,
      startTime: now(),
      endTime: null
    };
  }

  // --- Drawing ---

  function draw(){
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
    if (!currentTask) return;

    const pts = currentTask.points;

    // קווים בין נקודות שנבחרו בסדר הנכון
    if (currentTask.correctSeq.length > 1){
      ctx.beginPath();
      ctx.lineWidth = 3;
      ctx.strokeStyle = "rgba(96,165,250,0.9)";
      for(let i=1;i<currentTask.correctSeq.length;i++){
        const a = pts[currentTask.correctSeq[i-1]];
        const b = pts[currentTask.correctSeq[i]];
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
      }
      ctx.stroke();
    }

    // ציור נקודות
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "14px system-ui, Arial";

    pts.forEach((p, idx) => {
      const isCorrect = currentTask.correctSeq.includes(idx);
      const isWrong = currentTask.wrongSet.has(idx);
      const radius = 13;

      if (isCorrect){
        // נבחר נכון – כחול מלא
        ctx.fillStyle = "#1d4ed8";
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "#e5e7eb";
        ctx.fillText(String(idx+1), p.x, p.y);
      } else if (isWrong){
        // בחירה שגויה – עיגול דהוי עם קו אדום
        ctx.fillStyle = "rgba(148,163,184,0.4)";
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "#f97373";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = "#e5e7eb";
        ctx.fillText(String(idx+1), p.x, p.y);
      } else {
        // נקודה עדיין לא נבחרה
        ctx.fillStyle = "#020617";
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "#64748b";
        ctx.lineWidth = 1.5;
        ctx.stroke();

        ctx.fillStyle = "#e5e7eb";
        ctx.fillText(String(idx+1), p.x, p.y);
      }
    });
  }

  // --- Interaction ---

  function hitTest(x,y){
    if (!currentTask) return -1;
    const pts = currentTask.points;
    for(let i=0;i<pts.length;i++){
      const p = pts[i];
      if (Math.hypot(p.x-x, p.y-y) <= 18) return i;
    }
    return -1;
  }

  function handlePointerDown(ev){
    if (!running || !currentTask) return;
    const rect = canvas.getBoundingClientRect();
    const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
    const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    const idx = hitTest(x,y);
    if (idx === -1) return;

    const task = currentTask;
    const nextExpected = task.correctSeq.length; // האינדקס הבא (0-מבוסס)

    if (idx === nextExpected){
      // בחירה נכונה – מספר הבא ברצף
      task.correctSeq.push(idx);
      task.wrongSet.delete(idx);
      draw();

      if (task.correctSeq.length === task.points.length){
        finishCurrentTask(true);
      }
    } else {
      // בחירה שגויה – טוגל
      if (task.wrongSet.has(idx)){
        task.wrongSet.delete(idx);      // ביטול בחירה
      } else {
        task.wrongSet.add(idx);         // סימון שגוי
        task.errors += 1;               // נספר לצורכי ניתוח
      }
      draw();
    }
  }

  canvas.addEventListener("pointerdown", handlePointerDown);
  canvas.addEventListener("touchstart", handlePointerDown, {passive:true});

  // --- Tasks / Session control ---

  function startSession(){
    const pid = (pidInput.value || "").trim();
    if (!pid){
      alert("נא למלא מזהה נבדק לפני תחילת הסשן.");
      return;
    }
    running = true;
    tasks = [];
    taskIndex = 0;
    sessionStart = now();
    startBtn.disabled = true;
    endBtn.disabled = false;
    overlay.style.display = "none";
    currentTask = generateTask(CONFIG.initialPoints);
    draw();
    if (tickId) clearInterval(tickId);
    tickId = setInterval(tick, 500);
  }

  function finishCurrentTask(completed){
    if (!currentTask) return;
    currentTask.endTime = now();
    const dur = currentTask.endTime - currentTask.startTime;
    tasks.push({
      task: currentTask.index,
      n_points: currentTask.points.length,
      errors: currentTask.errors,
      duration_ms: Math.round(dur),
      completed: completed ? 1 : 0,
      ts: new Date().toISOString()
    });

    if (!running) return;

    if (completed){
      // העלאת רמת קושי
      const nextPoints = currentTask.points.length + CONFIG.incrementBy;
      currentTask = generateTask(nextPoints);
    } else {
      // ניסיון מחדש באותה רמת קושי
      currentTask = generateTask(currentTask.points.length);
    }
    draw();
  }

  function tick(){
    if (!running) return;
    const elapsedSec = (now() - sessionStart) / 1000;
    if (elapsedSec >= CONFIG.sessionMinutes * 60){
      // סיום אוטומטי
      endSession(true);
    }
  }

  function buildCsv(){
    if (!tasks.length) return "";
    const head = ["task","n_points","errors","duration_ms","completed","ts"];
    const rows = tasks.map(t => head.map(h => t[h]).join(","));
    return head.join(",") + "\n" + rows.join("\n");
  }

  function downloadCsv(pid){
    const csv = buildCsv();
    if (!csv) return;
    const blob = new Blob([csv], {type:"text/csv"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    const safePid = (pid || "PID").replace(/[^a-zA-Z0-9_-]/g,"");
    a.download = "connect_the_dots_results_" + safePid + ".csv";
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(a.href);
      a.remove();
    }, 0);
  }

  function endSession(autoEnded){
    if (!running){
      // אם כבר הופסק קודם – נוודא בכל זאת שממשיכים לטופס
      redirectToForm();
      return;
    }
    running = false;
    endBtn.disabled = true;
    startBtn.disabled = false;
    if (tickId) clearInterval(tickId);

    // לוג task אחרון כלא-מושלם אם עדיין רץ
    if (currentTask){
      finishCurrentTask(false);
    }

    const pid = (pidInput.value || "").trim();

    // הורדת CSV – תוכל לבקש מהנבדקים לשלוח לך את הקובץ אם תרצה
    if (tasks.length){
      downloadCsv(pid);
    }

    overlayTitle.textContent = autoEnded ? "הסשן הסתיים" : "הסשן הופסק";
    overlayText.textContent = "תודה על ביצוע המשימה. כעת נעבור לשאלון קצר נוסף.";
    overlay.style.display = "grid";

    overlayContinue.onclick = () => {
      redirectToForm();
    };
  }

  function redirectToForm(){
    const pid = (pidInput.value || "").trim();
    const target = FORM_BASE_URL + encodeURIComponent(pid || "");
    window.location.href = target;
  }

  function handleEndClick(){
    if (!running){
      redirectToForm();
    } else {
      endSession(false);
    }
  }

  // --- Init ---

  // PID מה-URL (מדף הביניים)
  const urlPid = getPidFromUrl();
  if (urlPid){
    pidInput.value = urlPid;
    pidInput.readOnly = true;
  }

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  startBtn.addEventListener("click", startSession);
  endBtn.addEventListener("click", handleEndClick);
})();
</script>
</body>
</html>
