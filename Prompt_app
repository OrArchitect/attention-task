<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Workspace Pilot — One Screen</title>
  <style>
    *{box-sizing:border-box;}
    html,body{height:100%; overflow:hidden;}
    body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;background:#fff;color:#111;}
    .wrap{
      height:100vh;
      display:grid;
      grid-template-columns: 1.15fr 0.85fr;
      gap:16px;
      padding:14px 16px;
      align-items:stretch;
    }
    .left{
      display:grid;
      grid-template-rows: auto 1fr auto;
      gap:10px;
      min-width:0;
      height:100%;
    }
    .panel{
      border:1px solid #e5e7eb;
      border-radius:14px;
      padding:10px 12px;
      background:#fff;
      min-width:0;
    }
    h3{margin:0 0 6px 0;font-size:14px;font-weight:900;}
    #prompt{white-space:pre-wrap;line-height:1.45;font-size:13px;}
    .canvasWrap{
      border:1px solid #e5e7eb;
      border-radius:14px;
      overflow:hidden;
      background:#f7f7f7;
      position:relative;
      min-height:260px;
    }
    canvas{width:100%;height:100%;display:block;}
    .caption{
      position:absolute; inset:auto 10px 10px auto;
      background:rgba(255,255,255,0.9);
      border:1px solid #e5e7eb;
      border-radius:999px;
      padding:5px 9px;
      font-size:11px;
      color:#334155;
      font-weight:800;
    }
    .rowBtns{
      display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-start;
    }
    button{
      border:1px solid #e5e7eb;
      background:#fff;
      border-radius:12px;
      padding:8px 10px;
      font-weight:800;
      cursor:pointer;
    }
    button:active{transform:translateY(1px);}
    .side{
      display:flex;flex-direction:column;gap:10px;
      height:100%;
      overflow:hidden;
    }
    .control{
      border:1px solid #e5e7eb;border-radius:14px;padding:10px 12px;background:#fff;
    }
    .row{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:6px;}
    .label{font-weight:900;font-size:13px;}
    .val{min-width:44px;text-align:left;direction:ltr;font-weight:900;color:#0f172a;font-size:13px;}
    input[type="range"]{width:100%;accent-color:#0b7285;}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    select, input[type="number"], input[type="text"]{
      width:100%;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid #e5e7eb;
      background:#fff;
      font-weight:800;
      color:#111827;
      font-size:13px;
    }
    .hint{font-size:11px;color:#6b7280;line-height:1.35;margin-top:6px;}
    .badge{
      display:inline-block;margin-inline-start:6px;
      padding:2px 8px;border-radius:999px;border:1px solid #e5e7eb;
      font-size:10px;background:#f8fafc;color:#334155;font-weight:900;
    }
    .mini{font-size:12px;font-weight:800;color:#334155;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="left">
      <div class="panel">
        <h3>פרומפט מתעדכן (תיאור תכנית/חתכים + הגיון המלצה)</h3>
        <div id="prompt"></div>
      </div>

      <div class="canvasWrap">
        <canvas id="cv"></canvas>
        <div class="caption">איזומטריה סכמטית</div>
      </div>

      <div class="panel">
        <div class="rowBtns">
          <button id="btnDownloadSvg">הורד איזומטריה (SVG)</button>
          <button id="btnDownloadTxt">הורד סיכום/פרומפט (TXT)</button>
        </div>
        <div class="hint">הורדה = “חלופה” להצגה בכנס (ציור + פרומפט + פרמטרים). אפשר להרחיב ל-PDF בהמשך.</div>
      </div>
    </div>

    <div class="side">

      <div class="control">
        <div class="row">
          <div class="label">מידות החדר <span class="badge">מ׳</span></div>
          <div class="mini">הזנה ידנית</div>
        </div>
        <div class="grid2">
          <div>
            <div class="mini">אורך (m)</div>
            <input id="inL" type="number" step="0.01" value="4.20" />
          </div>
          <div>
            <div class="mini">רוחב (m)</div>
            <input id="inW" type="number" step="0.01" value="3.60" />
          </div>
        </div>
        <div style="margin-top:10px;">
          <div class="mini">גובה (m)</div>
          <input id="inH" type="number" step="0.01" value="2.80" />
          <div class="hint">יש לכתוב במטרים (לדוגמה: 2.80).</div>
        </div>
      </div>

      <div class="control">
        <div class="row">
          <div class="label">דלת (תמיד בקיר הקדמי) <span class="badge">ס״מ</span></div>
        </div>
        <div class="mini">מרחק מהפינה השמאלית (cm)</div>
        <input id="inDoorOffsetCm" type="number" step="1" value="60" />
        <div class="hint">הקיר הקדמי = הקיר שפונה אלינו באיזומטריה (לצורך פיילוט עקבי).</div>
      </div>

      <div class="control">
        <div class="row">
          <div class="label">חלון ביחס לדלת <span class="badge">ס״מ</span></div>
        </div>
        <div class="grid2">
          <div>
            <div class="mini">מיקום חלון</div>
            <select id="selWinRel">
              <option value="facing">מול הדלת</option>
              <option value="right">מימין לדלת</option>
              <option value="left">משמאל לדלת</option>
            </select>
          </div>
          <div>
            <div class="mini">מרחק מהפינה (cm)</div>
            <input id="inWinOffsetCm" type="number" step="1" value="80" />
          </div>
        </div>
        <div class="hint">“מול הדלת” = בקיר האחורי. “ימין/שמאל” = על הקיר הימני/השמאלי של החלל.</div>
      </div>

      <div class="control">
        <div class="row">
          <div class="label">תנוחת השולחן <span class="badge">Desk</span></div>
        </div>
        <select id="selDeskMode">
          <option value="auto">אוטומטי לפי ההעדפות</option>
          <option value="facing">מול החלון</option>
          <option value="side">לצד החלון</option>
          <option value="back">גב לחלון</option>
        </select>
      </div>

      <div class="control">
        <div class="row">
          <div class="label">יעילות <span class="badge">Performance</span></div>
          <div class="val" id="v_perf"></div>
        </div>
        <input id="s_perf" type="range" min="0" max="100" value="70" />
      </div>

      <div class="control">
        <div class="row">
          <div class="label">תחושת פרטיות <span class="badge">Privacy</span></div>
          <div class="val" id="v_priv"></div>
        </div>
        <input id="s_priv" type="range" min="0" max="100" value="55" />
      </div>

      <div class="control">
        <div class="row">
          <div class="label">שליטה בחלל <span class="badge">Control</span></div>
          <div class="val" id="v_ctrl"></div>
        </div>
        <input id="s_ctrl" type="range" min="0" max="100" value="60" />
      </div>

      <div class="control">
        <div class="row">
          <div class="label">שלומות <span class="badge">Wellbeing</span></div>
          <div class="val" id="v_well"></div>
        </div>
        <input id="s_well" type="range" min="0" max="100" value="65" />
        <div class="hint">גודל החלון נקבע אוטומטית לפי העדפות (בשלב הבא נחליף את החוקים במשקלים מהנתונים שלך).</div>
      </div>

    </div>
  </div>

<script>
/* -----------------------------
   State
------------------------------ */
const S = {
  L: 4.20, W: 3.60, H: 2.80, // meters
  doorOffsetCm: 60,          // from left corner on FRONT wall
  winRel: 'facing',          // facing | right | left
  winOffsetCm: 80,           // from "relevant left corner" of that wall
  deskMode: 'auto',

  perf: 70, priv: 55, ctrl: 60, well: 65
};

const clamp = (x,min,max)=> Math.max(min, Math.min(max, x));
const clamp100 = x => Math.round(clamp(x,0,100));

/* -----------------------------
   Preference links (nudges)
------------------------------ */
const links = [
  { from:'priv', to:'perf', w:-0.25 },
  { from:'priv', to:'ctrl', w:+0.30 },
  { from:'ctrl', to:'well', w:+0.25 },
  { from:'well', to:'perf', w:+0.20 },
  { from:'perf', to:'well', w:-0.10 }
];

function applyLinks(changedKey, prevValue, newValue){
  const delta = newValue - prevValue;
  if (!delta) return;
  const damping = 0.55;
  for (const L of links){
    if (L.from !== changedKey) continue;
    S[L.to] = clamp100(S[L.to] + delta * L.w * damping);
  }
}

/* -----------------------------
   Data-driven window sizing (MVP rule)
   Later: replace with your effect sizes / model outputs
------------------------------ */
function decideWindowRatio(){
  // ratio of wall length (0.15..0.65)
  const p = S;
  let r =
    (p.well > 72 && p.priv < 60) ? 0.55 :
    (p.priv > 78) ? 0.25 :
    (p.perf > 78) ? 0.42 :
    0.35;

  // tiny modulation from control (more control -> slightly larger allowed)
  r += (p.ctrl - 50) * 0.001; // -0.05..+0.05 approx
  return clamp(r, 0.15, 0.65);
}

function decideDeskMode(){
  if (S.deskMode !== 'auto') return S.deskMode;
  const p = S;
  return (p.perf > 72 && p.priv > 60) ? 'side'
       : (p.well > 72 && p.priv < 55) ? 'facing'
       : (p.priv > 78) ? 'back'
       : 'side';
}

function deskHeb(m){
  return m==='facing'?'מול החלון':m==='side'?'לצד החלון':'גב לחלון';
}

/* -----------------------------
   Isometric drawing (Canvas) + SVG export
------------------------------ */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

let lastSvg = ""; // for download

function resizeCanvas(){
  const r = cv.getBoundingClientRect();
  cv.width  = Math.floor(r.width  * devicePixelRatio);
  cv.height = Math.floor(r.height * devicePixelRatio);
}

function isoProject(x,y,z, scale, ox, oy){
  const X = (x - y) * scale;
  const Y = (x + y) * scale * 0.5 - z * scale;
  return { x: ox + X, y: oy + Y };
}

function svgLine(x1,y1,x2,y2, stroke="#111827", w=2){
  return `<line x1="${x1.toFixed(2)}" y1="${y1.toFixed(2)}" x2="${x2.toFixed(2)}" y2="${y2.toFixed(2)}" stroke="${stroke}" stroke-width="${w}" stroke-linecap="round" stroke-linejoin="round" />`;
}

function drawScene(){
  const L = Math.max(1.5, S.L), W = Math.max(1.5, S.W), H = Math.max(2.0, S.H);

  // "front wall" is ALWAYS S wall (y=0), facing viewer in this consistent pilot.
  const FRONT = 'S';
  const BACK  = 'N';
  const LEFT  = 'W';
  const RIGHT = 'E';

  const w = cv.width, h = cv.height;
  ctx.clearRect(0,0,w,h);

  // scale: smaller (to guarantee no scroll + nice fit)
  const pad = 34 * devicePixelRatio;
  const maxSpan = (L + W);
  const scale = (Math.min(w,h) - 2*pad) / (maxSpan * 1.35);
  const ox = w/2;
  const oy = h*0.70;

  // background
  ctx.fillStyle = '#f7f7f7';
  ctx.fillRect(0,0,w,h);

  const P = (pt)=> isoProject(pt.x,pt.y,pt.z,scale,ox,oy);

  // room corners
  const A={x:0,y:0,z:0}, B={x:L,y:0,z:0}, C={x:L,y:W,z:0}, D={x:0,y:W,z:0};
  const A2={x:0,y:0,z:H}, B2={x:L,y:0,z:H}, C2={x:L,y:W,z:H}, D2={x:0,y:W,z:H};

  const pA=P(A), pB=P(B), pC=P(C), pD=P(D), pA2=P(A2), pB2=P(B2), pC2=P(C2), pD2=P(D2);

  function line(p1,p2,stroke="#111827", lw=2){
    ctx.strokeStyle = stroke;
    ctx.lineWidth = lw * devicePixelRatio;
    ctx.beginPath();
    ctx.moveTo(p1.x,p1.y);
    ctx.lineTo(p2.x,p2.y);
    ctx.stroke();
  }

  // base
  line(pA,pB); line(pB,pC); line(pC,pD); line(pD,pA);
  // verticals
  line(pA,pA2); line(pB,pB2); line(pC,pC2); line(pD,pD2);
  // top
  line(pA2,pB2); line(pB2,pC2); line(pC2,pD2); line(pD2,pA2);

  // --- Door on FRONT wall (S): y=0, offset from left corner (x=0)
  const doorW = 0.90; // m
  const doorH = Math.min(2.10, H*0.78);
  let doorX0 = clamp(S.doorOffsetCm/100, 0, Math.max(0, L - doorW));
  const d0={x:doorX0,y:0,z:0}, d1={x:doorX0+doorW,y:0,z:0}, d0t={x:doorX0,y:0,z:doorH}, d1t={x:doorX0+doorW,y:0,z:doorH};

  const pd0=P(d0), pd1=P(d1), pd0t=P(d0t), pd1t=P(d1t);
  line(pd0,pd1,"#334155",2.2);
  line(pd0t,pd1t,"#334155",2.2);
  line(pd0,pd0t,"#334155",2.2);
  line(pd1,pd1t,"#334155",2.2);

  // --- Window wall based on relation to door
  let winWall = (S.winRel==='facing') ? BACK : (S.winRel==='right') ? RIGHT : LEFT;

  const winRatio = decideWindowRatio();
  const wallLen = (winWall===BACK || winWall===FRONT) ? L : W;
  const winLen = wallLen * winRatio;

  // window height and sill (simple)
  const winH = clamp(H*0.45, 0.8, 1.4);
  const winZ0 = clamp(H*0.40 - winH/2, 0.7, H-0.7-winH);

  // offset from "left corner" of that wall (in cm -> m).
  // For BACK/FRONT walls: offset along +x.
  // For LEFT/RIGHT walls: offset along +y.
  let offm = clamp(S.winOffsetCm/100, 0, Math.max(0, wallLen - winLen));

  // compute endpoints
  let w0b, w1b;
  if (winWall===BACK){        // y=W
    w0b={x:offm, y:W, z:winZ0};
    w1b={x:offm+winLen, y:W, z:winZ0};
  } else if (winWall===FRONT){ // y=0 (not used in this rel logic, but kept)
    w0b={x:offm, y:0, z:winZ0};
    w1b={x:offm+winLen, y:0, z:winZ0};
  } else if (winWall===RIGHT){ // x=L
    w0b={x:L, y:offm, z:winZ0};
    w1b={x:L, y:offm+winLen, z:winZ0};
  } else {                    // LEFT x=0
    w0b={x:0, y:offm, z:winZ0};
    w1b={x:0, y:offm+winLen, z:winZ0};
  }
  const w0t={x:w0b.x,y:w0b.y,z:winZ0+winH}, w1t={x:w1b.x,y:w1b.y,z:winZ0+winH};

  const pw0b=P(w0b), pw1b=P(w1b), pw0t=P(w0t), pw1t=P(w1t);
  line(pw0b,pw1b,"#0b7285",2.4);
  line(pw0t,pw1t,"#0b7285",2.4);
  line(pw0b,pw0t,"#0b7285",2.4);
  line(pw1b,pw1t,"#0b7285",2.4);

  // --- Desk placement relative to window wall
  const mode = decideDeskMode();
  const deskW = 1.20, deskD = 0.60, deskH = 0.75;
  const wallOff = 0.75;

  let cx=L/2, cy=W/2;

  function towardInteriorFromWall(wall, dist){
    if (wall===BACK) return {x:L/2, y:W - dist};
    if (wall===FRONT) return {x:L/2, y:dist};
    if (wall===RIGHT) return {x:L - dist, y:W/2};
    return {x:dist, y:W/2}; // LEFT
  }
  function nearWallSide(wall, dist, bias){
    if (wall===BACK || wall===FRONT){
      return { x: clamp(L/2 + (L*0.25)*bias, 0.8, L-0.8),
               y: (wall===BACK) ? W - dist : dist };
    } else {
      return { x: (wall===RIGHT) ? L - dist : dist,
               y: clamp(W/2 + (W*0.25)*bias, 0.8, W-0.8) };
    }
  }

  if (mode==='facing'){
    const p=towardInteriorFromWall(winWall, wallOff); cx=p.x; cy=p.y;
  } else if (mode==='back'){
    const opposite = (winWall===BACK)?FRONT:(winWall===FRONT)?BACK:(winWall===RIGHT)?LEFT:RIGHT;
    const p=towardInteriorFromWall(opposite, wallOff); cx=p.x; cy=p.y;
  } else { // side
    const p=nearWallSide(winWall, wallOff, +1); cx=p.x; cy=p.y;
  }
  cx = clamp(cx, 0.8, L-0.8);
  cy = clamp(cy, 0.8, W-0.8);

  const x0=cx-deskW/2, x1=cx+deskW/2, y0=cy-deskD/2, y1=cy+deskD/2;
  const dbA={x:x0,y:y0,z:0}, dbB={x:x1,y:y0,z:0}, dbC={x:x1,y:y1,z:0}, dbD={x:x0,y:y1,z:0};
  const dtA={x:x0,y:y0,z:deskH}, dtB={x:x1,y:y0,z:deskH}, dtC={x:x1,y:y1,z:deskH}, dtD={x:x0,y:y1,z:deskH};

  // desk lines
  line(P(dbA),P(dbB),"#111827",2);
  line(P(dbB),P(dbC),"#111827",2);
  line(P(dbC),P(dbD),"#111827",2);
  line(P(dbD),P(dbA),"#111827",2);
  line(P(dbA),P(dtA),"#111827",2);
  line(P(dbB),P(dtB),"#111827",2);
  line(P(dbC),P(dtC),"#111827",2);
  line(P(dbD),P(dtD),"#111827",2);
  line(P(dtA),P(dtB),"#111827",2);
  line(P(dtB),P(dtC),"#111827",2);
  line(P(dtC),P(dtD),"#111827",2);
  line(P(dtD),P(dtA),"#111827",2);

  // build SVG for export (same geometry, screen coords)
  const svgW = cv.width / devicePixelRatio;
  const svgH = cv.height / devicePixelRatio;
  const toSvgPt = (pt)=> {
    const sp = isoProject(pt.x,pt.y,pt.z,scale/devicePixelRatio, (svgW/2), (svgH*0.70));
    return sp;
  };

  const lines = [];

  // room edges
  const pts = {A,B,C,D,A2,B2,C2,D2};
  const edges = [
    ['A','B'],['B','C'],['C','D'],['D','A'],
    ['A','A2'],['B','B2'],['C','C2'],['D','D2'],
    ['A2','B2'],['B2','C2'],['C2','D2'],['D2','A2']
  ];
  for (const [u,v] of edges){
    const p1=toSvgPt(pts[u]), p2=toSvgPt(pts[v]);
    lines.push(svgLine(p1.x,p1.y,p2.x,p2.y,"#111827",2));
  }

  // door
  const doorPts = [d0,d1,d0t,d1t];
  const doorEdges = [[0,1],[2,3],[0,2],[1,3]];
  for (const [i,j] of doorEdges){
    const p1=toSvgPt(doorPts[i]), p2=toSvgPt(doorPts[j]);
    lines.push(svgLine(p1.x,p1.y,p2.x,p2.y,"#334155",2));
  }

  // window
  const winPts=[w0b,w1b,w0t,w1t];
  const winEdges=[[0,1],[2,3],[0,2],[1,3]];
  for (const [i,j] of winEdges){
    const p1=toSvgPt(winPts[i]), p2=toSvgPt(winPts[j]);
    lines.push(svgLine(p1.x,p1.y,p2.x,p2.y,"#0b7285",2.2));
  }

  // desk
  const deskPts=[dbA,dbB,dbC,dbD,dtA,dtB,dtC,dtD];
  const deskEdges=[
    [0,1],[1,2],[2,3],[3,0],
    [0,4],[1,5],[2,6],[3,7],
    [4,5],[5,6],[6,7],[7,4]
  ];
  for (const [i,j] of deskEdges){
    const p1=toSvgPt(deskPts[i]), p2=toSvgPt(deskPts[j]);
    lines.push(svgLine(p1.x,p1.y,p2.x,p2.y,"#111827",1.9));
  }

  lastSvg = `
<svg xmlns="http://www.w3.org/2000/svg" width="${svgW}" height="${svgH}" viewBox="0 0 ${svgW} ${svgH}">
  <rect x="0" y="0" width="${svgW}" height="${svgH}" fill="#ffffff"/>
  ${lines.join("\n  ")}
</svg>`.trim();

  // Update prompt text
  updatePrompt({winWall, winLen, winRatio, mode});
}

function wallHeb(w){
  return (w==='N')?'אחורי (מול הדלת)':(w==='E')?'ימני':(w==='S')?'קדמי (דלת)': 'שמאלי';
}

function updatePrompt(meta){
  const winWallHeb = wallHeb(meta.winWall);
  const winLenMeters = meta.winLen;
  const winLenCm = Math.round(winLenMeters*100);

  const text = [
    `מידות: ${S.L.toFixed(2)}×${S.W.toFixed(2)} מ׳ | גובה ${S.H.toFixed(2)} מ׳`,
    `דלת: קיר קדמי | מרחק מהפינה השמאלית: ${Math.round(S.doorOffsetCm)} ס״מ`,
    `חלון: ${winWallHeb} | מרחק מהפינה: ${Math.round(S.winOffsetCm)} ס״מ | אורך חלון (אוטומטי): ${winLenCm} ס״מ (~${Math.round(meta.winRatio*100)}% מהקיר)`,
    `שולחן: ${deskHeb(meta.mode)}${S.deskMode==='auto'?' (Auto)':''}`,
    ``,
    `העדפות (0–100): יעילות ${S.perf} | פרטיות ${S.priv} | שליטה ${S.ctrl} | שלומות ${S.well}`,
    ``,
    `Prompt (פיילוט):`,
    `“תכנן חלל עבודה ביתי מלבני במידות ${S.L.toFixed(2)}×${S.W.toFixed(2)} מ׳ וגובה ${S.H.toFixed(2)} מ׳.`,
    `מקם דלת בקיר הקדמי במרחק ${Math.round(S.doorOffsetCm)} ס״מ מהפינה השמאלית.`,
    `מקם חלון ${winWallHeb} במרחק ${Math.round(S.winOffsetCm)} ס״מ מהפינה, באורך ${winLenCm} ס״מ (נגזר מהעדפות).`,
    `מקם שולחן ${deskHeb(meta.mode)} ביחס לחלון. שמור על איזון בין יעילות לשלומות, תוך התייחסות לפרטיות ושליטה.”`
  ].join("\n");

  document.getElementById('prompt').textContent = text;

  // update preference numbers
  document.getElementById('v_perf').textContent = S.perf;
  document.getElementById('v_priv').textContent = S.priv;
  document.getElementById('v_ctrl').textContent = S.ctrl;
  document.getElementById('v_well').textContent = S.well;
}

/* -----------------------------
   Inputs wiring
------------------------------ */
const inL = document.getElementById('inL');
const inW = document.getElementById('inW');
const inH = document.getElementById('inH');
const inDoorOffsetCm = document.getElementById('inDoorOffsetCm');
const selWinRel = document.getElementById('selWinRel');
const inWinOffsetCm = document.getElementById('inWinOffsetCm');
const selDeskMode = document.getElementById('selDeskMode');

function readDims(){
  S.L = clamp(parseFloat(inL.value || "0"), 2.0, 10.0);
  S.W = clamp(parseFloat(inW.value || "0"), 2.0, 10.0);
  S.H = clamp(parseFloat(inH.value || "0"), 2.2, 4.0);
}
function readOpenings(){
  S.doorOffsetCm = clamp(parseFloat(inDoorOffsetCm.value || "0"), 0, (S.L*100 - 90));
  S.winRel = selWinRel.value;
  S.winOffsetCm = clamp(parseFloat(inWinOffsetCm.value || "0"), 0, 1000); // later clamped per wall length
}
function readDesk(){
  S.deskMode = selDeskMode.value;
}

function redraw(){
  readDims();
  readOpenings();
  readDesk();

  // clamp window offset to its wall length (after deciding wall)
  // we compute a conservative max based on the smallest possible wall length
  // final clamping is done inside drawScene anyway.
  resizeCanvas();
  drawScene();
}

[inL,inW,inH,inDoorOffsetCm,inWinOffsetCm].forEach(el=>{
  el.addEventListener('input', redraw);
});
selWinRel.addEventListener('change', redraw);
selDeskMode.addEventListener('change', redraw);

// preference sliders
function setPref(key, value){
  const prev = S[key];
  const next = clamp100(parseFloat(value));
  S[key] = next;
  applyLinks(key, prev, next);

  // reflect nudges into UI sliders
  document.getElementById('s_perf').value = S.perf;
  document.getElementById('s_priv').value = S.priv;
  document.getElementById('s_ctrl').value = S.ctrl;
  document.getElementById('s_well').value = S.well;

  redraw();
}
document.getElementById('s_perf').addEventListener('input', e=>setPref('perf', e.target.value));
document.getElementById('s_priv').addEventListener('input', e=>setPref('priv', e.target.value));
document.getElementById('s_ctrl').addEventListener('input', e=>setPref('ctrl', e.target.value));
document.getElementById('s_well').addEventListener('input', e=>setPref('well', e.target.value));

/* -----------------------------
   Download helpers
------------------------------ */
function downloadText(filename, text){
  const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
document.getElementById('btnDownloadSvg').addEventListener('click', ()=>{
  if (!lastSvg) redraw();
  downloadText('workspace_isometry.svg', lastSvg);
});
document.getElementById('btnDownloadTxt').addEventListener('click', ()=>{
  const txt = document.getElementById('prompt').textContent;
  downloadText('workspace_prompt.txt', txt);
});

/* -----------------------------
   Boot
------------------------------ */
window.addEventListener('resize', ()=>{ resizeCanvas(); drawScene(); });
resizeCanvas();
drawScene();
</script>
</body>
</html>
