<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>משימת חיבור נקודות – ניסוי קשב (עם מעקב עיניים)</title>

  <!-- WebGazer -->
  <script src="https://webgazer.cs.brown.edu/webgazer.js" type="text/javascript"></script>

  <style>
    :root{
      --bg:#020617;
      --panel:#0b1120;
      --ink:#e5e7eb;
      --muted:#94a3b8;
      --accent:#e5e7eb;
      --stroke:#64748b;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      display:grid;
      grid-template-rows:auto 1fr auto;
    }
    header,footer{
      background:var(--panel);
      padding:10px 16px;
      border-bottom:1px solid #111827;
    }
    footer{
      border-top:1px solid #111827;
      border-bottom:none;
      font-size:0.8rem;
      color:var(--muted);
      text-align:center;
    }
    .top{
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:center;
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      justify-content:center;
      align-items:center;
    }
    label{font-size:0.9rem;color:var(--muted);}
    input{
      background:#020617;
      border:1px solid #334155;
      color:var(--ink);
      padding:4px 8px;
      border-radius:8px;
      min-width:120px;
    }
    input[readonly]{opacity:0.8;}
    button{
      border-radius:999px;
      border:1px solid #334155;
      background:#111827;
      color:var(--ink);
      padding:6px 14px;
      cursor:pointer;
      font-size:0.9rem;
    }
    button:disabled{
      opacity:0.4;
      cursor:not-allowed;
    }
    button:hover:not(:disabled){
      border-color:#60a5fa;
    }
    #stageWrap{
      padding:10px 16px 16px;
      position:relative;
    }
    #stage{
      width:100%;
      height:70vh;
      display:block;
      background:#020617;
      border-radius:18px;
      border:1px solid #1f2937;
      touch-action:none;
    }
    #overlay{
      position:absolute;
      inset:10px 16px 16px;
      display:none;
      place-items:center;
      background:rgba(15,23,42,0.82);
      border-radius:18px;
    }
    #overlay .box{
      background:#020617;
      border-radius:16px;
      border:1px solid #1f2937;
      padding:20px 24px;
      max-width:360px;
      text-align:center;
    }
    #overlay h2{
      margin-top:0;
      margin-bottom:8px;
    }
    .muted{color:var(--muted);}

    /* שכבת כיול */
    #calibOverlay{
      position:absolute;
      inset:10px 16px 16px;
      display:none;
      place-items:center;
      background:rgba(15,23,42,0.75);
      border-radius:18px;
      pointer-events:auto;
    }
    #calibDot{
      position:absolute;
      width:22px;
      height:22px;
      border-radius:999px;
      background:#f97373;
      box-shadow:0 0 12px rgba(248,113,113,0.9);
      cursor:pointer;
    }
    #calibText{
      position:absolute;
      bottom:24px;
      width:100%;
      text-align:center;
      color:var(--ink);
      font-size:0.9rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="top">
      <div class="muted">
        המשימה תימשך עד <b>10 דקות</b> או עד לחיצה על "סיום מוקדם".
      </div>
      <div class="controls">
        <label for="pid">מזהה נבדק:</label>
        <input id="pid" type="text" placeholder="לדוגמה OR010125" />

        <!-- כיול -->
        <button id="calibBtn">כיול מעקב עיניים</button>
        <button id="finishCalibBtn" disabled>סיום כיול</button>

        <!-- סשן -->
        <button id="startBtn" disabled>התחל סשן</button>
        <button id="endBtn" disabled>סיום מוקדם</button>
      </div>
    </div>
  </header>

  <div id="stageWrap">
    <canvas id="stage"></canvas>

    <!-- שכבת נקודת הכיול -->
    <div id="calibOverlay">
      <div id="calibDot"></div>
      <div id="calibText">הסתכל/י על הנקודה ולחץ/י עליה (1/9)</div>
    </div>

    <div id="overlay">
      <div class="box">
        <h2 id="overlayTitle">סיום הסשן</h2>
        <p id="overlayText" class="muted"></p>
        <button id="overlayContinue">המשך</button>
      </div>
    </div>
  </div>

  <footer>
    יש ללחוץ על המספרים לפי סדר עולה. ניתן להסיר בחירה על ידי לחיצה חוזרת על אותו מספר.
  </footer>

<script>
(() => {
  // ======================= CONFIG =======================
  const CONFIG = {
    sessionMinutes: 10,
    initialPoints: 12,
    incrementBy: 2,
    minDistance: 30,
    lineAvoidDistance: 16,
    margin: 30
  };

  // ---- Form 2 (summary) ----
  const FORM_ID = "1FAIpQLSdTCgLVjt4LXsNAkXP1H8jxIC5MPsdv1sD93v5lmglckCAzrA";
  const ENTRY_PID             = "entry.404955311";
  const ENTRY_TOTAL_TASKS     = "entry.1331557537";
  const ENTRY_POINTS_PER_TASK = "entry.742152065";
  const ENTRY_ERRORS_PER_TASK = "entry.1634677467";
  const ENTRY_DUR_PER_TASK    = "entry.529234118";
  const ENTRY_EXPERIMENT_TIME = "entry.883845532";
  const FORM_BASE_URL =
    "https://docs.google.com/forms/d/e/" + FORM_ID + "/viewform?usp=pp_url&";

  // ---- Form 3 (task log) ----
  const LOG_FORM_ID = "1FAIpQLSdrl006D8HAWo0YfsdWUMppGEewGOp8Snm3ANot8OxzSBkusA";
  const LOG_FORM_BASE =
    "https://docs.google.com/forms/d/e/" + LOG_FORM_ID + "/formResponse?";
  const LOG_ENTRY_PID        = "entry.152946855";
  const LOG_ENTRY_TASK       = "entry.781109584";
  const LOG_ENTRY_N_POINTS   = "entry.347168050";
  const LOG_ENTRY_ERRORS     = "entry.1932703164";
  const LOG_ENTRY_DURATION   = "entry.1227866932";
  const LOG_ENTRY_COMPLETED  = "entry.1100470565";
  const LOG_ENTRY_TIMESTAMP  = "entry.1243807469";

  // ======================= DOM =======================
  const canvas = document.getElementById("stage");
  const ctx = canvas.getContext("2d");
  const pidInput = document.getElementById("pid");
  const startBtn = document.getElementById("startBtn");
  const endBtn = document.getElementById("endBtn");
  const overlay = document.getElementById("overlay");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlayText = document.getElementById("overlayText");
  const overlayContinue = document.getElementById("overlayContinue");

  const calibBtn = document.getElementById("calibBtn");
  const finishCalibBtn = document.getElementById("finishCalibBtn");
  const calibOverlay = document.getElementById("calibOverlay");
  const calibDot = document.getElementById("calibDot");
  const calibText = document.getElementById("calibText");

  // ======================= STATE =======================
  let running = false;
  let sessionStart = null;
  let experimentStartIso = null;
  let tickId = null;

  let tasks = [];
  let taskCounter = 0;
  let currentTask = null;
  let pendingNextTaskPoints = null;
  let sessionEnded = false;

  // Calibration
  let calibrationStarted = false;
  let calibrationDone    = false;
  const CALIB_POINTS = [
    {x:0.1, y:0.1},
    {x:0.5, y:0.1},
    {x:0.9, y:0.1},
    {x:0.1, y:0.5},
    {x:0.5, y:0.5},
    {x:0.9, y:0.5},
    {x:0.1, y:0.9},
    {x:0.5, y:0.9},
    {x:0.9, y:0.9}
  ];
  let calibIndex = 0;
  let calibStartTime = 0;
  const CALIB_MAX_MS = 20000;

  // Gaze log
  const gazeSamples = [];
  let lastGazeSampleTime = 0;
  const GAZE_SAMPLE_INTERVAL = 50;

  // ======================= Helpers =======================
  function getPidFromUrl(){
    const p = new URLSearchParams(window.location.search);
    return p.get("pid") || "";
  }

  function now(){ return performance.now(); }

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  function randomBetween(min,max){ return min + Math.random()*(max-min); }

  function distance(a,b){ return Math.hypot(a.x-a.x, a.y-a.y); }

  function pointToSegmentDistance(p,a,b){
    const vx=b.x-a.x, vy=b.y-a.y;
    const wx=p.x-a.x, wy=p.y-a.y;
    const c1=vx*wx+vy*wy;
    if(c1<=0) return Math.hypot(p.x-a.x,p.y-a.y);
    const c2=vx*vx+vy*vy;
    if(c2<=c1) return Math.hypot(p.x-b.x,p.y-b.y);
    const t=c1/c2;
    const px=a.x+t*vx, py=a.y+t*vy;
    return Math.hypot(p.x-px,p.y-py);
  }

  // ======================= Tasks =======================
  function generatePoints(n){
    const rect = canvas.getBoundingClientRect();
    const m = CONFIG.margin;
    const W = Math.max(rect.width - 2*m, 220);
    const H = Math.max(rect.height - 2*m, 220);

    const pts = [];
    let attempts=0, maxAttempts=4000;

    while(pts.length<n && attempts<maxAttempts){
      attempts++;
      const c={ x:randomBetween(m,m+W), y:randomBetween(m,m+H) };
      let ok=true;

      for(const p of pts){
        if(Math.hypot(p.x-c.x,p.y-c.y)<CONFIG.minDistance){ ok=false; break; }
      }
      if(!ok) continue;

      for(let i=1;i<pts.length;i++){
        const d=pointToSegmentDistance(c,pts[i-1],pts[i]);
        if(d<CONFIG.lineAvoidDistance){ ok=false; break; }
      }
      if(!ok) continue;

      pts.push(c);
    }

    while(pts.length<n){
      pts.push({ x:randomBetween(m,m+W), y:randomBetween(m,m+H) });
    }
    return pts;
  }

  function openNewTask(n){
    pendingNextTaskPoints = null;
    currentTask = {
      index: ++taskCounter,
      points: generatePoints(n),
      selected: new Set(),
      selectionOrder: [],
      errors: 0,
      startTime: now()
    };
    draw();
  }

  // ======================= Draw =======================
  function draw(){
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
    if(!currentTask) return;

    const pts=currentTask.points;
    const order=currentTask.selectionOrder;

    if(order.length>1){
      ctx.strokeStyle="#e5e7eb";
      ctx.lineWidth=2;
      ctx.beginPath();
      const first=pts[order[0]];
      ctx.moveTo(first.x,first.y);
      for(let i=1;i<order.length;i++){
        const p=pts[order[i]];
        ctx.lineTo(p.x,p.y);
      }
      ctx.stroke();
    }

    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.font="14px system-ui, Arial";

    pts.forEach((p,idx)=>{
      const chosen=currentTask.selected.has(idx);
      const r=13;
      if(chosen){
        ctx.fillStyle="#e5e7eb";
        ctx.beginPath();
        ctx.arc(p.x,p.y,r,0,Math.PI*2);
        ctx.fill();
        ctx.fillStyle="#020617";
        ctx.fillText(String(idx+1),p.x,p.y);
      }else{
        ctx.fillStyle="#020617";
        ctx.beginPath();
        ctx.arc(p.x,p.y,r,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle="#64748b";
        ctx.lineWidth=1.5;
        ctx.stroke();
        ctx.fillStyle="#e5e7eb";
        ctx.fillText(String(idx+1),p.x,p.y);
      }
    });
  }

  // ======================= Interaction =======================
  function hitTest(x,y){
    if(!currentTask) return -1;
    const pts=currentTask.points;
    for(let i=0;i<pts.length;i++){
      const p=pts[i];
      if(Math.hypot(p.x-x,p.y-y)<=18) return i;
    }
    return -1;
  }

  function isPerfectSequence(task){
    const order=task.selectionOrder;
    const n=task.points.length;
    if(order.length!==n) return false;
    for(let i=0;i<n;i++) if(order[i]!==i) return false;
    return true;
  }

  function resetAttempt(task){
    task.selected.clear();
    task.selectionOrder=[];
    draw();
  }

  function handlePointerDown(ev){
    if(!running || !currentTask || pendingNextTaskPoints!==null) return;

    const rect=canvas.getBoundingClientRect();
    const cx=ev.touches?ev.touches[0].clientX:ev.clientX;
    const cy=ev.touches?ev.touches[0].clientY:ev.clientY;
    const x=cx-rect.left, y=cy-rect.top;

    const idx=hitTest(x,y);
    if(idx===-1) return;

    const task=currentTask;
    const sel=task.selected;

    if(sel.has(idx)){
      sel.delete(idx);
      task.selectionOrder=task.selectionOrder.filter(i=>i!==idx);
      draw();
      return;
    }

    sel.add(idx);
    task.selectionOrder.push(idx);
    draw();

    if(task.selectionOrder.length===task.points.length){
      if(isPerfectSequence(task)){
        completeCurrentTask();
      }else{
        task.errors++;
        resetAttempt(task);
      }
    }
  }

  canvas.addEventListener("pointerdown",handlePointerDown);
  canvas.addEventListener("touchstart",handlePointerDown,{passive:true});

  // ======================= Task log =======================
  function sendTaskToLogForm(row){
    const p=new URLSearchParams();
    p.set(LOG_ENTRY_PID,row.pid);
    p.set(LOG_ENTRY_TASK,String(row.task));
    p.set(LOG_ENTRY_N_POINTS,String(row.n_points));
    p.set(LOG_ENTRY_ERRORS,String(row.errors));
    p.set(LOG_ENTRY_DURATION,String(row.duration_ms));
    p.set(LOG_ENTRY_COMPLETED,String(row.completed));
    p.set(LOG_ENTRY_TIMESTAMP,row.ts);

    const url=LOG_FORM_BASE+p.toString();
    if(navigator.sendBeacon) navigator.sendBeacon(url);
    else fetch(url,{method:"GET",mode:"no-cors"}).catch(()=>{});
  }

  function logTask(completed){
    if(!currentTask) return;
    const end=now();
    const dur=Math.round(end-currentTask.startTime);
    const pid=(pidInput.value||"").trim();

    const row={
      pid,
      task:currentTask.index,
      n_points:currentTask.points.length,
      errors:currentTask.errors,
      duration_ms:dur,
      completed:completed?1:0,
      ts:new Date().toISOString()
    };

    tasks.push(row);
    sendTaskToLogForm(row);
  }

  function completeCurrentTask(){
    logTask(true);
    const nextN=currentTask.points.length+CONFIG.incrementBy;
    pendingNextTaskPoints=nextN;
    currentTask=null;
    draw();

    overlayTitle.textContent="סיימת משימה";
    overlayText.textContent="לחץ/י על \"משימה הבאה\" כדי להמשיך.";
    overlayContinue.textContent="משימה הבאה";
    overlay.style.display="grid";

    overlayContinue.onclick=()=>{
      overlay.style.display="none";
      if(running && pendingNextTaskPoints!==null){
        openNewTask(pendingNextTaskPoints);
      }
    };
  }

  function tick(){
    if(!running) return;
    const elapsed=(now()-sessionStart)/1000;
    if(elapsed>=CONFIG.sessionMinutes*60){
      endSession(true);
    }
  }

  // ======================= CSV builders =======================
  function buildCsvTasks(){
    if(!tasks.length) return "";
    const head=["pid","task","n_points","errors","duration_ms","completed","ts"];
    const rows=tasks.map(t=>[
      t.pid,t.task,t.n_points,t.errors,t.duration_ms,t.completed,t.ts
    ].join(","));
    return head.join(",")+"\n"+rows.join("\n");
  }

  function buildCsvGaze(){
    if(!gazeSamples.length) return "";
    const head=["t_ms_session","has_gaze","x_px","y_px","in_viewport"];
    const rows=gazeSamples.map(s=>[
      s.t_ms,
      s.hasGaze?1:0,
      s.hasGaze?Math.round(s.x):"",
      s.hasGaze?Math.round(s.y):"",
      s.inViewport?1:0
    ].join(","));
    return head.join(",")+"\n"+rows.join("\n");
  }

  function downloadCsv(content,filename){
    if(!content) return;
    const blob=new Blob([content],{type:"text/csv"});
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download=filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{URL.revokeObjectURL(a.href);a.remove();},0);
  }

  function buildFormSummary(){
    const completed=tasks.filter(t=>t.completed===1);
    const total=completed.length;
    let ppt="", ept="", dpt="";
    if(completed.length){
      ppt=completed.map(t=>t.n_points).join(",");
      ept=completed.map(t=>t.errors).join(",");
      dpt=completed.map(t=>t.duration_ms).join(",");
    }
    return {
      totalTasksCompleted:total,
      pointsPerTask:ppt,
      errorsPerTask:ept,
      durPerTask:dpt,
      experimentTime:experimentStartIso||""
    };
  }

  function redirectToForm(){
    const pid=(pidInput.value||"").trim();
    const s=buildFormSummary();
    const p=new URLSearchParams();
    p.set(ENTRY_PID,pid||"");
    p.set(ENTRY_TOTAL_TASKS,String(s.totalTasksCompleted));
    p.set(ENTRY_POINTS_PER_TASK,s.pointsPerTask);
    p.set(ENTRY_ERRORS_PER_TASK,s.errorsPerTask);
    p.set(ENTRY_DUR_PER_TASK,s.durPerTask);
    p.set(ENTRY_EXPERIMENT_TIME,s.experimentTime);
    window.location.href=FORM_BASE_URL+p.toString();
  }

  function endSession(autoEnded){
    if(sessionEnded){ redirectToForm(); return; }
    sessionEnded=true;
    running=false;
    if(tickId) clearInterval(tickId);
    startBtn.disabled=false;
    endBtn.disabled=true;

    if(currentTask) logTask(false);

    const pid=(pidInput.value||"").trim();
    const safePid=(pid||"PID").replace(/[^a-zA-Z0-9_-]/g,"");

    const tasksCsv=buildCsvTasks();
    if(tasksCsv) downloadCsv(tasksCsv,"connect_the_dots_results_"+safePid+".csv");

    const gazeCsv=buildCsvGaze();
    if(gazeCsv) downloadCsv(gazeCsv,"connect_the_dots_gaze_"+safePid+".csv");

    overlayTitle.textContent=autoEnded?"הסשן הסתיים":"הסשן הופסק";
    overlayText.textContent="תודה על ביצוע המשימה. כעת נעבור לשאלון קצר נוסף.";
    overlayContinue.textContent="המשך לשאלון";
    overlay.style.display="grid";
    overlayContinue.onclick=()=>{overlay.style.display="none";redirectToForm();};
  }

  // ======================= Calibration =======================
  function showCalibPoint(){
    const pt=CALIB_POINTS[calibIndex];
    calibDot.style.left=(pt.x*100)+"%";
    calibDot.style.top =(pt.y*100)+"%";
    calibText.textContent=
      `הסתכל/י על הנקודה ולחץ/י עליה (${calibIndex+1}/${CALIB_POINTS.length})`;
  }

  function startCalibrationSequence(){
    calibIndex=0;
    calibStartTime=performance.now();
    calibOverlay.style.display="grid";
    showCalibPoint();
  }

  function handleCalibClick(){
    calibIndex++;
    const elapsed=performance.now()-calibStartTime;
    const finishedByCount=calibIndex>=CALIB_POINTS.length;
    const finishedByTime =elapsed>=CALIB_MAX_MS;
    if(finishedByCount || finishedByTime){
      finishCalibrationSequence();
    }else{
      showCalibPoint();
    }
  }

  function finishCalibrationSequence(){
    calibOverlay.style.display="none";
    finishCalibration();
  }

  async function startCalibration(){
    if(!window.webgazer){
      alert("WebGazer לא נטען. ניתן לבצע את המשימה גם בלי מעקב עיניים.");
      return;
    }
    if(calibrationStarted) return;

    calibrationStarted=true;
    calibBtn.disabled=true;
    finishCalibBtn.disabled=false;

    try{
      await webgazer.setRegression('ridge');
      await webgazer.setTracker('clmtrackr');
      webgazer.params.showVideoPreview=true;
      webgazer.params.showPredictionPoints=true;
      await webgazer.begin();
      startCalibrationSequence();
    }catch(err){
      console.error(err);
      alert("שגיאה בהפעלת WebGazer. אפשר להמשיך בלי מעקב עיניים.");
      calibrationStarted=false;
      calibBtn.disabled=false;
      finishCalibBtn.disabled=true;
      calibOverlay.style.display="none";
    }
  }

  function finishCalibration(){
    if(!calibrationStarted) return;
    calibrationDone=true;
    finishCalibBtn.disabled=true;
    pidInput.disabled=false;
    startBtn.disabled=false;
    if(window.webgazer){
      webgazer.showVideoPreview(false);
      webgazer.showPredictionPoints(false);
    }
    calibOverlay.style.display="none";
  }

  // ======================= Session start =======================
  function startSession(){
    if(!calibrationDone){
      alert("נא לבצע קודם כיול מעקב עיניים.");
      return;
    }
    const pid=(pidInput.value||"").trim();
    if(!pid){
      alert("נא למלא מזהה נבדק לפני תחילת הסשן.");
      return;
    }

    running=true;
    sessionEnded=false;
    sessionStart=now();
    experimentStartIso=new Date().toISOString();
    tasks=[];
    taskCounter=0;
    currentTask=null;
    pendingNextTaskPoints=null;
    overlay.style.display="none";
    startBtn.disabled=true;
    endBtn.disabled=false;

    gazeSamples.length=0;
    lastGazeSampleTime=0;

    openNewTask(CONFIG.initialPoints);
    if(tickId) clearInterval(tickId);
    tickId=setInterval(tick,500);
  }

  function handleEndClick(){ endSession(false); }

  // ======================= Gaze listener =======================
  function setupGazeListener(){
    if(!window.webgazer) return;
    webgazer.setGazeListener((data,elapsed)=>{
      if(!running || !sessionStart) return;
      const tSession=now()-sessionStart;
      if(tSession-lastGazeSampleTime<GAZE_SAMPLE_INTERVAL) return;
      lastGazeSampleTime=tSession;

      if(!data){
        gazeSamples.push({
          t_ms:Math.round(tSession),
          hasGaze:false,
          x:null,
          y:null,
          inViewport:false
        });
        return;
      }

      const x=data.x, y=data.y;
      const inViewport=
        x>=0 && x<=window.innerWidth &&
        y>=0 && y<=window.innerHeight;

      gazeSamples.push({
        t_ms:Math.round(tSession),
        hasGaze:true,
        x,y,
        inViewport
      });
    });
  }

  // ======================= Init =======================
  const urlPid=getPidFromUrl();
  if(urlPid){ pidInput.value=urlPid; pidInput.readOnly=true; }
  pidInput.disabled=true;

  window.addEventListener("resize",resizeCanvas);
  resizeCanvas();

  startBtn.addEventListener("click",startSession);
  endBtn.addEventListener("click",handleEndClick);
  calibBtn.addEventListener("click",startCalibration);
  finishCalibBtn.addEventListener("click",finishCalibration);
  calibDot.addEventListener("click",handleCalibClick);

  window.addEventListener("beforeunload",()=>{
    if(window.webgazer) webgazer.end();
  });

  setupGazeListener();
})();
</script>
</body>
</html>
