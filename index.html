<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Connect-the-Dots + Head Tracking (Clean)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel: rgba(15,26,46,.86);
      --text:#e6eaf2;
      --muted:#9aa6bf;
      --btnbg: rgba(17,28,51,.88);
      --border: rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);

      --dot: rgba(230,234,242,0.90);
      --blue: rgba(120,170,255,.95);
      --blueLast: rgba(90,145,255,.98);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 70% -10%, #233a6b 0%, transparent 55%),
                  radial-gradient(900px 600px at 10% 10%, #1a6a5f 0%, transparent 60%),
                  var(--bg);
      color:var(--text);
      overflow:hidden;
    }

    .topBar{
      position:fixed;
      top:14px;
      left:50%;
      transform:translateX(-50%);
      width:min(900px, calc(100% - 24px));
      padding: 10px;
      background: rgba(15,26,46,.55);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 999px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      z-index: 6;
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .btn{
      border: 1px solid var(--border);
      background: var(--btnbg);
      color: var(--text);
      padding: 10px 16px;
      border-radius: 999px;
      cursor:pointer;
      font-size: 14.5px;
      transition: transform .05s ease, opacity .2s ease, border-color .2s ease;
      user-select:none;
      white-space:nowrap;
      min-width: 140px;
      text-align:center;
    }
    .btn:hover{border-color: rgba(255,255,255,.22)}
    .btn:active{transform: translateY(1px)}
    .btn[disabled]{opacity:.45; cursor:not-allowed}
    .btn.early{ border-color: rgba(251,113,133,.35); color:#ffe4e8; }

    .pidOverlay{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index: 5;
      pointer-events:none;
    }
    .pidCard{
      pointer-events:auto;
      width:min(560px, 100%);
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 22px;
      box-shadow: var(--shadow);
      padding:18px 18px 16px;
      backdrop-filter: blur(10px);
      text-align:center;
    }
    .pidCard h2{margin:0 0 8px; font-size: 18px; font-weight: 700;}
    .pidCard p{margin:0 0 14px; color: var(--muted); font-size: 14px; line-height:1.35;}
    input[type="text"]{
      width: min(260px, 100%);
      padding: 12px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline:none;
      font-size: 16px;
      letter-spacing: 1px;
      text-transform: uppercase;
      text-align:center;
    }
    input[type="text"]::placeholder{color: rgba(230,234,242,.45)}
    .pidHint{margin-top:10px; color: rgba(230,234,242,.62); font-size: 12.5px;}
    .pidWarn{margin-top:10px; color: rgba(255,210,210,.90); font-size: 12.5px; display:none;}

    .stage{
      position:fixed;
      inset:0;
      padding-top: 68px;
      z-index: 1;
    }
    canvas#cv{width:100%; height:100%; display:block;}

    .overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index: 10;
    }
    .card{
      width:min(540px, 100%);
      background: rgba(15,26,46,.92);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 22px;
      box-shadow: var(--shadow);
      padding:18px;
      backdrop-filter: blur(10px);
      text-align:center;
    }
    .card h2{margin:0 0 8px; font-size: 20px}
    .card p{margin:0 0 14px; color: var(--muted); line-height:1.4}
    .card .actions{display:flex; justify-content:center; gap:10px; flex-wrap:wrap;}

    .hiddenCam{
      position: fixed;
      left: -9999px;
      top: -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
    }

    @media (max-width: 560px){
      .stage{padding-top: 112px;}
      .btn{min-width: 120px;}
    }
  </style>
</head>

<body>
  <div class="topBar">
    <button id="btnStart" class="btn" disabled>×”×ª×—×œ ××©×™××”</button>
    <button id="btnEarly" class="btn early" disabled>×¡×™×•× ××•×§×“×</button>
  </div>

  <div id="pidOverlay" class="pidOverlay">
    <div class="pidCard">
      <h2>×”×–×™× ×• ××–×”×” × ×‘×“×§</h2>
      <p>3 ××•×ª×™×•×ª ×× ×’×œ×™×ª + 3 ×¡×¤×¨×•×ª (×œ××©×œ ABC123)</p>
      <input id="pid" type="text" placeholder="ABC123" maxlength="6" autocomplete="off" inputmode="latin" />
      <script>
        (function () {
          const pidEl = document.getElementById('pid');
          const btnStart = document.getElementById('btnStart');

          function validPID(pid){ return /^[A-Z]{3}[0-9]{3}$/.test(pid); }

          function update(){
            let v = (pidEl.value || "").toUpperCase();
            v = v.replace(/[^A-Z0-9]/g,'').slice(0,6);
            pidEl.value = v;
            btnStart.disabled = !validPID(v);
          }

          pidEl.addEventListener('input', update);
          window.addEventListener('pageshow', update);
          update();
        })();
      </script>
      <div class="pidHint">×œ××—×¨ ×”×–× ×ª ×§×•×“ ×ª×§×™×Ÿ, ×›×¤×ª×•×¨ "×”×ª×—×œ ××©×™××”" ×™×•×¤×¢×œ</div>
      <div id="secureWarn" class="pidWarn">
        âš ï¸ ××¦×œ××” ×“×•×¨×©×ª <b>http://localhost</b> ××• <b>https</b>. ××œ ×ª×¨×™×¥ ×“×¨×š file://
      </div>
    </div>
  </div>

  <div class="stage">
    <canvas id="cv"></canvas>
  </div>

  <div id="taskOverlay" class="overlay" role="dialog" aria-modal="true">
    <div class="card">
      <h2>××¢×•×œ×” ğŸ‰</h2>
      <p>×‘×•× × ××©×™×š ×œ××©×™××” ×”×‘××”</p>
      <div class="actions">
        <button id="btnContinue" class="btn">×”××©×š</button>
      </div>
    </div>
  </div>

  <div id="followupOverlay" class="overlay" role="dialog" aria-modal="true" style="display:none;">
    <div class="card">
      <h2>×ª×•×“×” ×¨×‘×”! ğŸ™</h2>
      <p id="followupMsg">×‘×•××• × ××©×™×š ×œ×©××œ×•×Ÿ ×§×¦×¨(×•××—×¨×•×Ÿ).</p>
      <div class="actions">
        <button id="btnFollowup" class="btn">×œ×©××œ×•×Ÿ ×”××©×š</button>
      </div>
    </div>
  </div>

  <video id="video" class="hiddenCam" playsinline autoplay muted></video>

<script type="module">
(() => {
  // ---- Config
  const EXP_DURATION_MS = 10 * 60 * 1000;
  const DOT_COUNT = 16;

  const DOT_RADIUS = 14;
  const DOT_LABEL_SIZE = 14;
  const LINE_WIDTH = 3;

  const MIN_DIST = 52;
  const EDGE_PAD = 28;
  const MAX_TRIES = 5000;

  // Head thresholds
  const YAW_T = 29;      // degrees
  const PITCH_T = 18;    // degrees

  // Timeline sampling
  const TIMELINE_DT_MS = 100;

  // ---- Drive Upload (Google Apps Script Web App)
  const DRIVE_WEBAPP_URL = "https://script.google.com/macros/s/AKfycbzzL6_C4miqkMb46vs9qVYRnp1_uzq1ZdrSR7fk-J8s1HBIxwN-ad3OAQrNAAd6PHd2/exec";

  // ---- Follow-up form
  // Base URL you provided:
  const FOLLOWUP_FORM_BASE_URL = "https://docs.google.com/forms/d/e/1FAIpQLSdTCgLVjt4LXsNAkXP1H8jxIC5MPsdv1sD93v5lmglckCAzrA/viewform?usp=pp_url";

  // IMPORTANT:
  // Put here the PID field parameter from Google Forms, e.g. "entry.1234567890"
  // If you leave it empty ("") the form will open normally without PID prefill.
  const FORM_PID_ENTRY_PARAM = "entry.404955311";
  // ---- DOM
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const pidEl = document.getElementById('pid');
  const pidOverlay = document.getElementById('pidOverlay');
  const secureWarn = document.getElementById('secureWarn');

  const btnStart = document.getElementById('btnStart');
  const btnEarly = document.getElementById('btnEarly');

  const taskOverlay = document.getElementById('taskOverlay');
  const btnContinue = document.getElementById('btnContinue');

  const followupOverlay = document.getElementById('followupOverlay');
  const followupMsgEl = document.getElementById('followupMsg');
  const btnFollowup = document.getElementById('btnFollowup');

  const video = document.getElementById('video');

  // ---- State
  let sessionRunning = false;
  let taskActive = false;
  let startAt = null;
  let rafId = null;

  // We'll keep the participant PID available for followup link even after resetUI()
  let followupPid = null;

  let dots = [];
  let connections = [];
  let selectedSet = new Set();

  const log = {
    meta: {
      pid: null,
      createdAtISO: new Date().toISOString(),
      durationMsPlanned: EXP_DURATION_MS,
      dotCount: DOT_COUNT
    },
    session: {
      startedAtISO: null,
      endedAtISO: null,
      endedReason: null,
      actualDurationMs: null,
      totalTasksCompleted: 0,
      totalErrors: 0,
      totalAttempts: 0
    },
    tasks: []
  };

  let taskIndex = 0;
  let currentTask = null;
  let currentAttempt = null;

  // Head tracking
  let faceLandmarker = null;
  let headRunning = false;
  let lastVideoTime = -1;

  window.__HEAD_STATE__ = {
    tsPerf: null,
    attention: "WAITING",
    reason: "WAITING",
    yawDeg: 0,
    pitchDeg: 0,
    ok: false
  };

  const timeline = [];
  let timelineTimer = null;

  // ---- Helpers
  function validPID(pid){ return /^[A-Z]{3}[0-9]{3}$/.test(pid); }

  function isSecureEnough(){
    if (window.isSecureContext) return true;
    const h = location.hostname;
    return (h === "localhost" || h === "127.0.0.1");
  }

  function getPidSafe(){
    const p = String(log.meta.pid || "PID").toUpperCase().replace(/[^A-Z0-9]/g,'');
    return p || "PID";
  }

  function isoStamp(){
    return new Date().toISOString().replace(/[:.]/g,'-');
  }

  // ---- beforeunload warning (ONLY during active session)
  window.addEventListener('beforeunload', (e) => {
    if (!sessionRunning) return;
    e.preventDefault();
    e.returnValue = ""; // triggers browser generic warning (where supported)
  });

  // ---- Followup URL builder (PID prefill if FORM_PID_ENTRY_PARAM is set)
  function buildFollowupUrl(){
    try{
      const url = new URL(FOLLOWUP_FORM_BASE_URL);
      if (FORM_PID_ENTRY_PARAM && typeof FORM_PID_ENTRY_PARAM === "string" && FORM_PID_ENTRY_PARAM.startsWith("entry.")) {
        url.searchParams.set(FORM_PID_ENTRY_PARAM, (followupPid || "").toUpperCase());
      }
      return url.toString();
    } catch {
      // fallback (shouldn't happen)
      return FOLLOWUP_FORM_BASE_URL;
    }
  }

  // ---- Upload helpers (UTF-8 safe base64)
  function base64EncodeUtf8(str){
    const bytes = new TextEncoder().encode(str);
    let binary = "";
    for (let i=0;i<bytes.length;i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  async function uploadFilesToDrive({ pid, files }){
    if (!DRIVE_WEBAPP_URL || !/^https:\/\/script\.google\.com\/macros\/s\//.test(DRIVE_WEBAPP_URL)){
      throw new Error("×—×¡×¨ ×§×™×©×•×¨ ×”×¢×œ××” (Web App URL) ×©×œ Apps Script.");
    }

    const payload = {
      pid,
      files: (files || []).map(f => ({
        filename: f.filename,
        mimeType: f.mimeType || "text/plain",
        contentBase64: base64EncodeUtf8(f.content || "")
      }))
    };

    const res = await fetch(DRIVE_WEBAPP_URL, {
      method: "POST",
      body: JSON.stringify(payload) // no headers => text/plain => avoids preflight in many cases
    });

    const json = await res.json().catch(() => ({}));
    if (!res.ok || !json.ok){
      throw new Error(json.error || ("Upload failed (HTTP " + res.status + ")"));
    }
    return json;
  }

  function resizeCanvas(){
    const r = window.devicePixelRatio || 1;
    const rect = cv.getBoundingClientRect();
    cv.width = Math.floor(rect.width * r);
    cv.height = Math.floor(rect.height * r);
    ctx.setTransform(r,0,0,r,0,0);
    draw();
  }

  function randInt(min, max){ return Math.floor(Math.random()*(max-min+1)) + min; }
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

  function getPointerPos(e){
    const rect = cv.getBoundingClientRect();
    const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
    const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top };
  }

  function pickDotAt(pos){
    const r = DOT_RADIUS + 6;
    let best = null, bestD = Infinity;
    for (let i=0;i<dots.length;i++){
      const d = Math.hypot(pos.x-dots[i].x, pos.y-dots[i].y);
      if (d <= r && d < bestD){ bestD = d; best = i; }
    }
    return best;
  }

  function generateDots(){
    const rect = cv.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const pts = [];
    let tries = 0;

    while (pts.length < DOT_COUNT && tries < MAX_TRIES){
      tries++;
      const p = { x: randInt(EDGE_PAD, Math.floor(w-EDGE_PAD)),
                  y: randInt(EDGE_PAD, Math.floor(h-EDGE_PAD)) };
      let ok = true;
      for (const q of pts){
        if (dist(p,q) < MIN_DIST) { ok = false; break; }
      }
      if (ok) pts.push(p);
    }

    if (pts.length < DOT_COUNT){
      while (pts.length < DOT_COUNT && tries < MAX_TRIES*2){
        tries++;
        const p = { x: randInt(EDGE_PAD, Math.floor(w-EDGE_PAD)),
                    y: randInt(EDGE_PAD, Math.floor(h-EDGE_PAD)) };
        let ok = true;
        for (const q of pts){
          if (dist(p,q) < Math.max(30, MIN_DIST*0.75)) { ok = false; break; }
        }
        if (ok) pts.push(p);
      }
    }
    return pts;
  }

  // ---- Drawing
  function draw(){
    const rect = cv.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    ctx.clearRect(0,0,w,h);

    const g = ctx.createRadialGradient(w*0.55,h*0.35, 60, w*0.55,h*0.35, Math.max(w,h));
    g.addColorStop(0, 'rgba(138,164,255,0.10)');
    g.addColorStop(1, 'rgba(0,0,0,0.00)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.lineWidth = LINE_WIDTH;
    ctx.strokeStyle = 'rgba(138,164,255,0.85)';
    if (connections.length > 1){
      ctx.beginPath();
      const first = dots[connections[0]];
      ctx.moveTo(first.x, first.y);
      for (let k=1;k<connections.length;k++){
        const p = dots[connections[k]];
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }

    const lastPicked = connections.length ? connections[connections.length-1] : null;

    for (let i=0;i<dots.length;i++){
      const p = dots[i];
      const isPicked = selectedSet.has(i);
      const isLast = (lastPicked === i);

      ctx.beginPath();
      ctx.arc(p.x,p.y, DOT_RADIUS, 0, Math.PI*2);

      if (isLast) ctx.fillStyle = 'rgba(90,145,255,0.98)';
      else if (isPicked) ctx.fillStyle = 'rgba(120,170,255,0.95)';
      else ctx.fillStyle = 'rgba(230,234,242,0.90)';
      ctx.fill();

      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.stroke();

      ctx.font = `700 ${DOT_LABEL_SIZE}px system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
      ctx.fillStyle = 'rgba(10,18,32,0.92)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(i+1), p.x, p.y+0.5);
    }
  }

  // ---- Attempts
  function startAttempt(){
    connections = [];
    selectedSet = new Set();

    currentAttempt = {
      attemptIndex: (currentTask.attempts.length + 1),
      startedAtMs: Date.now(),
      endedAtMs: null,
      durationMs: null,
      clicks: []
    };
    currentTask.attempts.push(currentAttempt);
    log.session.totalAttempts += 1;

    draw();
  }

  function endAttempt(success, reason){
    if (!currentAttempt || currentAttempt.endedAtMs) return;
    currentAttempt.endedAtMs = Date.now();
    currentAttempt.durationMs = currentAttempt.endedAtMs - currentAttempt.startedAtMs;
    currentAttempt.success = success;
    currentAttempt.endReason = reason;
  }

  function validateIfComplete(){
    if (connections.length < DOT_COUNT) return;

    let ok = true;
    for (let i=0;i<DOT_COUNT;i++){
      if (connections[i] !== i){ ok = false; break; }
    }

    if (ok){
      endAttempt(true, 'completed_correct');
      completeTask();
    } else {
      endAttempt(false, 'completed_wrong');
      log.session.totalErrors += 1;
      currentTask.errors += 1;
      startAttempt();
    }
  }

  // ---- Task/session
  function startNewTask(){
    taskIndex++;
    dots = generateDots();

    currentTask = {
      taskIndex,
      dots: dots.map(p => ({x:p.x, y:p.y})),
      startedAtMs: Date.now(),
      endedAtMs: null,
      durationMs: null,
      errors: 0,
      completed: false,
      attempts: []
    };
    log.tasks.push(currentTask);

    taskActive = true;
    taskOverlay.style.display = 'none';

    startAttempt();
  }

  function showContinueOverlay(){
    taskActive = false;
    taskOverlay.style.display = 'flex';
  }

  function completeTask(){
    currentTask.endedAtMs = Date.now();
    currentTask.durationMs = currentTask.endedAtMs - currentTask.startedAtMs;
    currentTask.completed = true;

    log.session.totalTasksCompleted += 1;
    showContinueOverlay();
  }

  async function startSession(pid){
    if (!isSecureEnough()){
      alert("×”××¦×œ××” ×“×•×¨×©×ª https ××• http://localhost. ××œ ×ª×¨×™×¥ ×“×¨×š file://");
      return;
    }

    btnStart.disabled = true;
    btnEarly.disabled = true;

    try{
      await initHeadTracking();
    } catch (e){
      console.error(e);
      alert("×™×© ×©×’×™××” ×‘×”×¤×¢×œ×ª ×”××¦×œ××”/××•×“×œ. ×¤×ª×— F12 > Console ×›×“×™ ×œ×¨××•×ª ×œ××”.");
      btnStart.disabled = false;
      btnEarly.disabled = true;
      return;
    }

    sessionRunning = true;
    log.meta.pid = pid;
    followupPid = pid; // keep PID for the form link
    log.session.startedAtISO = new Date().toISOString();
    startAt = Date.now();

    pidEl.disabled = true;
    pidOverlay.style.display = 'none';

    btnEarly.disabled = false;

    startTimelineSampling();
    startNewTask();
    cancelAnimationFrame(rafId);
    loop();
  }

  async function finish(reason){
    if (!sessionRunning) return;
    sessionRunning = false;
    taskActive = false;
    cancelAnimationFrame(rafId);

    stopTimelineSampling();

    const endAt = Date.now();

    if (currentAttempt && !currentAttempt.endedAtMs){
      endAttempt(false, 'session_end');
    }

    if (currentTask && !currentTask.endedAtMs){
      currentTask.endedAtMs = endAt;
      currentTask.durationMs = currentTask.endedAtMs - currentTask.startedAtMs;
      currentTask.completed = false;
    }

    log.session.endedAtISO = new Date().toISOString();
    log.session.endedReason = reason;
    log.session.actualDurationMs = endAt - startAt;

    taskOverlay.style.display = 'none';

    // Prepare payload for background upload
    const pidSafe = getPidSafe();
    followupPid = pidSafe; // keep PID even after resetUI()
    const ts = isoStamp();

    const timelineCsv = buildTimelineCSVString();
    const offSummaryCsv = buildOffSummaryCSVString();
    const reportCsv = buildReportCSVString();

    const filesToSend = [
      { filename: `${pidSafe}_timeline_${ts}.csv`,     mimeType: "text/csv;charset=utf-8", content: timelineCsv },
      { filename: `${pidSafe}_off_summary_${ts}.csv`,  mimeType: "text/csv;charset=utf-8", content: offSummaryCsv },
      { filename: `${pidSafe}_report_${ts}.csv`,       mimeType: "text/csv;charset=utf-8", content: reportCsv }
    ];

    stopHeadTracking();

    // Show overlay immediately (no waiting)
    resetUI();
    showFollowupOverlay('×ª×•×“×” ×¨×‘×”! ×‘×•××• × ××©×™×š ×œ×©××œ×•×Ÿ ×§×¦×¨...×•××—×¨×•×Ÿ:)â€¦');

    // Background upload (non-blocking)
    uploadFilesToDrive({ pid: pidSafe, files: filesToSend })
      .then(() => {
        if (followupMsgEl) {
          followupMsgEl.textContent = '×ª×•×“×” ×¨×‘×”! ×‘×•××• × ××©×™×š ×œ×©××œ×•×Ÿ ×§×¦×¨(×•××—×¨×•×Ÿ)';
        }
      })
      .catch((e) => {
        console.error(e);
        if (followupMsgEl) {
          followupMsgEl.textContent = '×ª×•×“×” ×¨×‘×”! ×‘×•××• × ××©×™×š ×œ×©××œ×•×Ÿ ×§×¦×¨(×•××—×¨×•×Ÿ) (×©×™××• ×œ×‘: ×”×™×™×ª×” ×‘×¢×™×” ×‘×©×œ×™×—×ª ×”×§×‘×¦×™× ×œ-Drive â€” ×× × ×¢×“×›× ×• ××ª ×”×—×•×§×¨/×ª.)';
        }
      });
  }

  function loop(){
    if (!sessionRunning) return;
    const remaining = EXP_DURATION_MS - (Date.now() - startAt);
    if (remaining <= 0){
      finish('timeout');
      return;
    }
    rafId = requestAnimationFrame(loop);
  }

  function resetUI(){
    sessionRunning = false;
    taskActive = false;
    taskIndex = 0;
    dots = [];
    connections = [];
    selectedSet = new Set();
    currentTask = null;
    currentAttempt = null;

    pidOverlay.style.display = 'flex';
    pidEl.disabled = false;
    pidEl.value = '';
    btnEarly.disabled = true;
    btnStart.disabled = true;

    log.meta.pid = null;
    log.session.startedAtISO = null;
    log.session.endedAtISO = null;
    log.session.endedReason = null;
    log.session.actualDurationMs = null;
    log.session.totalTasksCompleted = 0;
    log.session.totalErrors = 0;
    log.session.totalAttempts = 0;
    log.tasks = [];

    timeline.length = 0;

    draw();
  }

  // ---- CSV builders
  function buildReportCSVString(){
    const header = ['××¡×¤×¨ ××©×™××”','×–××Ÿ ××©×™××” (×©× ×™×•×ª)','×›××•×ª ×˜×¢×•×™×•×ª ×‘××©×™××”'];
    const rows = [header];

    const reasonTag = (log.session.endedReason === 'timeout') ? 'TIMEOUT'
                    : (log.session.endedReason === 'early')   ? 'EARLY'
                    : 'UNKNOWN';

    for (const t of log.tasks){
      if (!t.startedAtMs) continue;

      const durSec = (typeof t.durationMs === 'number') ? (t.durationMs/1000) : '';
      const durStr = (durSec === '') ? '' : String(Math.round(durSec*1000)/1000);

      const taskLabel = t.completed
        ? String(t.taskIndex)
        : `${t.taskIndex} (INCOMPLETE_${reasonTag})`;

      rows.push([taskLabel, durStr, String(t.errors || 0)]);
    }

    const esc = (v) => {
      const s = String(v ?? '');
      if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
      return s;
    };

    const csv = rows.map(r => r.map(esc).join(',')).join('\r\n');
    return '\uFEFF' + csv;
  }

  function buildTimelineCSVString(){
    const header = ['taskNumber','tFromSessionMs','tFromTaskMs','timeHundredths','onScreen/Offscreen','connections','OffDirection'];
    const rows = [header];

    for (const r of timeline){
      rows.push([
        r.taskNumber,
        r.tFromSessionMs,
        r.tFromTaskMs,
        r.timeHundredths,
        r["onScreen/Offscreen"],
        r.connections,
        r.OffDirection
      ]);
    }

    const esc = (v) => {
      const s = String(v ?? '');
      if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
      return s;
    };

    const csv = rows.map(r => r.map(esc).join(',')).join('\r\n');
    return '\uFEFF' + csv;
  }

  function buildOffSummaryCSVString(){
    const byTask = new Map();

    function ensureTask(taskNumber){
      const key = String(taskNumber ?? "");
      if (!byTask.has(key)){
        byTask.set(key, {
          taskNumber: key,
          totalTimePerTaskMs: 0,
          upCount: 0, upTimeMs: 0,
          downCount: 0, downTimeMs: 0,
          leftCount: 0, leftTimeMs: 0,
          rightCount: 0, rightTimeMs: 0,
          totalOffMs: 0
        });
      }
      return byTask.get(key);
    }

    for (const t of (log.tasks || [])){
      const taskKey = String(t.taskIndex ?? "");
      const rec = ensureTask(taskKey);
      if (typeof t.durationMs === "number") rec.totalTimePerTaskMs = t.durationMs;
    }

    const maxTaskMs = new Map();
    for (const r of timeline){
      const taskKey = String(r.taskNumber ?? "");
      const v = Number(r.tFromTaskMs);
      if (!Number.isFinite(v)) continue;
      maxTaskMs.set(taskKey, Math.max(maxTaskMs.get(taskKey) ?? 0, v));
    }
    for (const [taskKey, mx] of maxTaskMs.entries()){
      const rec = ensureTask(taskKey);
      if (!rec.totalTimePerTaskMs || rec.totalTimePerTaskMs === 0){
        rec.totalTimePerTaskMs = mx;
      }
    }

    const stateByTask = new Map();

    for (let i=0;i<timeline.length;i++){
      const r = timeline[i];
      const taskKey = String(r.taskNumber ?? "");
      if (!taskKey) continue;

      const rec = ensureTask(taskKey);

      const onoff = String(r["onScreen/Offscreen"] || "");
      const dir = String(r.OffDirection || "");

      const st = stateByTask.get(taskKey) ?? { inOff:false, dir:"" };

      if (onoff === "OFFSCREEN"){
        rec.totalOffMs += TIMELINE_DT_MS;

        if (dir === "UP") rec.upTimeMs += TIMELINE_DT_MS;
        else if (dir === "DOWN") rec.downTimeMs += TIMELINE_DT_MS;
        else if (dir === "LEFT") rec.leftTimeMs += TIMELINE_DT_MS;
        else if (dir === "RIGHT") rec.rightTimeMs += TIMELINE_DT_MS;
      }

      if (onoff === "OFFSCREEN"){
        if (!st.inOff){
          st.inOff = true;
          st.dir = dir;

          if (dir === "UP") rec.upCount += 1;
          else if (dir === "DOWN") rec.downCount += 1;
          else if (dir === "LEFT") rec.leftCount += 1;
          else if (dir === "RIGHT") rec.rightCount += 1;

        } else {
          if (dir && dir !== st.dir){
            st.dir = dir;

            if (dir === "UP") rec.upCount += 1;
            else if (dir === "DOWN") rec.downCount += 1;
            else if (dir === "LEFT") rec.leftCount += 1;
            else if (dir === "RIGHT") rec.rightCount += 1;
          }
        }
      } else {
        st.inOff = false;
        st.dir = "";
      }

      stateByTask.set(taskKey, st);
    }

    const header = [
      "taskNumber",
      "TOTAL TIME PER TASK",
      "no of UP EVENTS",
      "TOTAL TIME UP EVENTS",
      "no ofDOWN EVENTS",
      "TOTAL TIME Down EVENTS",
      "no ofLEFT EVENTS",
      "TOTAL TIME left EVENTS",
      "no ofRIGHT EVENTS",
      "TOTAL TIME right EVENTS",
      "TOTAL TIME OFF"
    ];

    const rows = [header];

    const sorted = [...byTask.values()].sort((a,b) => {
      const A = Number(a.taskNumber), B = Number(b.taskNumber);
      if (Number.isFinite(A) && Number.isFinite(B)) return A - B;
      return String(a.taskNumber).localeCompare(String(b.taskNumber));
    });

    for (const t of sorted){
      if (!t.taskNumber) continue;
      rows.push([
        t.taskNumber,
        t.totalTimePerTaskMs,
        t.upCount, t.upTimeMs,
        t.downCount, t.downTimeMs,
        t.leftCount, t.leftTimeMs,
        t.rightCount, t.rightTimeMs,
        t.totalOffMs
      ]);
    }

    const esc = (v) => {
      const s = String(v ?? "");
      if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
      return s;
    };

    const csv = rows.map(r => r.map(esc).join(",")).join("\r\n");
    return "\uFEFF" + csv;
  }

  // ---- TIMELINE sampling
  function mapReasonToOffDirection(reason){
    if (reason === "HEAD_LEFT")  return "LEFT";
    if (reason === "HEAD_RIGHT") return "RIGHT";
    if (reason === "HEAD_UP")    return "UP";
    if (reason === "HEAD_DOWN")  return "DOWN";
    return "";
  }

  function startTimelineSampling(){
    if (timelineTimer) clearInterval(timelineTimer);
    timelineTimer = setInterval(() => {
      if (!sessionRunning) return;

      const now = Date.now();
      const tFromSessionMs = now - startAt;

      const tFromTaskMs = (currentTask && currentTask.startedAtMs)
        ? (now - currentTask.startedAtMs)
        : null;

      const h = window.__HEAD_STATE__ || {};
      const onOff = (h.attention === "ON_TASK") ? "ONSCREEN"
                  : (h.attention === "OFF_TASK") ? "OFFSCREEN"
                  : "UNKNOWN";

      const offDir = (h.attention === "OFF_TASK") ? mapReasonToOffDirection(h.reason) : "";

      const timeHundredths = Math.round(tFromSessionMs / 10);

      timeline.push({
        taskNumber: currentTask ? currentTask.taskIndex : "",
        tFromSessionMs,
        tFromTaskMs: (tFromTaskMs == null ? "" : tFromTaskMs),
        timeHundredths,
        "onScreen/Offscreen": onOff,
        connections: connections.length,
        OffDirection: offDir
      });
    }, TIMELINE_DT_MS);
  }

  function stopTimelineSampling(){
    if (timelineTimer){
      clearInterval(timelineTimer);
      timelineTimer = null;
    }
  }

  // ---- Head tracking (MediaPipe)
  function yawPitchFromMatrix(m){
    const r02 = m[8];
    const r12 = m[9];
    const r22 = m[10];
    const r10 = m[1];
    const r11 = m[5];

    const yaw = Math.atan2(r02, r22);
    const pitch = Math.atan2(-r12, Math.sqrt(r10*r10 + r11*r11));

    return { yawDeg: yaw * 180/Math.PI, pitchDeg: pitch * 180/Math.PI };
  }

  function decideFromPose(yawDeg, pitchDeg){
    if (yawDeg >= YAW_T)  return { attention: "OFF_TASK", reason: "HEAD_LEFT"  };
    if (yawDeg <= -YAW_T) return { attention: "OFF_TASK", reason: "HEAD_RIGHT" };

    if (pitchDeg >= PITCH_T)  return { attention: "OFF_TASK", reason: "HEAD_DOWN" };
    if (pitchDeg <= -PITCH_T) return { attention: "OFF_TASK", reason: "HEAD_UP"   };

    return { attention: "ON_TASK", reason: "CENTER" };
  }

  async function loadVisionModule(){
    const candidates = [
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.12/vision_bundle.mjs",
      "https://unpkg.com/@mediapipe/tasks-vision@0.10.12/vision_bundle.mjs",
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.12",
      "https://unpkg.com/@mediapipe/tasks-vision@0.10.12"
    ];
    let lastErr = null;
    for (const url of candidates){
      try{
        const mod = await import(url);
        return mod;
      } catch(e){
        lastErr = e;
      }
    }
    throw lastErr ?? new Error("Failed to import tasks-vision");
  }

  async function initHeadTracking(){
    const vision = await loadVisionModule();
    const { FaceLandmarker, FilesetResolver } = vision;

    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user" },
      audio: false
    });

    video.srcObject = stream;

    await video.play().catch(()=>{});
    await new Promise(res => {
      if (video.readyState >= 2) return res();
      video.onloadedmetadata = () => res();
    });

    const fileset = await FilesetResolver.forVisionTasks(
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.12/wasm"
    );

    faceLandmarker = await FaceLandmarker.createFromOptions(fileset, {
      baseOptions: {
        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
        delegate: "GPU"
      },
      runningMode: "VIDEO",
      numFaces: 1,
      outputFacialTransformationMatrixes: true
    });

    headRunning = true;
    lastVideoTime = -1;
    requestAnimationFrame(headLoop);
  }

  function stopHeadTracking(){
    headRunning = false;
    try{
      if (video && video.srcObject){
        const tracks = video.srcObject.getTracks();
        tracks.forEach(t => t.stop());
      }
      video.srcObject = null;
    } catch {}
    faceLandmarker = null;
  }

  function headLoop(){
    if (!headRunning) return;

    if (video.readyState >= 2) {
      const now = performance.now();
      if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;

        const res = faceLandmarker.detectForVideo(video, now);

        if (res?.facialTransformationMatrixes?.length) {
          const m = res.facialTransformationMatrixes[0].data;
          const { yawDeg, pitchDeg } = yawPitchFromMatrix(m);
          const { attention, reason } = decideFromPose(yawDeg, pitchDeg);

          window.__HEAD_STATE__ = {
            tsPerf: now,
            attention,
            reason,
            yawDeg,
            pitchDeg,
            ok: true
          };
        } else {
          window.__HEAD_STATE__ = {
            tsPerf: now,
            attention: "TRACK_LOST",
            reason: "TRACK_LOST",
            yawDeg: 0,
            pitchDeg: 0,
            ok: false
          };
        }
      }
    }
    requestAnimationFrame(headLoop);
  }

  // ---- Input + buttons
  pidEl.addEventListener('input', () => {
    let v = pidEl.value.toUpperCase();
    v = v.replace(/[^A-Z0-9]/g,'').slice(0,6);
    pidEl.value = v;

    secureWarn.style.display = isSecureEnough() ? "none" : "block";
    btnStart.disabled = !validPID(v);
  });

  btnStart.addEventListener('click', async () => {
    const pid = (pidEl.value || '').toUpperCase();
    if (!validPID(pid)){
      alert('×§×•×“ ×œ× ×ª×§×™×Ÿ. ×™×© ×œ×”×–×™×Ÿ 3 ××•×ª×™×•×ª ×× ×’×œ×™×ª + 3 ×¡×¤×¨×•×ª (×œ××©×œ ABC123).');
      return;
    }
    await startSession(pid);
  });

  btnEarly.addEventListener('click', () => finish('early'));
  btnContinue.addEventListener('click', () => { if (sessionRunning) startNewTask(); });

  // ---- Follow-up questionnaire
  function showFollowupOverlay(message){
    try{
      if (followupMsgEl) followupMsgEl.textContent = message || '×ª×•×“×” ×¨×‘×”! ×‘×•××• × ××©×™×š ×œ×©××œ×•×Ÿ ×§×¦×¨(×•××—×¨×•×Ÿ)';
      if (pidOverlay) pidOverlay.style.display = 'none';
      if (taskOverlay) taskOverlay.style.display = 'none';
      if (followupOverlay) followupOverlay.style.display = 'flex';
    } catch(e){
      console.error('showFollowupOverlay error', e);
    }
  }

  if (btnFollowup){
    btnFollowup.addEventListener('click', () => {
      window.open(buildFollowupUrl(), '_blank', 'noopener');
    });
  }

  // ---- Canvas click logic
  function onPointerDown(e){
    if (!sessionRunning || !taskActive) return;
    e.preventDefault();

    const pos = getPointerPos(e);
    const hit = pickDotAt(pos);

    if (currentAttempt){
      currentAttempt.clicks.push({
        ts: Date.now(),
        x: pos.x, y: pos.y,
        hitDotIndex: (hit === null ? null : hit),
        action: null
      });
    }

    if (hit === null){
      if (currentAttempt) currentAttempt.clicks[currentAttempt.clicks.length-1].action = 'miss';
      return;
    }

    if (selectedSet.has(hit)){
      selectedSet.delete(hit);
      connections = connections.filter(idx => idx !== hit);
      if (currentAttempt) currentAttempt.clicks[currentAttempt.clicks.length-1].action = 'toggle_off';
      draw();
      return;
    }

    selectedSet.add(hit);
    connections.push(hit);
    if (currentAttempt) currentAttempt.clicks[currentAttempt.clicks.length-1].action = 'toggle_on';
    draw();

    if (connections.length === DOT_COUNT){
      validateIfComplete();
    }
  }

  cv.addEventListener('mousedown', onPointerDown);
  cv.addEventListener('touchstart', onPointerDown, { passive:false });

  window.addEventListener('resize', resizeCanvas);

  // init
  resizeCanvas();
  resetUI();
})();
</script>
</body>
</html>
