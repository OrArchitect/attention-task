<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>משימת חיבור נקודות – ניסוי קשב + WebGazer + Head</title>
  <style>
    :root{
      --bg:#020617;
      --panel:#0b1120;
      --ink:#e5e7eb;
      --muted:#94a3b8;
      --accent:#e5e7eb;
      --stroke:#64748b;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      display:grid;
      grid-template-rows:auto 1fr auto;
    }
    header,footer{
      background:var(--panel);
      padding:10px 16px;
      border-bottom:1px solid #111827;
    }
    footer{ border-top:1px solid #111827; border-bottom:none; }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .grow{flex:1;}
    input,button,select{
      background:#0f172a;
      color:var(--ink);
      border:1px solid #1f2937;
      border-radius:10px;
      padding:10px 12px;
      font-size:14px;
      outline:none;
    }
    button{cursor:pointer; font-weight:600;}
    button.primary{background:#111827; border-color:#334155;}
    button.good{background:rgba(34,197,94,.12); border-color:rgba(34,197,94,.45);}
    button.warn{background:rgba(245,158,11,.12); border-color:rgba(245,158,11,.45);}
    button.bad{background:rgba(239,68,68,.12); border-color:rgba(239,68,68,.45);}
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px;
      border:1px solid #1f2937; background:#0f172a;
      font-size:12px; color:var(--muted);
      user-select:none;
    }
    .pill strong{color:var(--ink);}
    main{display:grid; grid-template-columns:1fr 340px; gap:16px; padding:16px;}
    @media(max-width:980px){ main{grid-template-columns:1fr;} }
    .card{
      background:rgba(15,23,42,.65);
      border:1px solid #1f2937;
      border-radius:16px;
      overflow:hidden;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
    }
    .card h3{
      margin:0; padding:12px 14px;
      border-bottom:1px solid #1f2937;
      font-size:14px; color:var(--muted);
      letter-spacing:.2px;
    }
    .card .content{padding:12px 14px;}
    canvas{display:block; width:100%; height:70vh; background:#020617;}
    .small{font-size:12px; color:var(--muted); line-height:1.35;}
    .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}
    .kpi{
      display:grid; grid-template-columns:1fr 1fr; gap:8px;
      margin-top:10px;
    }
    .kpi .box{
      border:1px solid #1f2937; border-radius:12px; padding:10px;
      background:#0b1224;
    }
    .kpi .box .v{font-size:18px; font-weight:800; color:var(--ink);}
    .kpi .box .l{font-size:12px; color:var(--muted);}
    .hint{margin-top:8px; padding:10px 12px; border-radius:12px; border:1px dashed #334155; background:rgba(2,6,23,.45);}
  </style>

  <!-- WebGazer -->
  <script src="https://cdn.jsdelivr.net/npm/webgazer@2.1.0/dist/webgazer.min.js"></script>

  <!-- Mediapipe FaceMesh (Head tracking) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

</head>

<body>
<header>
  <div class="row">
    <div class="pill"><strong>ניסוי קשב:</strong> חבר את הנקודות + מעקב עיניים + Head</div>
    <div class="pill" id="miniStatus"><strong>סטטוס:</strong> ממתין</div>
    <div class="pill"><strong>זמן:</strong> <span id="timeLabel">00:00</span></div>
    <div class="grow"></div>
    <div class="row">
      <label class="pill">מזהה נבדק:
        <input id="pidInput" class="mono" placeholder="לדוגמה ABC123" style="width:160px; margin-inline-start:8px;" />
      </label>
      <button id="btnStart" class="primary">התחל משימה</button>
      <button id="btnStop" class="bad">סיום מוקדם</button>
    </div>
  </div>
</header>

<main>
  <div class="card">
    <h3>משימה</h3>
    <canvas id="c"></canvas>
  </div>

  <div class="card">
    <h3>בקרה</h3>
    <div class="content">
      <div class="small">
        <div class="hint">
          <div><strong>כיול:</strong> יתחיל אוטומטית אחרי "התחל משימה".</div>
          <div>1) כיול WebGazer (נקודות על המסך)</div>
          <div>2) כיול "ראש ניטרלי" (להחזיק מרכז)</div>
        </div>
      </div>

      <div class="kpi">
        <div class="box">
          <div class="v" id="kpiOn">0</div>
          <div class="l">On-screen ms</div>
        </div>
        <div class="box">
          <div class="v" id="kpiOff">0</div>
          <div class="l">Off-screen ms</div>
        </div>
        <div class="box">
          <div class="v" id="kpiOffEvents">0</div>
          <div class="l">OFF events</div>
        </div>
        <div class="box">
          <div class="v" id="kpiHeadDir">CENTER</div>
          <div class="l">Head dir</div>
        </div>
      </div>

      <div class="hint small">
        <div><strong>הסבר OFF:</strong> אם כיוון הראש הוא R/L/U/D (לא CENTER) ברצף של לפחות <span id="offMinTxt">1000</span>ms → נספר OFF ונרשום כיוון.</div>
        <div>אם אין Head tracking פעיל/מכויל → גיבוי לפי מיקום gaze ביחס למסך.</div>
      </div>

      <div style="margin-top:10px" class="row">
        <button id="btnDownload" class="good">הורד CSV (לבדיקה)</button>
        <button id="btnUpload" class="warn">שלח ל-Drive</button>
      </div>

      <div style="margin-top:10px" class="small mono" id="logBox"></div>
    </div>
  </div>
</main>

<footer>
  <div class="row small">
    <div>המשימה תימשך עד 10 דקות או עד לחיצה על "סיום מוקדם".</div>
    <div class="grow"></div>
    <div>WebGazer + FaceMesh</div>
  </div>
</footer>

<script>
  // ======================= CONFIG =======================
  // שים כאן את כתובת ה-Apps Script שלך (כמו שהיה אצלך בקובץ המקורי)
  // אם כבר יש לך SCRIPT_URL בקובץ – השארתי אותו.
  const SCRIPT_URL = window.SCRIPT_URL || ""; // אפשר להדביק כאן אם תרצה.

  const MAX_SESSION_MS = 10 * 60 * 1000;

  // OFF לפי ראש: חייב להחזיק לפחות 1 שניה מחוץ ל-CENTER
  const OFF_MIN_MS = 1000;

  // smoothing
  const SMOOTH_ALPHA = 0.25;

  // נקודות כיול WebGazer
  const CALIB_POINTS = 9;
  const CALIB_HOLD_MS = 700;

  // Head thresholds (45° בערך תלוי בקנה מידה של ה-yaw/pitch שנחשב פה; מכויל יחסית לניטרלי)
  // חשוב: אצלך כיוון ימין/שמאל היה הפוך, לכן שיניתי את המיפוי.
  const HEAD_YAW_THRESH = 0.11;
  const HEAD_PITCH_THRESH = 0.10;

  // EMA for head angles
  const HEAD_SMOOTH_ALPHA = 0.22;

  // internal paddings for task rendering
  const FRAME_MARGIN_X_RATIO = 0.12;
  const FRAME_MARGIN_Y_RATIO = 0.12;
  const POINT_INNER_PADDING = 0.10;

  document.getElementById("offMinTxt").textContent = OFF_MIN_MS.toString();

  // ======================= DOM =======================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const pidInput = document.getElementById("pidInput");
  const btnStart = document.getElementById("btnStart");
  const btnStop = document.getElementById("btnStop");
  const btnDownload = document.getElementById("btnDownload");
  const btnUpload = document.getElementById("btnUpload");

  const miniStatus = document.getElementById("miniStatus");
  const timeLabel = document.getElementById("timeLabel");

  const kpiOn = document.getElementById("kpiOn");
  const kpiOff = document.getElementById("kpiOff");
  const kpiOffEvents = document.getElementById("kpiOffEvents");
  const kpiHeadDir = document.getElementById("kpiHeadDir");

  const logBox = document.getElementById("logBox");

  function log(msg){
    const t = new Date().toLocaleTimeString();
    logBox.innerHTML = `<div>[${t}] ${msg}</div>` + logBox.innerHTML;
  }

  // ======================= Canvas sizing =======================
  function resize(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  // ======================= Utils =======================
  function ema(prev, cur, a){
    if (prev === null || prev === undefined) return cur;
    return prev + a*(cur - prev);
  }
  function fmtTime(ms){
    const s = Math.floor(ms/1000);
    const mm = String(Math.floor(s/60)).padStart(2,"0");
    const ss = String(s%60).padStart(2,"0");
    return `${mm}:${ss}`;
  }
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // חישוב שוליים פנימיים של אזור המשימה (לרינדור נקודות/כיול) – במקום Zones
  function getTaskMargins(){
    const rect = canvas.getBoundingClientRect();
    const marginX = Math.max(rect.width  * FRAME_MARGIN_X_RATIO, 40);
    const marginY = Math.max(rect.height * FRAME_MARGIN_Y_RATIO, 40);
    return { rect, marginX, marginY };
  }


  // ======================= Head tracking state =======================
  const head = {
    ready:false,
    face:false,
    yaw:null,
    pitch:null,
    yawSm:null,
    pitchSm:null,
    calibrated:false,
    neutralYaw:0,
    neutralPitch:0,
    awayEvents:0,
    left:0, right:0, up:0, down:0, unknown:0,
    _inAway:false,
    _lastDir:"CENTER"
  };

  let faceMesh = null;

  function computeYawPitch(landmarks){
    // תמציתי ויציב יחסית:
    // נשתמש בנקודות עיניים/אף כדי לאמוד yaw/pitch.
    // indices נפוצים ב-FaceMesh:
    // left eye outer: 33, right eye outer: 263, nose tip: 1
    const L = landmarks[33];
    const R = landmarks[263];
    const N = landmarks[1];

    const midX = (L.x + R.x)/2;
    const midY = (L.y + R.y)/2;

    // yaw: אם האף "נוסע" ימינה ביחס לאמצע העיניים
    const yaw = (N.x - midX);

    // pitch: אם האף "נוסע" למטה/למעלה ביחס לאמצע העיניים
    const pitch = (N.y - midY);

    return { yaw, pitch };
  }

  function classifyHeadDir(yawRel, pitRel){
    // NOTE: תיקון היפוך ימין/שמאל:
    if (Math.abs(yawRel) >= Math.abs(pitRel)){
      if (yawRel > 0) return "L";
      return "R";
    } else {
      if (pitRel > 0) return "D";
      return "U";
    }
  }

  function headDirFromRel(yawRel, pitRel){
    // סף: אם מתחת לסף → CENTER
    if (Math.abs(yawRel) < HEAD_YAW_THRESH && Math.abs(pitRel) < HEAD_PITCH_THRESH) return "CENTER";
    return classifyHeadDir(yawRel, pitRel);
  }

  function updateHeadAway(t, dir){
    // counts an away-event only once per away episode
    let away = 0;
    if (dir !== "CENTER" && !head._inAway){
      head._inAway = true;
      head.awayEvents++;
      away = 1;
      if (dir==="L") head.left++;
      else if (dir==="R") head.right++;
      else if (dir==="U") head.up++;
      else if (dir==="D") head.down++;
      else head.unknown++;
    }
    if (dir === "CENTER") head._inAway = false;
    head._lastDir = dir;
    return { away };
  }

  function resetHeadState(){
    head.ready = false;
    head.face = false;
    head.yaw = null;
    head.pitch = null;
    head.yawSm = null;
    head.pitchSm = null;
    head.calibrated = false;
    head.neutralYaw = 0;
    head.neutralPitch = 0;
    head.awayEvents = 0;
    head.left = head.right = head.up = head.down = head.unknown = 0;
    head._inAway = false;
    head._lastDir = "CENTER";
  }

  async function initFaceMesh(){
    if (head.ready) return;

    try{
      // נשתמש בוידאו של WebGazer כדי לא לפתוח מצלמה פעמיים (זה הגורם העיקרי לתקלות/קפיצות)
      const wgVideo = (window.webgazer && webgazer.getVideoElement) ? webgazer.getVideoElement() : null;
      if (!wgVideo) throw new Error("WebGazer video not available");

      faceMesh = new FaceMesh.FaceMesh({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
      });

      faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });

      faceMesh.onResults((results) => {
        const faces = results.multiFaceLandmarks || [];
        head.face = !!faces.length;
        if (!head.face) return;

        const {yaw, pitch} = computeYawPitch(faces[0]);
        head.yaw = yaw;
        head.pitch = pitch;

        head.yawSm = ema(head.yawSm, yaw, HEAD_SMOOTH_ALPHA);
        head.pitchSm = ema(head.pitchSm, pitch, HEAD_SMOOTH_ALPHA);
      });

      // לולאת עיבוד (על גבי הוידאו של WebGazer)
      const tick = async () => {
        if (!running) return;
        try{
          await faceMesh.send({ image: wgVideo });
        } catch(_e){}
        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);

      head.ready = true;
      miniStatus.textContent = "סטטוס: Head tracking פעיל (על בסיס WebGazer)";
    } catch(e){
      head.ready = false;
      miniStatus.textContent = "סטטוס: Head tracking לא הופעל (ממשיך ללא Head)";
    }
  }

  // ======================= Head calibration (neutral) =======================
  let holdActive = false;
  let holdStart = null;

  function startHeadNeutralCalibration(){
    // user holds head at center for 1.2s
    holdActive = true;
    holdStart = null;
    head.calibrated = false;
    log("כיול ראש: החזק/י ראש במרכז (מול המסך) ~1.2 שניות...");
  }

  function updateHeadNeutralCalibration(){
    if (!holdActive) return false;

    // require face present
    if (!head.ready || !head.face || head.yawSm==null || head.pitchSm==null){
      holdStart = null;
      return false;
    }

    const { marginX, marginY } = getTaskMargins();
    // we don’t really use margins now; just reuse calibration loop timing
    const now = performance.now();
    if (holdStart == null) holdStart = now;

    if ((now - holdStart) >= 1200){
      head.neutralYaw = head.yawSm;
      head.neutralPitch = head.pitchSm;
      head.calibrated = true;
      holdActive = false;
      log("כיול ראש הסתיים ✅");
      return true;
    }
    return false;
  }

  function getHeadRel(){
    const yawRel = head.yawSm - head.neutralYaw;
    const pitRel = head.pitchSm - head.neutralPitch;
    return { yawRel, pitRel };
  }

  // ======================= Gaze direction fallback (אם אין Head) =======================
  function classifyGazeDir(hadRaw, x, y){
    if (!hadRaw || x == null || y == null) return "UNKNOWN";

    // אם המבט באמת מחוץ למסך/חלון
    const w = window.innerWidth, h = window.innerHeight;
    if (x < 0) return "L";
    if (x > w) return "R";
    if (y < 0) return "U";
    if (y > h) return "D";

    // אחרת – כיוון יחסי למרכז עם deadzone
    const cx = w/2, cy = h/2;
    const dx = x - cx, dy = y - cy;
    const deadX = w * 0.08;
    const deadY = h * 0.08;
    if (Math.abs(dx) < deadX && Math.abs(dy) < deadY) return "CENTER";

    if (Math.abs(dx) >= Math.abs(dy)) return dx >= 0 ? "R" : "L";
    return dy >= 0 ? "D" : "U";
  }

  // ======================= Stats / timeline =============
  const gazeStats = {
    hasStarted:false,
    lastTime:null,
    totalOnMs:0,
    totalOffMs:0,
    totalSamples:0,
    validSamples:0,
    invalidSamples:0,
    offEvents:0,
    offUnknownEvents:0,
    offLeftEvents:0,
    offRightEvents:0,
    offUpEvents:0,
    offDownEvents:0,
    timeTaskMs:0,
    timeDeviationMs:0
  };

  // off state (Head-based)
  const offState = {
    candidate: false,
    candidateStart: null,
    inOff: false,
    dir: "",
  };

  const gazeTimeline = [];

  function resetGazeStats(){
    Object.assign(gazeStats,{
      hasStarted:false,lastTime:null,
      totalOnMs:0,totalOffMs:0,totalSamples:0,validSamples:0,invalidSamples:0,
      offEvents:0,offUnknownEvents:0,offLeftEvents:0,offRightEvents:0,offUpEvents:0,offDownEvents:0,
      timeTaskMs:0,timeDeviationMs:0
    });
    offState.candidate=false; offState.candidateStart=null;
    offState.inOff=false; offState.dir="";
    gazeTimeline.length=0;
    resetSmoothing();
  }

  function resetSmoothing(){
    smoothX = null;
    smoothY = null;
  }

  // ======================= Connect-the-dots task =======================
  // (פשוט: סט נקודות קבוע + מעקב)
  const tasks = [];
  let currentTask = null;
  let taskIndex = 0;

  function buildTasks(){
    tasks.length = 0;
    const patterns = [
      { n: 12, seed: 1 },
      { n: 14, seed: 2 },
      { n: 16, seed: 3 }
    ];
    patterns.forEach((p,i)=>{
      tasks.push({ index:i+1, points: generatePoints(p.n, p.seed), done:false, started:false, startMs:null, endMs:null });
    });
  }

  function seededRand(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let x = Math.imul(t ^ (t >>> 15), 1 | t);
      x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }

  function generatePoints(n, seed){
    const r = seededRand(seed);
    const { rect, marginX, marginY } = getTaskMargins();
    const x0 = marginX + rect.width * POINT_INNER_PADDING;
    const y0 = marginY + rect.height * POINT_INNER_PADDING;
    const x1 = rect.width - marginX - rect.width * POINT_INNER_PADDING;
    const y1 = rect.height - marginY - rect.height * POINT_INNER_PADDING;

    const pts = [];
    for (let i=0;i<n;i++){
      pts.push({ x: x0 + r()*(x1-x0), y: y0 + r()*(y1-y0) });
    }
    return pts;
  }

  // task state
  let connectIdx = 0;
  let isDrawing = false;

  function startNextTask(){
    const t = tasks.find(x=>!x.done);
    if (!t){
      endSession("completed");
      return;
    }
    currentTask = t;
    connectIdx = 0;
    isDrawing = false;
    currentTask.started = true;
    currentTask.startMs = performance.now();
    log(`משימה ${currentTask.index} התחילה`);
  }

  function finishTask(){
    if (!currentTask) return;
    currentTask.done = true;
    currentTask.endMs = performance.now();
    log(`משימה ${currentTask.index} הסתיימה ✅`);
    startNextTask();
  }

  // ======================= WebGazer =======================
  let wgReady = false;
  let smoothX = null;
  let smoothY = null;

  function startWebgazer(){
    return new Promise(async (resolve,reject)=>{
      try{
        webgazer.setGazeListener((data, elapsedTime) => {
          onGaze(data, elapsedTime);
        })
        .showVideoPreview(false)
        .showPredictionPoints(false)
        .applyKalmanFilter(false);

        await webgazer.begin();
        wgReady = true;
        resolve();
      } catch(e){
        reject(e);
      }
    });
  }

  async function stopWebgazer(){
    try{
      if (window.webgazer) await webgazer.end();
    } catch(_e){}
    wgReady = false;
  }

  function smoothPoint(x,y){
    smoothX = ema(smoothX, x, SMOOTH_ALPHA);
    smoothY = ema(smoothY, y, SMOOTH_ALPHA);
    return { x:smoothX, y:smoothY };
  }

  // ======================= Calibration UI =======================
  let calibActive = false;
  let calibPoints = [];
  let calibIdx = 0;
  let calibHoldStart = null;

  function startCalibrationSequence(){
    // 1) WebGazer points
    calibActive = true;
    calibIdx = 0;
    calibHoldStart = null;
    calibPoints = generateCalibrationPoints(CALIB_POINTS);

    log("כיול WebGazer התחיל: עקוב אחרי הנקודה...");
  }

  function generateCalibrationPoints(count){
    const pts = [];
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    const grid = [
      [0.2,0.2],[0.5,0.2],[0.8,0.2],
      [0.2,0.5],[0.5,0.5],[0.8,0.5],
      [0.2,0.8],[0.5,0.8],[0.8,0.8]
    ];
    for (let i=0;i<Math.min(count,grid.length);i++){
      pts.push({ x:grid[i][0]*w, y:grid[i][1]*h });
    }
    return pts;
  }

  function updateCalibration(elapsed){
    if (!calibActive) return false;

    // hold per point
    const now = performance.now();
    if (calibHoldStart == null) calibHoldStart = now;

    // collect samples on each point
    if ((now - calibHoldStart) >= CALIB_HOLD_MS){
      // record sample to webgazer
      const p = calibPoints[calibIdx];
      const rect = canvas.getBoundingClientRect();
      const screenX = rect.left + p.x;
      const screenY = rect.top + p.y;
      try{
        webgazer.recordScreenPosition(screenX, screenY, "click");
      } catch(_e){}

      calibIdx++;
      calibHoldStart = null;

      if (calibIdx >= calibPoints.length){
        calibActive = false;
        log("כיול WebGazer הסתיים ✅");
        // 2) Head calibration
        startHeadNeutralCalibration();
        return true;
      }
    }
    return false;
  }

  // ======================= Session state =======================
  let running = false;
  let sessionStart = null;
  let rafId = null;

  btnStart.addEventListener("click", async ()=>{
    if (running) return;
    const pid = (pidInput.value || "").trim();
    if (!pid){
      alert("נא להזין מזהה נבדק (PID).");
      return;
    }

    resetGazeStats();
    resetHeadState();
    buildTasks();

    miniStatus.textContent = "סטטוס: מבקש מצלמה...";
    log("מתחיל...");

    try{
      await startWebgazer();
      miniStatus.textContent = "סטטוס: WebGazer פעיל, מכין Head...";
      running = true;
      sessionStart = performance.now();

      // Head tracking uses same camera permission; start it too.
      initFaceMesh();

      setTimeout(startCalibrationSequence, 900);

      startNextTask();

      loop();
    } catch(e){
      running = false;
      miniStatus.textContent = "סטטוס: שגיאה בהפעלת מצלמה";
      log("שגיאה: לא הצלחתי להפעיל WebGazer. ודא הרשאת מצלמה/HTTPS.");
    }
  });

  btnStop.addEventListener("click", ()=>{
    if (!running) return;
    endSession("stopped");
  });

  btnDownload.addEventListener("click", ()=>{
    const pid = (pidInput.value || "").trim();
    if (!pid){ alert("PID חסר"); return; }
    const blob = new Blob([buildAllCsvZipText()], {type:"text/plain;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `${pid}_export.txt`;
    a.click();
  });

  btnUpload.addEventListener("click", async ()=>{
    const pid = (pidInput.value || "").trim();
    if (!pid){ alert("PID חסר"); return; }
    await uploadAll();
  });

  async function endSession(reason){
    running = false;
    if (rafId) cancelAnimationFrame(rafId);
    await stopWebgazer();

    miniStatus.textContent = `סטטוס: הסתיים (${reason})`;
    log(`סיום סשן: ${reason}`);

    // auto upload if SCRIPT_URL present
    if (SCRIPT_URL){
      try{
        await uploadAll();
      } catch(_e){
        log("שליחה ל-Drive נכשלה (בדוק SCRIPT_URL / הרשאות).");
      }
    }
  }

  // ======================= Gaze processing =======================
  function onGaze(data, elapsedTime){
    if (!running) return;

    const hadRaw = !!(data && typeof data.x==="number" && typeof data.y==="number");

    // smooth
    let fixed = {x:null,y:null};
    if (hadRaw){
      fixed = smoothPoint(data.x, data.y);
    }

    const t = elapsedTime;

    // ---- head current state for this sample ----
    let facePresent = head.face ? 1 : 0;
    let headDir = "CENTER";
    let headYawRel = "";
    let headPitchRel = "";
    let headAwayEvent = 0;

    if (head.ready && head.calibrated && head.face){
      const rel = getHeadRel();
      headYawRel = rel.yawRel.toFixed(4);
      headPitchRel = rel.pitRel.toFixed(4);
      headDir = headDirFromRel(rel.yawRel, rel.pitRel);
      const awayRes = updateHeadAway(t, headDir);
      headAwayEvent = awayRes.away;
    } else {
      // אם Head לא זמין/לא מכויל – נשתמש בכיוון לפי Gaze כגיבוי
      headDir = classifyGazeDir(hadRaw, fixed.x, fixed.y);
    }
const onFlag = (headDir === "CENTER") ? 1 : 0;

    // ---- update calibration steps ----
    if (calibActive){
      updateCalibration(t);
      return;
    }

    if (holdActive){
      const ok = updateHeadNeutralCalibration();
      if (ok){
        log("התחל משימה ✅");
      }
      return;
    }

    if (!currentTask) return;

    // ---- stats accumulators ----
    if (!gazeStats.hasStarted){
      gazeStats.hasStarted = true;
      gazeStats.lastTime = t;

      // sample counters
      gazeStats.totalSamples = 1;
      if (hadRaw) gazeStats.validSamples = 1;
      else gazeStats.invalidSamples = 1;
    } else {
      const dt = t - (gazeStats.lastTime || t);
      gazeStats.lastTime = t;

      if (onFlag === 1){
        gazeStats.totalOnMs += dt;
        gazeStats.timeTaskMs += dt;
      } else {
        gazeStats.totalOffMs += dt;
        gazeStats.timeDeviationMs += dt;
      }

      gazeStats.totalSamples++;
      if (hadRaw) gazeStats.validSamples++;
      else gazeStats.invalidSamples++;
    }

    // ---- OFF detection (ראש קודם, וגיבוי לפי Gaze אם אין Head) ----
    if (onFlag === 1){
      if (offState.candidate || offState.inOff){
        offState.candidate = false;
        offState.candidateStart = null;
        offState.inOff = false;
        offState.dir = "";
      }
    } else {
      if (!offState.candidate){
        offState.candidate = true;
        offState.candidateStart = t;
        offState.inOff = false;
        offState.dir = headDir || "";
      } else {
        // עדכן כיוון "האחרון הידוע" בזמן מועמדות
        if (headDir && headDir !== "CENTER") offState.dir = headDir;
      }

      if (offState.candidate && !offState.inOff &&
          offState.candidateStart != null &&
          (t - offState.candidateStart) >= OFF_MIN_MS){
        offState.inOff = true;

        gazeStats.offEvents++;
        if (!offState.dir || offState.dir === "CENTER") gazeStats.offUnknownEvents++;
        else if (offState.dir==="L") gazeStats.offLeftEvents++;
        else if (offState.dir==="R") gazeStats.offRightEvents++;
        else if (offState.dir==="U") gazeStats.offUpEvents++;
        else if (offState.dir==="D") gazeStats.offDownEvents++;
      }
    }

    const ms = Math.round(t);
    const tIndex = currentTask ? currentTask.index : 0;

    let xOut="", yOut="";
    if (hadRaw && fixed.x != null && fixed.y != null){
      xOut = Math.round(fixed.x);
      yOut = Math.round(fixed.y);
    }

    let dirSample = "";
    if (onFlag===0 && offState.dir) dirSample = offState.dir;

    gazeTimeline.push({
      ms,
      task: tIndex,
      x: xOut,
      y: yOut,
      on: onFlag,
      dir: dirSample,
      face: facePresent,
      hdir: headDir,
      hyaw: headYawRel,
      hpit: headPitchRel,
      haway: headAwayEvent
    });
  }

  // ======================= Task interaction =======================
  canvas.addEventListener("pointerdown", (e)=>{
    if (!running || !currentTask) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const target = currentTask.points[connectIdx];
    const d = Math.hypot(x-target.x, y-target.y);
    if (d < 18){
      isDrawing = true;
    }
  });

  canvas.addEventListener("pointermove", (e)=>{
    if (!isDrawing || !currentTask) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const target = currentTask.points[connectIdx];
    const d = Math.hypot(x-target.x, y-target.y);
    if (d < 18){
      connectIdx++;
      if (connectIdx >= currentTask.points.length){
        isDrawing = false;
        finishTask();
      }
    }
  });

  canvas.addEventListener("pointerup", ()=>{ isDrawing=false; });

  // ======================= Rendering =======================
  function draw(){
    resize();
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    ctx.clearRect(0,0,w,h);

    // background grid light
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#0f172a";
    ctx.lineWidth = 1;
    for (let x=0;x<w;x+=40){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
    for (let y=0;y<h;y+=40){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // calibration dot
    if (calibActive){
      const p = calibPoints[calibIdx] || calibPoints[calibPoints.length-1];
      ctx.fillStyle = "rgba(239,68,68,0.95)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "14px system-ui";
      ctx.fillText(`כיול: נקודה ${calibIdx+1}/${calibPoints.length}`, 14, 24);
      return;
    }

    // head neutral hold indicator
    if (holdActive){
      ctx.fillStyle = "rgba(245,158,11,0.95)";
      ctx.beginPath();
      ctx.arc(w/2, h/2, 10, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "14px system-ui";
      ctx.fillText("כיול ראש: החזק/י מרכז", 14, 24);
      return;
    }

    // draw task points
    if (currentTask){
      ctx.strokeStyle = "rgba(148,163,184,0.6)";
      ctx.lineWidth = 2;

      // lines between completed points
      if (connectIdx > 0){
        ctx.beginPath();
        ctx.moveTo(currentTask.points[0].x, currentTask.points[0].y);
        for (let i=1;i<connectIdx;i++){
          ctx.lineTo(currentTask.points[i].x, currentTask.points[i].y);
        }
        ctx.stroke();
      }

      // points
      currentTask.points.forEach((p,i)=>{
        const done = i < connectIdx;
        ctx.fillStyle = done ? "rgba(34,197,94,0.95)" : "rgba(229,231,235,0.9)";
        ctx.beginPath();
        ctx.arc(p.x, p.y, 8, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "#020617";
        ctx.font = "11px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(String(i+1), p.x, p.y+0.5);
      });

      // task label
      ctx.textAlign="left"; ctx.textBaseline="alphabetic";
      ctx.fillStyle = "#e5e7eb";
      ctx.font = "14px system-ui";
      ctx.fillText(`משימה ${currentTask.index} | נקודה: ${Math.min(connectIdx+1, currentTask.points.length)}/${currentTask.points.length}`, 14, 24);
    }

    // draw gaze point (debug) from last sample
    const last = gazeTimeline[gazeTimeline.length-1];
    if (last && last.x !== "" && last.y !== ""){
      const rect = canvas.getBoundingClientRect();
      const gx = (last.x - rect.left);
      const gy = (last.y - rect.top);
      ctx.fillStyle = "rgba(239,68,68,0.95)";
      ctx.beginPath();
      ctx.arc(gx, gy, 6, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function loop(){
    if (!running) return;
    const elapsed = performance.now() - sessionStart;
    timeLabel.textContent = fmtTime(elapsed);

    // KPI
    kpiOn.textContent = Math.round(gazeStats.totalOnMs).toString();
    kpiOff.textContent = Math.round(gazeStats.totalOffMs).toString();
    kpiOffEvents.textContent = gazeStats.offEvents.toString();
    kpiHeadDir.textContent = head._lastDir || "CENTER";

    if (elapsed >= MAX_SESSION_MS){
      endSession("timeout");
      return;
    }

    draw();
    rafId = requestAnimationFrame(loop);
  }

  // ======================= CSV builders =======================
  function buildEyeCsv(){
    const pid = (pidInput.value || "").trim();
    if (!gazeStats.hasStarted && gazeStats.totalSamples === 0) return "";
    const headRow = [
      "pid","total_on_ms","total_off_ms","total_samples","valid_samples","invalid_samples",
      "off_events","off_unknown_events","off_left_events","off_right_events","off_up_events","off_down_events",
      "time_task_ms","time_deviation_ms",
      "head_away_events","head_left_events","head_right_events","head_up_events","head_down_events","head_unknown_events"
    ];
    const row = [
      pid,
      Math.round(gazeStats.totalOnMs),
      Math.round(gazeStats.totalOffMs),
      gazeStats.totalSamples,
      gazeStats.validSamples,
      gazeStats.invalidSamples,
      gazeStats.offEvents,
      gazeStats.offUnknownEvents,
      gazeStats.offLeftEvents,
      gazeStats.offRightEvents,
      gazeStats.offUpEvents,
      gazeStats.offDownEvents,
      Math.round(gazeStats.timeTaskMs),
      Math.round(gazeStats.timeDeviationMs),
      head.awayEvents, head.left, head.right, head.up, head.down, head.unknown
    ].join(",");
    return headRow.join(",") + "\n" + row + "\n";
  }

  function buildEyeTimelineCsv(){
    const pid = (pidInput.value || "").trim();
    if (!gazeTimeline.length) return "";
    const headCols = [
      "pid","task_index","ms",
      "x_fixed","y_fixed","on_screen","off_direction",
      "face_present","head_dir","head_yaw_rel","head_pitch_rel","head_away_event"
    ];
    const rows = gazeTimeline.map(s =>
      [
        pid, s.task, s.ms,
        s.x, s.y, s.on, s.dir,
        s.face, s.hdir, s.hyaw, s.hpit, s.haway
      ].join(",")
    );
    return headCols.join(",") + "\n" + rows.join("\n");
  }

  function buildTasksCsv(){
    const pid = (pidInput.value || "").trim();
    const cols = ["pid","task_index","started","done","task_ms"];
    const rows = tasks.map(t=>{
      const ms = (t.started && t.done) ? Math.round(t.endMs - t.startMs) : "";
      return [pid, t.index, t.started?1:0, t.done?1:0, ms].join(",");
    });
    return cols.join(",") + "\n" + rows.join("\n");
  }

  function buildAllCsvZipText(){
    // פשוט קובץ טקסט אחד שמכיל 3 "קבצים" (לבדיקה מקומית)
    const pid = (pidInput.value || "").trim();
    return [
      `===== ${pid}_eye_summary.csv =====`,
      buildEyeCsv(),
      `===== ${pid}_eye_timeline.csv =====`,
      buildEyeTimelineCsv(),
      `===== ${pid}_tasks.csv =====`,
      buildTasksCsv()
    ].join("\n");
  }

  // ======================= Upload to Drive =======================
  async function sendCsvToDrive(filename, content){
    if (!SCRIPT_URL) throw new Error("SCRIPT_URL missing");
    const body = new URLSearchParams();
    body.set("filename", filename);
    body.set("content", content);

    const res = await fetch(SCRIPT_URL, {
      method:"POST",
      mode:"no-cors",
      headers: { "Content-Type":"application/x-www-form-urlencoded;charset=UTF-8" },
      body
    });
    return res;
  }

  async function uploadAll(){
    const pid = (pidInput.value || "").trim();
    if (!pid) throw new Error("PID missing");

    const s1 = buildEyeCsv();
    const s2 = buildEyeTimelineCsv();
    const s3 = buildTasksCsv();

    if (!s1 || !s2){
      log("אין מספיק נתונים לשליחה עדיין.");
      return;
    }

    log("שולח ל-Drive...");
    await sendCsvToDrive(`${pid}_eye_summary.csv`, s1);
    await sendCsvToDrive(`${pid}_eye_timeline.csv`, s2);
    await sendCsvToDrive(`${pid}_tasks.csv`, s3);
    log("נשלח ✅ (אם Apps Script מוגדר תקין)");
  }

</script>
</body>
</html>
