<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>משימת חיבור נקודות – ניסוי קשב + מעקב עיניים</title>
  <style>
    :root{
      --bg:#020617;
      --panel:#0b1120;
      --ink:#e5e7eb;
      --muted:#94a3b8;
      --accent:#e5e7eb;
      --stroke:#64748b;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      display:grid;
      grid-template-rows:auto 1fr auto;
    }
    header,footer{
      background:var(--panel);
      padding:10px 16px;
      border-bottom:1px solid #111827;
    }
    footer{
      border-top:1px solid #111827;
      border-bottom:none;
      font-size:0.8rem;
      color:var(--muted);
      text-align:center;
    }
    .top{
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:center;
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      justify-content:center;
      align-items:center;
    }
    label{font-size:0.9rem;color:var(--muted);}
    input{
      background:#020617;
      border:1px solid #334155;
      color:var(--ink);
      padding:4px 8px;
      border-radius:8px;
      min-width:120px;
    }
    input[readonly]{opacity:0.8;}
    button{
      border-radius:999px;
      border:1px solid #334155;
      background:#111827;
      color:var(--ink);
      padding:6px 14px;
      cursor:pointer;
      font-size:0.9rem;
    }
    button:disabled{
      opacity:0.4;
      cursor:not-allowed;
    }
    button:hover:not(:disabled){
      border-color:#60a5fa;
    }
    #stageWrap{
      padding:10px 16px 16px;
      position:relative;
    }
    #stage{
      width:100%;
      height:70vh;
      display:block;
      background:#020617;
      border-radius:18px;
      border:1px solid #1f2937;
      touch-action:none;
    }
    #overlay{
      position:absolute;
      inset:10px 16px 16px;
      display:none;
      place-items:center;
      background:rgba(15,23,42,0.82);
      border-radius:18px;
      z-index:10;
    }
    #overlay .box{
      background:#020617;
      border-radius:16px;
      border:1px solid #1f2937;
      padding:20px 24px;
      max-width:420px;
      text-align:center;
    }
    #overlay h2{
      margin-top:0;
      margin-bottom:8px;
    }
    .muted{color:var(--muted);}
  </style>

  <!-- ספריית WebGazer (מעקב עיניים) -->
  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
</head>
<body>
  <header>
    <div class="top">
      <div class="muted">
        המשימה תימשך עד <b>10 דקות</b> או עד לחיצה על "סיום מוקדם".
      </div>
      <div class="controls">
        <label for="pid">מזהה נבדק:</label>
        <input id="pid" type="text" placeholder="לדוגמה OR010125" />
        <button id="startBtn" disabled>התחל משימה</button>
        <button id="endBtn" disabled>סיום מוקדם</button>
      </div>
    </div>
  </header>

  <div id="stageWrap">
    <canvas id="stage"></canvas>
    <div id="overlay">
      <div class="box">
        <h2 id="overlayTitle">סיום הסשן</h2>
        <p id="overlayText" class="muted"></p>
        <button id="overlayContinue">המשך</button>
      </div>
    </div>
  </div>

  <footer>
    יש ללחוץ על המספרים לפי סדר עולה. ניתן להסיר בחירה על ידי לחיצה חוזרת על אותו מספר.
  </footer>

<script>
(() => {
  // ======================= הגדרות כלליות =======================
  const CONFIG = {
    sessionMinutes: 10,   // משך סשן בדקות
    initialPoints: 12,    // כמות נקודות התחלתית
    incrementBy: 2,       // העלאת קושי בכל משימה (2 נקודות)
    minDistance: 30,
    lineAvoidDistance: 16,
    margin: 30
  };

  // ======================= שליחה ל-Google Drive =======================
  const SCRIPT_URL =
    "https://script.google.com/macros/s/AKfycbzVinB7VZA9P3mkKYpfYuykv6JXF62w70s7I98iOqU2YhRyigD0lcBndONHsx5rdhRnRA/exec";

  function sendCsvToDrive(csvContent, label) {
    if (!csvContent) return;

    // PID מתוך השדה (או מתוך ה-URL אם השדה נעול)
    const rawPid = (pidInput.value || "").trim();
    // ניקוי תווים בעייתיים בשם קובץ
    const safePid = rawPid
      ? rawPid.replace(/[^a-zA-Z0-9_-]/g, "")
      : "PID";

    // חותמת זמן קומפקטית לשם הקובץ
    const ts = new Date().toISOString().replace(/[:.]/g, "");

    // שם הקובץ הסופי – כולל PID
    const filename = `${safePid}_${label}_${ts}.csv`;

    const payload = {
      filename: filename,
      mimeType: "text/csv",
      content: csvContent
    };

    fetch(SCRIPT_URL, {
      method: "POST",
      mode: "no-cors",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    }).catch(err => {
      console.error("Failed to send CSV to Drive:", err);
    });
  }

  // ---- טופס 2: טופס הסיכום ----
  const FORM_ID = "1FAIpQLSdTCgLVjt4LXsNAkXP1H8jxIC5MPsdv1sD93v5lmglckCAzrA";

  const ENTRY_PID             = "entry.404955311";
  const ENTRY_TOTAL_TASKS     = "entry.1331557537";  // TTC
  const ENTRY_POINTS_PER_TASK = "entry.742152065";   // PPT
  const ENTRY_ERRORS_PER_TASK = "entry.1634677467";  // EPT
  const ENTRY_DUR_PER_TASK    = "entry.529234118";   // DPT
  const ENTRY_EXPERIMENT_TIME = "entry.883845532";   // TIME

  const FORM_BASE_URL =
    "https://docs.google.com/forms/d/e/" + FORM_ID + "/viewform?usp=pp_url&";

  // ---- טופס 3: לוג המשימות ----
  const LOG_FORM_ID = "1FAIpQLSdrl006D8HAWo0YfsdWUMppGEewGOp8Snm3ANot8OxzSBkusA";
  const LOG_FORM_BASE =
    "https://docs.google.com/forms/d/e/" + LOG_FORM_ID + "/formResponse?";

  const LOG_ENTRY_PID        = "entry.152946855";
  const LOG_ENTRY_TASK       = "entry.781109584";
  const LOG_ENTRY_N_POINTS   = "entry.347168050";
  const LOG_ENTRY_ERRORS     = "entry.1932703164";
  const LOG_ENTRY_DURATION   = "entry.1227866932";
  const LOG_ENTRY_COMPLETED  = "entry.1100470565";
  const LOG_ENTRY_TIMESTAMP  = "entry.1243807469";

  // ======================= DOM =======================
  const canvas = document.getElementById("stage");
  const ctx = canvas.getContext("2d");
  const pidInput = document.getElementById("pid");
  const startBtn = document.getElementById("startBtn");
  const endBtn = document.getElementById("endBtn");
  const overlay = document.getElementById("overlay");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlayText = document.getElementById("overlayText");
  const overlayContinue = document.getElementById("overlayContinue");

  // ======================= STATE (משימה) =======================
  let running = false;
  let sessionStart = null;
  let experimentStartIso = null;
  let tickId = null;

  let tasks = [];
  let taskCounter = 0;
  let currentTask = null;
  let pendingNextTaskPoints = null;
  let sessionEnded = false;

  // ======================= WebGazer / כיול =======================
  let isCalibrated = false;
  const CALIB_POINTS_TOTAL = 15;
  let calibrationActive = false;
  let calibrationPoints = [];
  let calibrationIndex = 0;

  // סטטיסטיקות מעקב עיניים בזמן המשימה
  const gazeStats = {
    hasStarted: false,
    lastTime: null,
    lastHadData: false,
    lastX: null,
    lastY: null,
    totalOnMs: 0,
    totalOffMs: 0,
    totalSamples: 0,
    validSamples: 0,
    invalidSamples: 0,
    offEvents: 0,
    offLeftEvents: 0,
    offRightEvents: 0,
    offUpEvents: 0,
    offDownEvents: 0
  };

  const gazeTimeline = [];

  function resetGazeStats(){
    gazeStats.hasStarted = false;
    gazeStats.lastTime = null;
    gazeStats.lastHadData = false;
    gazeStats.lastX = null;
    gazeStats.lastY = null;
    gazeStats.totalOnMs = 0;
    gazeStats.totalOffMs = 0;
    gazeStats.totalSamples = 0;
    gazeStats.validSamples = 0;
    gazeStats.invalidSamples = 0;
    gazeStats.offEvents = 0;
    gazeStats.offLeftEvents = 0;
    gazeStats.offRightEvents = 0;
    gazeStats.offUpEvents = 0;
    gazeStats.offDownEvents = 0;
    gazeTimeline.length = 0;
  }

  // מאזין של WebGazer – נאסף רק בזמן המשימה
  function handleGaze(data, elapsedTime){
    if (!running || sessionEnded){
      // לא אוספים נתונים מחוץ למשימה
      gazeStats.lastTime = null;
      gazeStats.lastHadData = !!data;
      if (data){
        gazeStats.lastX = data.x;
        gazeStats.lastY = data.y;
      }
      return;
    }

    const t = elapsedTime; // מילי־שניות מאז begin()

    if (!gazeStats.hasStarted){
      gazeStats.hasStarted = true;
      gazeStats.lastTime = t;
      gazeStats.lastHadData = !!data;
      if (data){
        gazeStats.lastX = data.x;
        gazeStats.lastY = data.y;
      }
      return;
    }

    const dt = t - (gazeStats.lastTime || t);
    gazeStats.lastTime = t;

    if (gazeStats.lastHadData){
      gazeStats.totalOnMs += dt;
    } else {
      gazeStats.totalOffMs += dt;
    }

    const hadData = !!data;
    gazeStats.totalSamples++;
    if (hadData) gazeStats.validSamples++;
    else gazeStats.invalidSamples++;

    // זיהוי "יציאה" חדשה מהמחשב + כיוון (L/R/U/D)
    if (!hadData && gazeStats.lastHadData){
      gazeStats.offEvents++;
      if (gazeStats.lastX != null && gazeStats.lastY != null){
        const w = window.innerWidth  || document.documentElement.clientWidth  || 1;
        const h = window.innerHeight || document.documentElement.clientHeight || 1;
        const cx = w / 2;
        const cy = h / 2;
        const dx = gazeStats.lastX - cx;
        const dy = gazeStats.lastY - cy;

        if (Math.abs(dx) >= Math.abs(dy)){
          if (dx < 0) gazeStats.offLeftEvents++;
          else        gazeStats.offRightEvents++;
        } else {
          if (dy < 0) gazeStats.offUpEvents++;
          else        gazeStats.offDownEvents++;
        }
      }
    }

    gazeStats.lastHadData = hadData;
    if (hadData){
      gazeStats.lastX = data.x;
      gazeStats.lastY = data.y;
    }

    // לוג מפורט של כל דגימת מבט
    const ms = Math.round(t);
    const taskIndex = currentTask ? currentTask.index : 0;
    let x = "";
    let y = "";
    let dir = "";

    if (hadData){
      x = Math.round(data.x);
      y = Math.round(data.y);
    } else if (gazeStats.lastX != null && gazeStats.lastY != null){
      const w = window.innerWidth  || document.documentElement.clientWidth  || 1;
      const h = window.innerHeight || document.documentElement.clientHeight || 1;
      const cx = w / 2;
      const cy = h / 2;
      const dx = gazeStats.lastX - cx;
      const dy = gazeStats.lastY - cy;

      if (Math.abs(dx) >= Math.abs(dy)){
        dir = (dx < 0) ? "L" : "R";
      } else {
        dir = (dy < 0) ? "U" : "D";
      }
    }

    gazeTimeline.push({
      ms,
      task: taskIndex,
      x,
      y,
      on: hadData ? 1 : 0,
      dir
    });
  }

  function buildEyeCsv(){
    const pid = (pidInput.value || "").trim();
    if (!gazeStats.hasStarted && gazeStats.totalSamples === 0){
      // לא נאספו נתונים
      return "";
    }
    const head = [
      "pid",
      "total_on_ms",
      "total_off_ms",
      "total_samples",
      "valid_samples",
      "invalid_samples",
      "off_events",
      "off_left_events",
      "off_right_events",
      "off_up_events",
      "off_down_events"
    ];
    const row = [
      pid,
      Math.round(gazeStats.totalOnMs),
      Math.round(gazeStats.totalOffMs),
      gazeStats.totalSamples,
      gazeStats.validSamples,
      gazeStats.invalidSamples,
      gazeStats.offEvents,
      gazeStats.offLeftEvents,
      gazeStats.offRightEvents,
      gazeStats.offUpEvents,
      gazeStats.offDownEvents
    ].join(",");
    return head.join(",") + "\n" + row + "\n";
  }

  function buildEyeTimelineCsv(){
    const pid = (pidInput.value || "").trim();
    if (!gazeTimeline.length){
      return "";
    }
    const head = [
      "pid",
      "task_index",
      "ms",
      "x",
      "y",
      "on_screen",
      "off_direction"
    ];
    const rows = gazeTimeline.map(sample =>
      [
        pid,
        sample.task,
        sample.ms,
        sample.x,
        sample.y,
        sample.on,
        sample.dir
      ].join(",")
    );
    return head.join(",") + "\n" + rows.join("\n");
  }

  // התחלת WebGazer + מעבר לרצף כיול הנקודות
  function startWebgazerAndCalibration(){
    if (!window.webgazer){
      alert("ספריית WebGazer לא נטענה. ניתן להמשיך עם המשימה בלי מעקב עיניים.");
      startBtn.disabled = false;
      return;
    }

    // לא לשמור נתונים בין סשנים
    window.saveDataAcrossSessions = false;

    try{
      webgazer
        .setGazeListener(handleGaze)
        .showVideo(false)
        .showFaceOverlay(false)
        .showPredictionPoints(false)
        .begin();
    } catch(e){
      console.error("WebGazer error:", e);
      alert("לא ניתן להפעיל את מעקב העיניים. ניתן להמשיך במשימה ללא המערכת.");
      startBtn.disabled = false;
      return;
    }

    // נותן למצלמה רגע לעלות לפני שמתחילים נקודות
    setTimeout(startCalibrationSequence, 1000);
  }

  // ======================= פונקציות עזר כלליות =======================
  function getPidFromUrl(){
    const params = new URLSearchParams(window.location.search);
    return params.get("pid") || "";
  }

  function now(){
    return performance.now();
  }

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  function randomBetween(min,max){
    return min + Math.random() * (max - min);
  }

  function distance(a,b){
    return Math.hypot(a.x - b.x, a.y - b.y);
  }

  function pointToSegmentDistance(p,a,b){
    const vx = b.x - a.x;
    const vy = b.y - a.y;
    const wx = p.x - a.x;
    const wy = p.y - a.y;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(p.x-a.x, p.y-a.y);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(p.x-b.x, p.y-b.y);
    const t = c1 / c2;
    const projX = a.x + t*vx;
    const projY = a.y + t*vy;
    return Math.hypot(p.x-projX, p.y-projY);
  }

  // ======================= יצירת משימה (Connect-the-dots) =======================
  function generatePoints(n){
    const rect = canvas.getBoundingClientRect();
    const m = CONFIG.margin;
    const W = Math.max(rect.width - 2*m, 220);
    const H = Math.max(rect.height - 2*m, 220);

    const pts = [];
    let attempts = 0;
    const maxAttempts = 4000;

    while (pts.length < n && attempts < maxAttempts){
      attempts++;
      const candidate = {
        x: randomBetween(m, m+W),
        y: randomBetween(m, m+H)
      };

      let ok = true;

      for (const p of pts){
        if (Math.hypot(p.x-candidate.x, p.y-candidate.y) < CONFIG.minDistance){
          ok = false;
          break;
        }
      }
      if (!ok) continue;

      for (let i = 1; i < pts.length; i++){
        const d = pointToSegmentDistance(candidate, pts[i-1], pts[i]);
        if (d < CONFIG.lineAvoidDistance){
          ok = false;
          break;
        }
      }
      if (!ok) continue;

      pts.push(candidate);
    }

    while (pts.length < n){
      pts.push({
        x: randomBetween(m, m+W),
        y: randomBetween(m, m+H)
      });
    }

    return pts;
  }

  function openNewTask(n){
    pendingNextTaskPoints = null;
    currentTask = {
      index: ++taskCounter,
      points: generatePoints(n),
      selected: new Set(),
      selectionOrder: [],
      errors: 0,
      startTime: now()
    };
    draw();
  }

  // ======================= כיול – נקודות אדומות =======================
  function generateCalibrationPoints(count){
    const rect = canvas.getBoundingClientRect();
    const m = CONFIG.margin;
    const W = Math.max(rect.width - 2*m, 220);
    const H = Math.max(rect.height - 2*m, 220);

    // נקודות מנורמלות (0–1) ביחס לאזור הכיול
    const pattern = [
      // פינות
      [0.05, 0.05],
      [0.95, 0.05],
      [0.95, 0.95],
      [0.05, 0.95],

      // אמצעי צלעות
      [0.50, 0.05],
      [0.95, 0.50],
      [0.50, 0.95],
      [0.05, 0.50],

      // מרכז
      [0.50, 0.50],

      // טבעת פנימית (ריבוע פנימי)
      [0.33, 0.33],
      [0.67, 0.33],
      [0.67, 0.67],
      [0.33, 0.67],

      // שתי נקודות אלכסון להשלמת 15
      [0.25, 0.75],
      [0.75, 0.25]
    ];

    const pts = [];
    for (let i = 0; i < count; i++) {
      const [nx, ny] = pattern[i % pattern.length];
      pts.push({
        x: m + nx * W,
        y: m + ny * H
      });
    }
    return pts;
  }

  function startCalibrationSequence(){
    calibrationPoints = generateCalibrationPoints(CALIB_POINTS_TOTAL);
    calibrationIndex = 0;
    calibrationActive = true;
    draw();
  }

  function handleCalibrationClick(ev){
    if (!calibrationActive || !calibrationPoints.length) return;

    const rect = canvas.getBoundingClientRect();
    const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
    const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    const current = calibrationPoints[calibrationIndex];
    if (!current) return;

    // לוודא שהמשתתף באמת לוחץ קרוב לנקודה
    const d = Math.hypot(current.x - x, current.y - y);
    if (d > 40) return;

    // רישום נקודת מסך ל-WebGazer (יחסית ל־viewport)
    try{
      if (window.webgazer && webgazer.recordScreenPosition){
        const vx = rect.left + current.x;
        const vy = rect.top + current.y;
        webgazer.recordScreenPosition(vx, vy, "click");
      }
    } catch(e){
      console.warn("recordScreenPosition failed:", e);
    }

    calibrationIndex++;
    if (calibrationIndex >= calibrationPoints.length){
      calibrationActive = false;
      isCalibrated = true;
      startBtn.disabled = false;

      // במקום להתחיל משימה מיד – מציגים מסך הוראות
      showTaskInstructions();
      draw();
    } else {
      draw();
    }
  }

  function showCalibrationIntro(){
    overlayTitle.textContent = "כיול מצלמה ומערכת מעקב עיניים";
    overlayText.textContent =
      "על מנת לכייל את המערכת, יש לאשר פתיחת מצלמה. לאחר מכן יופיעו 15 נקודות אדומות במקומות שונים על המסך – יש להביט בכל נקודה וללחוץ עליה.";
    overlayContinue.textContent = "פתח מצלמה וכייל";
    overlay.style.display = "grid";
    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      startWebgazerAndCalibration();
    };
  }

  // מסך הוראות המשימה לאחר כיול
  function showTaskInstructions(){
    overlayTitle.textContent = "הוראות המשימה";
    overlayText.innerHTML =
      "1. יש לבחור מספרים רק בסדר עולה (1, 2, 3 וכן הלאה).<br>" +
      "2. אם עשית טעות וברצונך לתקן – לחיצה נוספת על אותה ספרה תבטל את הבחירה.<br>" +
      "3. אם נעשתה טעות אך המשכת במשימה – הקווים יימחקו ותצטרך להתחיל שוב את הרצף שבו אתה נמצא.<br><br>" +
      "בהצלחה!";
    overlayContinue.textContent = "המשך להזנת קוד משתמש";
    overlay.style.display = "grid";
    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      // בשלב זה המשתתף ממלא PID ולוחץ על \"התחל משימה\"
      pidInput.focus();
    };
  }

  // ======================= ציור =======================
  function draw(){
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

    // מצב כיול – מציג רק נקודה אדומה אחת
    if (calibrationActive && calibrationPoints.length){
      const p = calibrationPoints[calibrationIndex] || calibrationPoints[calibrationPoints.length-1];
      ctx.fillStyle = "#ef4444"; // אדום
      ctx.beginPath();
      ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "14px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(
        `נקודה ${calibrationIndex+1} מתוך ${calibrationPoints.length} – לחץ על הנקודה האדומה`,
        p.x,
        p.y + 18
      );
      return;
    }

    if (!currentTask) return;

    const pts = currentTask.points;
    const order = currentTask.selectionOrder;

    // קווים לפי סדר הבחירה
    if (order.length > 1){
      ctx.strokeStyle = "#e5e7eb";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const first = pts[order[0]];
      ctx.moveTo(first.x, first.y);
      for (let i=1;i<order.length;i++){
        const p = pts[order[i]];
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }

    // נקודות ומספרים
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "14px system-ui, Arial";

    pts.forEach((p, idx) => {
      const isSelected = currentTask.selected.has(idx);
      const radius = 13;

      if (isSelected){
        ctx.fillStyle = "#e5e7eb";
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "#020617";
        ctx.fillText(String(idx+1), p.x, p.y);
      } else {
        ctx.fillStyle = "#020617";
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "#64748b";
        ctx.lineWidth = 1.5;
        ctx.stroke();

        ctx.fillStyle = "#e5e7eb";
        ctx.fillText(String(idx+1), p.x, p.y);
      }
    });
  }

  // ======================= אינטראקציה =======================
  function hitTest(x,y){
    if (!currentTask) return -1;
    const pts = currentTask.points;
    for(let i=0;i<pts.length;i++){
      const p = pts[i];
      if (Math.hypot(p.x-x, p.y-y) <= 18) return i;
    }
    return -1;
  }

  function isPerfectSequence(task){
    const order = task.selectionOrder;
    const n = task.points.length;
    if (order.length !== n) return false;
    for (let i=0;i<n;i++){
      if (order[i] !== i) return false;
    }
    return true;
  }

  function resetAttempt(task){
    task.selected.clear();
    task.selectionOrder = [];
    draw();
  }

  function handlePointerDown(ev){
    // אם אנחנו במצב כיול – הלחיצה שייכת לכיול
    if (calibrationActive){
      handleCalibrationClick(ev);
      return;
    }

    if (!running || !currentTask || pendingNextTaskPoints !== null) return;

    const rect = canvas.getBoundingClientRect();
    const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
    const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    const idx = hitTest(x,y);
    if (idx === -1) return;

    const task = currentTask;
    const selected = task.selected;

    if (selected.has(idx)){
      selected.delete(idx);
      task.selectionOrder = task.selectionOrder.filter(i => i !== idx);
      draw();
      return;
    }

    selected.add(idx);
    task.selectionOrder.push(idx);
    draw();

    if (task.selectionOrder.length === task.points.length){
      if (isPerfectSequence(task)){
        completeCurrentTask();
      } else {
        task.errors += 1;
        resetAttempt(task);
      }
    }
  }

  canvas.addEventListener("pointerdown", handlePointerDown);
  canvas.addEventListener("touchstart", handlePointerDown, {passive:true});

  // ======================= שליחה לטופס 3 (לוג משימות) =======================
  function sendTaskToLogForm(row){
    const params = new URLSearchParams();
    params.set(LOG_ENTRY_PID,       row.pid);
    params.set(LOG_ENTRY_TASK,      String(row.task));
    params.set(LOG_ENTRY_N_POINTS,  String(row.n_points));
    params.set(LOG_ENTRY_ERRORS,    String(row.errors));
    params.set(LOG_ENTRY_DURATION,  String(row.duration_ms));
    params.set(LOG_ENTRY_COMPLETED, String(row.completed));
    params.set(LOG_ENTRY_TIMESTAMP, row.ts);

    const url = LOG_FORM_BASE + params.toString();

    if (navigator.sendBeacon){
      navigator.sendBeacon(url);
    } else {
      fetch(url, { method:"GET", mode:"no-cors" }).catch(()=>{});
    }
  }

  // ======================= לוג משימות וסשן =======================
  function logTask(completed){
    if (!currentTask) return;
    const endTime = now();
    const dur = Math.round(endTime - currentTask.startTime);
    const pid = (pidInput.value || "").trim();

    const row = {
      pid,
      task: currentTask.index,
      n_points: currentTask.points.length,
      errors: currentTask.errors,
      duration_ms: dur,
      completed: completed ? 1 : 0,
      ts: new Date().toISOString()
    };

    tasks.push(row);
    sendTaskToLogForm(row);
  }

  function completeCurrentTask(){
    logTask(true);

    const nextN = currentTask.points.length + CONFIG.incrementBy;
    pendingNextTaskPoints = nextN;
    currentTask = null;
    draw();

    overlayTitle.textContent = "סיימת משימה";
    overlayText.textContent = "לחץ/י על \"משימה הבאה\" כדי להמשיך.";
    overlayContinue.textContent = "משימה הבאה";
    overlay.style.display = "grid";

    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      if (running && pendingNextTaskPoints !== null){
        openNewTask(pendingNextTaskPoints);
      }
    };
  }

  function tick(){
    if (!running) return;
    const elapsedSec = (now() - sessionStart) / 1000;
    if (elapsedSec >= CONFIG.sessionMinutes * 60){
      endSession(true);
    }
  }

  function buildCsv(){
    if (!tasks.length) return "";
    const head = ["pid","task","n_points","errors","duration_ms","completed","ts"];
    const rows = tasks.map(t =>
      [t.pid, t.task, t.n_points, t.errors, t.duration_ms, t.completed, t.ts].join(",")
    );
    return head.join(",") + "\n" + rows.join("\n");
  }

  // ======== בניית המידע שנשלח לטופס 2 ========
  function buildFormSummary(){
    const completedTasks = tasks.filter(t => t.completed === 1);
    const totalTasksCompleted = completedTasks.length;

    let pointsPerTask = "";
    let errorsPerTask = "";
    let durPerTask = "";

    if (completedTasks.length > 0){
      pointsPerTask = completedTasks.map(t => t.n_points).join(",");
      errorsPerTask = completedTasks.map(t => t.errors).join(",");
      durPerTask = completedTasks.map(t => t.duration_ms).join(",");
    }

    return {
      totalTasksCompleted,
      pointsPerTask,
      errorsPerTask,
      durPerTask,
      experimentTime: experimentStartIso || ""
    };
  }

  function redirectToForm(){
    const pid = (pidInput.value || "").trim();
    const summary = buildFormSummary();

    const params = new URLSearchParams();
    params.set(ENTRY_PID, pid || "");
    params.set(ENTRY_TOTAL_TASKS, String(summary.totalTasksCompleted));
    params.set(ENTRY_POINTS_PER_TASK, summary.pointsPerTask);
    params.set(ENTRY_ERRORS_PER_TASK, summary.errorsPerTask);
    params.set(ENTRY_DUR_PER_TASK, summary.durPerTask);
    params.set(ENTRY_EXPERIMENT_TIME, summary.experimentTime);

    const target = FORM_BASE_URL + params.toString();
    window.location.href = target;
  }

  function endSession(autoEnded){
    console.log("endSession called. autoEnded =", autoEnded);

    if (sessionEnded) {
      console.log("sessionEnded already true -> redirectToForm only");
      redirectToForm();
      return;
    }
    sessionEnded = true;
    running = false;
    if (tickId) clearInterval(tickId);
    startBtn.disabled = false;
    endBtn.disabled = true;

    if (currentTask){
      console.log("Logging unfinished currentTask before end");
      logTask(false);
    }

    // קובץ תוצאות המשימה
    const csv = buildCsv();
    console.log("CSV built. length =", csv.length);
    if (csv) {
      console.log("Calling sendCsvToDrive for connect_the_dots_tasks");
      sendCsvToDrive(csv, "connect_the_dots_tasks");
    } else {
      console.log("No CSV content – nothing to send");
    }

    // קובץ סיכום מעקב עיניים (שורה אחת לסשן)
    const eyeCsv = buildEyeCsv();
    console.log("Eye CSV built. length =", eyeCsv.length);
    if (eyeCsv){
      console.log("Calling sendCsvToDrive for webgazer_eye_summary");
      sendCsvToDrive(eyeCsv, "webgazer_eye_summary");
    } else {
      console.log("No eye CSV content – nothing to send (summary)");
    }

    // קובץ מפורט – דגימה לכל רגע בזמן
    const eyeTimelineCsv = buildEyeTimelineCsv();
    console.log("Eye timeline CSV length =", eyeTimelineCsv.length);
    if (eyeTimelineCsv){
      console.log("Calling sendCsvToDrive for webgazer_eye_timeline");
      sendCsvToDrive(eyeTimelineCsv, "webgazer_eye_timeline");
    } else {
      console.log("No eye timeline content – nothing to send");
    }

    // לסגור מצלמה
    if (window.webgazer){
      try { webgazer.end(); } catch(e){}
    }

    overlayTitle.textContent = autoEnded ? "הסשן הסתיים" : "הסשן הופסק";
    overlayText.textContent = "תודה על ביצוע המשימה. כעת נעבור לשאלון קצר נוסף.";
    overlayContinue.textContent = "המשך לשאלון";
    overlay.style.display = "grid";

    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      redirectToForm();
    };
  }

  function startSession(){
    const pid = (pidInput.value || "").trim();
    if (!pid){
      alert("נא למלא מזהה נבדק לפני תחילת המשימה.");
      return;
    }
    running = true;
    sessionEnded = false;
    sessionStart = now();
    experimentStartIso = new Date().toISOString();
    tasks = [];
    taskCounter = 0;
    currentTask = null;
    pendingNextTaskPoints = null;
    overlay.style.display = "none";
    startBtn.disabled = true;
    endBtn.disabled = false;

    resetGazeStats();
    openNewTask(CONFIG.initialPoints);

    if (tickId) clearInterval(tickId);
    tickId = setInterval(tick, 500);
  }

  function handleEndClick(){
    endSession(false);
  }

  function handleStartClick(){
    if (!isCalibrated){
      // אם משום מה הגיע לכאן בלי כיול – נכפה כיול
      showCalibrationIntro();
      return;
    }
    startSession();
  }

  // ======================= Init =======================
  const urlPid = getPidFromUrl();
  if (urlPid){
    pidInput.value = urlPid;
    pidInput.readOnly = true;
  }

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  startBtn.addEventListener("click", handleStartClick);
  endBtn.addEventListener("click", handleEndClick);

  // מציג חלון כיול כבר בהתחלה
  showCalibrationIntro();
})();
</script>
</body>
</html>
