<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>××©×™××ª ×—×™×‘×•×¨ × ×§×•×“×•×ª<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>××©×™××ª ×—×™×‘×•×¨ × ×§×•×“×•×ª â€“ × ×™×¡×•×™ ×§×©×‘ + ××¢×§×‘ ×¢×™× ×™×™×</title>
  <style>
    :root{
      --bg:#020617;
      --panel:#0b1120;
      --ink:#e5e7eb;
      --muted:#94a3b8;
      --stroke:#64748b;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      display:grid;
      grid-template-rows:auto 1fr auto;
    }
    header,footer{
      background:var(--panel);
      padding:10px 16px;
      border-bottom:1px solid #111827;
    }
    footer{
      border-top:1px solid #111827;
      border-bottom:none;
      font-size:0.8rem;
      color:var(--muted);
      text-align:center;
    }
    .top{
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:center;
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      justify-content:center;
      align-items:center;
    }
    label{font-size:0.9rem;color:var(--muted);}
    input{
      background:#020617;
      border:1px solid #334155;
      color:var(--ink);
      padding:4px 8px;
      border-radius:8px;
      min-width:140px;
    }
    input[readonly]{opacity:0.8;}
    button{
      border-radius:999px;
      border:1px solid #334155;
      background:#111827;
      color:var(--ink);
      padding:6px 14px;
      cursor:pointer;
      font-size:0.9rem;
      white-space:nowrap;
    }
    button:disabled{ opacity:0.4; cursor:not-allowed; }
    button:hover:not(:disabled){ border-color:#60a5fa; }

    #stageWrap{
      padding:10px 16px 16px;
      position:relative;
    }
    #stage{
      width:100%;
      height:70vh;
      display:block;
      background:#020617;
      border-radius:18px;
      border:1px solid #1f2937;
      touch-action:none;
    }

    #overlay{
      position:absolute;
      inset:10px 16px 16px;
      display:none;
      place-items:center;
      background:rgba(15,23,42,0.82);
      border-radius:18px;
      z-index:10;
    }
    #overlay .box{
      background:#020617;
      border-radius:16px;
      border:1px solid #1f2937;
      padding:20px 24px;
      max-width:560px;
      text-align:center;
    }
    #overlay h2{ margin:0 0 8px; }
    .muted{ color:var(--muted); }
  </style>

  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
</head>
<body>
  <header>
    <div class="top">
      <div class="muted">
        ×”××©×™××” ×ª×™××©×š ×¢×“ <b>10 ×“×§×•×ª</b> ××• ×¢×“ ×œ×—×™×¦×” ×¢×œ "×¡×™×•× ××•×§×“×".
      </div>

      <div class="controls">
        <label for="pid">××–×”×” × ×‘×“×§:</label>
        <input id="pid" type="text" placeholder="×œ×“×•×’××” ABC123" />

        <button id="startBtn" disabled>×”×ª×—×œ ××©×™××”</button>
        <button id="endBtn" disabled>×¡×™×•× ××•×§×“×</button>

        <!-- DEBUG controls (× ×•×¨×™×“ ×‘×”××©×š) -->
        <button id="flipXBtn" type="button" disabled>Flip X: OFF</button>
        <button id="flipYBtn" type="button" disabled>Flip Y: OFF</button>
        <button id="swapBtn"  type="button" disabled>Swap Xâ†”Y: OFF</button>
      </div>
    </div>
  </header>

  <div id="stageWrap">
    <canvas id="stage"></canvas>

    <div id="overlay">
      <div class="box">
        <h2 id="overlayTitle">×”×•×“×¢×”</h2>
        <p id="overlayText" class="muted"></p>
        <button id="overlayContinue">×”××©×š</button>
      </div>
    </div>
  </div>

  <footer>
    ×™×© ×œ×œ×—×•×¥ ×¢×œ ×”××¡×¤×¨×™× ×œ×¤×™ ×¡×“×¨ ×¢×•×œ×”. × ×™×ª×Ÿ ×œ×”×¡×™×¨ ×‘×—×™×¨×” ×¢×œ ×™×“×™ ×œ×—×™×¦×” ×—×•×–×¨×ª ×¢×œ ××•×ª×• ××¡×¤×¨.
  </footer>

<script>
(() => {
  // ======================= ×”×’×“×¨×•×ª ×›×œ×œ×™×•×ª =======================
  const CONFIG = {
    sessionMinutes: 10,
    initialPoints: 16,
    incrementBy: 0,
    minDistance: 30,
    lineAvoidDistance: 16
  };

  const FRAME_MARGIN_X_RATIO = 0.06;
  const FRAME_MARGIN_Y_RATIO = 0.10;
  const POINT_INNER_PADDING = 40;

  // ======================= ×™×¦×™×‘×•×ª/×¨×’×™×©×•×ª =======================
  const OFF_MIN_MS = 900;

  // ×›×™×•×•×Ÿ ×‘×¨×™×—×” ×™×¦×™×‘
  const DIR_WINDOW_MS = 450;
  const DIR_MIN_VOTES = 8;
  const DIR_DEADZONE_RATIO = 0.28;

  // Tracking: ×¤×—×•×ª lag, ×¤×—×•×ª ×¨×™×¦×•×“
  const SMOOTH_ALPHA = 0.28;   // â†“ ×§×¦×ª ×›×“×™ ×œ×”×¤×—×™×ª ×¨×™×¦×•×“ (×›×‘×¨ ×™×© median)
  const MAX_STEP_PX  = 140;    // â†‘ ×§×¦×ª ×›×“×™ ×œ× "×œ×”×™×ª×§×¢" ×‘×§×¤×™×¦×•×ª

  // Median filter ×§×˜×Ÿ ×œ×”×¤×—×ª×ª ×¨×™×¦×•×“
  const MEDIAN_WIN = 5;        // 5 ×“×’×™××•×ª

  // --- × ×§×•×“×ª ××¨×›×– ---
  const CENTER_HOLD_MS = 5000;
  const CENTER_MIN_SAMPLES = 18;

  // ×‘×“×™×§×ª ××™×›×•×ª: ×× ×¤×™×–×•×¨ ×’×“×•×œ ××“×™ -> × ×•×¡×™×£ ×¢×•×“ 3 ×©× ×™×•×ª + ×”×•×“×¢×”
  const CENTER_MAX_STD_PX = 65;     // ×× ×”×¨×™×¦×•×“ ×’×‘×•×” ××–×”, ×–×” "×œ× ×™×¦×™×‘"
  const CENTER_EXTRA_MS   = 3000;

  const DRAW_GAZE_DOT = true;

  // ======================= ×©×œ×™×—×” ×œÖ¾Drive =======================
  const SCRIPT_URL =
    "https://script.google.com/macros/s/AKfycbzVinB7VZA9P3mkKYpfYuykv6JXF62w70s7I98iOqU2YhRyigD0lcBndONHsx5rdhRnRA/exec";

  function sendCsvToDrive(csvContent, label) {
    if (!csvContent) return;
    const rawPid = (pidInput.value || "").trim();
    const safePid = rawPid ? rawPid.replace(/[^a-zA-Z0-9_-]/g, "") : "PID";
    const ts = new Date().toISOString().replace(/[:.]/g, "");
    const filename = `${safePid}_${label}_${ts}.csv`;
    const payload = { filename, mimeType: "text/csv", content: csvContent };

    fetch(SCRIPT_URL, {
      method: "POST",
      mode: "no-cors",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    }).catch(err => console.error("Failed to send CSV to Drive:", err));
  }

  // ======================= ×˜×¤×¡×™× =======================
  const FORM_ID = "1FAIpQLSdTCgLVjt4LXsNAkXP1H8jxIC5MPsdv1sD93v5lmglckCAzrA";
  const ENTRY_PID             = "entry.404955311";
  const ENTRY_TOTAL_TASKS     = "entry.1331557537";
  const ENTRY_POINTS_PER_TASK = "entry.742152065";
  const ENTRY_ERRORS_PER_TASK = "entry.1634677467";
  const ENTRY_DUR_PER_TASK    = "entry.529234118";
  const ENTRY_EXPERIMENT_TIME = "entry.883845532";
  const FORM_BASE_URL =
    "https://docs.google.com/forms/d/e/" + FORM_ID + "/viewform?usp=pp_url&";

  const LOG_FORM_ID = "1FAIpQLSdrl006D8HAWo0YfsdWUMppGEewGOp8Snm3ANot8OxzSBkusA";
  const LOG_FORM_BASE =
    "https://docs.google.com/forms/d/e/" + LOG_FORM_ID + "/formResponse?";
  const LOG_ENTRY_PID        = "entry.152946855";
  const LOG_ENTRY_TASK       = "entry.781109584";
  const LOG_ENTRY_N_POINTS   = "entry.347168050";
  const LOG_ENTRY_ERRORS     = "entry.1932703164";
  const LOG_ENTRY_DURATION   = "entry.1227866932";
  const LOG_ENTRY_COMPLETED  = "entry.1100470565";
  const LOG_ENTRY_TIMESTAMP  = "entry.1243807469";

  // ======================= DOM =======================
  const canvas = document.getElementById("stage");
  const ctx = canvas.getContext("2d");

  const pidInput = document.getElementById("pid");
  const startBtn = document.getElementById("startBtn");
  const endBtn = document.getElementById("endBtn");

  const flipXBtn = document.getElementById("flipXBtn");
  const flipYBtn = document.getElementById("flipYBtn");
  const swapBtn  = document.getElementById("swapBtn");

  const overlay = document.getElementById("overlay");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlayText = document.getElementById("overlayText");
  const overlayContinue = document.getElementById("overlayContinue");

  // ======================= STATE =======================
  let running = false;
  let sessionStart = null;
  let experimentStartIso = null;
  let tickId = null;
  let tasks = [];
  let taskCounter = 0;
  let currentTask = null;
  let pendingNextTaskPoints = null;
  let sessionEnded = false;

  let isCalibrated = false;
  const CALIB_POINTS_TOTAL = 17;
  let calibrationActive = false;
  let calibrationPoints = [];
  let calibrationIndex = 0;

  let centerHoldActive = false;
  let centerHoldStart = null;
  let centerHoldDurationMs = CENTER_HOLD_MS;
  let centerSamples = [];

  const taskLayouts = [];

  // ======================= Debug / mapping toggles =======================
  let FLIP_X = false;
  let FLIP_Y = false;
  let SWAP_XY = false;

  // ======================= Tracking fix =======================
  const gazeFix = {
    offsetX: 0,
    offsetY: 0,
    hasOffset: false,
    smoothX: null,
    smoothY: null,
    medBufX: [],
    medBufY: []
  };

  const dbg = { x:null, y:null, zone:"O" };

  function getScreenSize(){ return { w: window.innerWidth, h: window.innerHeight }; }

  function resetSmoothing(){
    gazeFix.smoothX = null;
    gazeFix.smoothY = null;
    gazeFix.medBufX.length = 0;
    gazeFix.medBufY.length = 0;
  }

  function medianOf(arr){
    if (!arr.length) return null;
    const a = [...arr].sort((x,y)=>x-y);
    const m = Math.floor(a.length/2);
    return a.length % 2 ? a[m] : (a[m-1] + a[m]) / 2;
  }

  // mode: "calib" (×‘×œ×™ median/smooth/step), "run"
  function applyFixes(rawX, rawY, mode){
    if (rawX == null || rawY == null) return { x:null, y:null, rawX:null, rawY:null };

    let x = rawX, y = rawY;

    // Swap ×§×•×“×
    if (SWAP_XY){
      const t = x; x = y; y = t;
    }

    // Flip
    const { w, h } = getScreenSize();
    if (FLIP_X) x = w - x;
    if (FLIP_Y) y = h - y;

    // Offset
    if (gazeFix.hasOffset){
      x += gazeFix.offsetX;
      y += gazeFix.offsetY;
    }

    const rawFixedX = x;
    const rawFixedY = y;

    if (mode === "calib"){
      return { x: rawFixedX, y: rawFixedY, rawX: rawFixedX, rawY: rawFixedY };
    }

    // Median filter (×¨×§ ×‘-run)
    gazeFix.medBufX.push(rawFixedX);
    gazeFix.medBufY.push(rawFixedY);
    if (gazeFix.medBufX.length > MEDIAN_WIN) gazeFix.medBufX.shift();
    if (gazeFix.medBufY.length > MEDIAN_WIN) gazeFix.medBufY.shift();

    const mx = medianOf(gazeFix.medBufX) ?? rawFixedX;
    const my = medianOf(gazeFix.medBufY) ?? rawFixedY;

    // Step-limit (×œ× ×œ×”×§×¤×™×)
    let sx = mx, sy = my;
    if (gazeFix.smoothX != null && gazeFix.smoothY != null){
      const dx = mx - gazeFix.smoothX;
      const dy = my - gazeFix.smoothY;
      const d  = Math.hypot(dx, dy);
      if (d > MAX_STEP_PX){
        sx = gazeFix.smoothX + (dx / d) * MAX_STEP_PX;
        sy = gazeFix.smoothY + (dy / d) * MAX_STEP_PX;
      }
    }

    // EMA smoothing
    if (gazeFix.smoothX == null){
      gazeFix.smoothX = sx;
      gazeFix.smoothY = sy;
    } else {
      gazeFix.smoothX = gazeFix.smoothX + SMOOTH_ALPHA * (sx - gazeFix.smoothX);
      gazeFix.smoothY = gazeFix.smoothY + SMOOTH_ALPHA * (sy - gazeFix.smoothY);
    }

    return { x: gazeFix.smoothX, y: gazeFix.smoothY, rawX: rawFixedX, rawY: rawFixedY };
  }

  // ======================= Zones =======================
  function getZoneRects(){
    const rect = canvas.getBoundingClientRect();
    const marginX = Math.max(rect.width  * FRAME_MARGIN_X_RATIO, 40);
    const marginY = Math.max(rect.height * FRAME_MARGIN_Y_RATIO, 40);
    const innerRect = {
      left:   rect.left + marginX,
      right:  rect.right - marginX,
      top:    rect.top  + marginY,
      bottom: rect.bottom - marginY
    };
    return { canvasRect: rect, innerRect, marginX, marginY };
  }

  function classifyZone(hadRaw, x, y){
    if (!hadRaw || x == null || y == null) return "O";

    const { canvasRect, innerRect } = getZoneRects();
    const inCanvas =
      x >= canvasRect.left && x <= canvasRect.right &&
      y >= canvasRect.top  && y <= canvasRect.bottom;
    if (!inCanvas) return "O";

    const inTask =
      x >= innerRect.left && x <= innerRect.right &&
      y >= innerRect.top  && y <= innerRect.bottom;
    if (inTask) return "T";

    const cx = (innerRect.left + innerRect.right) / 2;
    const cy = (innerRect.top  + innerRect.bottom) / 2;

    const dx = x - cx;
    const dy = y - cy;

    const deadX = (innerRect.right - innerRect.left) * DIR_DEADZONE_RATIO;
    const deadY = (innerRect.bottom - innerRect.top) * DIR_DEADZONE_RATIO;
    if (Math.abs(dx) < deadX && Math.abs(dy) < deadY) return "O";

    if (Math.abs(dx) >= Math.abs(dy)) return dx >= 0 ? "R" : "L";
    return dy >= 0 ? "D" : "U";
  }

  // ======================= Stats / timeline =======================
  const gazeStats = {
    hasStarted: false,
    lastTime: null,
    lastZone: "O",
    totalOnMs: 0,
    totalOffMs: 0,
    totalSamples: 0,
    validSamples: 0,
    invalidSamples: 0,
    offEvents: 0,
    offLeftEvents: 0,
    offRightEvents: 0,
    offUpEvents: 0,
    offDownEvents: 0,
    timeTaskMs: 0,
    timeDeviationMs: 0
  };

  const offState = {
    candidate: false,
    candidateStart: null,
    inOff: false,
    dir: "",
    votes: { L:0, R:0, U:0, D:0 },
    votesStart: null
  };

  const gazeTimeline = [];

  function resetGazeStats(){
    Object.assign(gazeStats,{
      hasStarted:false,lastTime:null,lastZone:"O",
      totalOnMs:0,totalOffMs:0,totalSamples:0,validSamples:0,invalidSamples:0,
      offEvents:0,offLeftEvents:0,offRightEvents:0,offUpEvents:0,offDownEvents:0,
      timeTaskMs:0,timeDeviationMs:0
    });
    offState.candidate=false; offState.candidateStart=null;
    offState.inOff=false; offState.dir="";
    offState.votes={L:0,R:0,U:0,D:0}; offState.votesStart=null;
    gazeTimeline.length=0;
    resetSmoothing();
  }

  // ======================= Drawing =======================
  function drawGazeDotAndStatus(){
    if (!DRAW_GAZE_DOT) return;

    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const { marginX, marginY } = getZoneRects();

    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1.2;
    ctx.strokeRect(marginX, marginY, w - 2*marginX, h - 2*marginY);

    if (dbg.x != null && dbg.y != null){
      const rect = canvas.getBoundingClientRect();
      const gx = dbg.x - rect.left;
      const gy = dbg.y - rect.top;
      ctx.fillStyle = "rgba(239,68,68,0.95)";
      ctx.beginPath();
      ctx.arc(gx, gy, 6, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "12px system-ui, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const mapTxt = `swap=${SWAP_XY?"ON":"OFF"} flipX=${FLIP_X?"ON":"OFF"} flipY=${FLIP_Y?"ON":"OFF"}`;
    ctx.fillText(`zone=${dbg.zone} dir=${offState.dir||"-"}  ${mapTxt}`, 12, 12);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

    if (calibrationActive && calibrationPoints.length){
      const p = calibrationPoints[calibrationIndex] || calibrationPoints[calibrationPoints.length-1];
      ctx.fillStyle = "#ef4444";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "14px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(`× ×§×•×“×” ${calibrationIndex+1} ××ª×•×š ${calibrationPoints.length} â€“ ×œ×—×¥ ×¢×œ ×”× ×§×•×“×” ×”××“×•××”`, p.x, p.y + 18);

      drawGazeDotAndStatus();
      return;
    }

    if (centerHoldActive){
      const { marginX, marginY } = getZoneRects();
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      const cx = marginX + (w - 2*marginX)/2;
      const cy = marginY + (h - 2*marginY)/2;

      ctx.fillStyle = "#ef4444";
      ctx.beginPath();
      ctx.arc(cx, cy, 14, 0, Math.PI*2);
      ctx.fill();

      const elapsed = performance.now() - centerHoldStart;
      const leftMs = Math.max(0, centerHoldDurationMs - elapsed);
      const leftSec = Math.ceil(leftMs/1000);

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "14px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(`× × ×œ×”×ª××™×“ ×‘××‘×˜ ×¢×œ ×”× ×§×•×“×” ×‘××¨×›×– (${leftSec})`, cx, cy + 20);

      drawGazeDotAndStatus();
      return;
    }

    if (!currentTask){
      drawGazeDotAndStatus();
      return;
    }

    const pts = currentTask.points;
    const order = currentTask.selectionOrder;

    if (order.length > 1){
      ctx.strokeStyle = "#e5e7eb";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const first = pts[order[0]];
      ctx.moveTo(first.x, first.y);
      for (let i=1;i<order.length;i++){
        const p = pts[order[i]];
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "14px system-ui, Arial";

    pts.forEach((p, idx) => {
      const isSelected = currentTask.selected.has(idx);
      const radius = 13;
      if (isSelected){
        ctx.fillStyle = "#e5e7eb";
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#020617";
        ctx.fillText(String(idx+1), p.x, p.y);
      } else {
        ctx.fillStyle = "#020617";
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "#64748b";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.fillStyle = "#e5e7eb";
        ctx.fillText(String(idx+1), p.x, p.y);
      }
    });

    drawGazeDotAndStatus();
  }

  let drawQueued=false;
  function requestDraw(){
    if(drawQueued) return;
    drawQueued=true;
    requestAnimationFrame(()=>{ drawQueued=false; draw(); });
  }

  // ======================= WebGazer listener =======================
  function handleGaze(data, elapsedTime){
    if (sessionEnded) return;

    const hadRaw = !!data;
    const rawX = hadRaw ? data.x : null;
    const rawY = hadRaw ? data.y : null;

    const mode = centerHoldActive ? "calib" : "run";
    const fixed = hadRaw ? applyFixes(rawX, rawY, mode) : {x:null,y:null,rawX:null,rawY:null};

    dbg.x = fixed.x;
    dbg.y = fixed.y;

    if (centerHoldActive && hadRaw && fixed.rawX != null && fixed.rawY != null){
      centerSamples.push({x: fixed.rawX, y: fixed.rawY});
    }

    if (!running || !currentTask){
      dbg.zone = classifyZone(hadRaw, fixed.x, fixed.y);
      requestDraw();
      return;
    }

    const t = elapsedTime;
    const zoneNow = classifyZone(hadRaw, fixed.x, fixed.y);
    dbg.zone = zoneNow;

    const onFlag = (zoneNow === "T") ? 1 : 0;

    if (!gazeStats.hasStarted){
      gazeStats.hasStarted=true;
      gazeStats.lastTime=t;
      gazeStats.lastZone=zoneNow;
      gazeStats.totalSamples=1;
      if (hadRaw) gazeStats.validSamples=1; else gazeStats.invalidSamples=1;
    } else {
      const dt = t - (gazeStats.lastTime || t);
      gazeStats.lastTime = t;

      if (gazeStats.lastZone === "T"){
        gazeStats.totalOnMs += dt;
        gazeStats.timeTaskMs += dt;
      } else {
        gazeStats.totalOffMs += dt;
        gazeStats.timeDeviationMs += dt;
      }

      gazeStats.totalSamples++;
      if (hadRaw) gazeStats.validSamples++;
      else gazeStats.invalidSamples++;
    }

    // OFF direction vote
    if (onFlag === 1){
      if (offState.candidate || offState.inOff || offState.votesStart != null){
        offState.candidate=false; offState.candidateStart=null;
        offState.inOff=false; offState.dir="";
        offState.votes={L:0,R:0,U:0,D:0}; offState.votesStart=null;
      }
    } else {
      if (gazeStats.lastZone === "T" && !offState.candidate){
        offState.candidate=true;
        offState.candidateStart=t;
        offState.inOff=false;
        offState.dir="";
        offState.votes={L:0,R:0,U:0,D:0};
        offState.votesStart=t;
      }

      if (zoneNow === "L") offState.votes.L++;
      else if (zoneNow === "R") offState.votes.R++;
      else if (zoneNow === "U") offState.votes.U++;
      else if (zoneNow === "D") offState.votes.D++;

      if (offState.votesStart != null && (t - offState.votesStart) >= DIR_WINDOW_MS){
        const arr = [
          ["L", offState.votes.L],
          ["R", offState.votes.R],
          ["U", offState.votes.U],
          ["D", offState.votes.D],
        ].sort((a,b)=>b[1]-a[1]);

        const [bestDir, bestVotes] = arr[0];
        if (bestVotes >= DIR_MIN_VOTES) offState.dir = bestDir;

        offState.votes={L:0,R:0,U:0,D:0};
        offState.votesStart=t;
      }

      if (offState.candidate && !offState.inOff &&
          offState.candidateStart != null &&
          (t - offState.candidateStart) >= OFF_MIN_MS){
        offState.inOff=true;
        if (offState.dir){
          gazeStats.offEvents++;
          if (offState.dir==="L") gazeStats.offLeftEvents++;
          else if (offState.dir==="R") gazeStats.offRightEvents++;
          else if (offState.dir==="U") gazeStats.offUpEvents++;
          else if (offState.dir==="D") gazeStats.offDownEvents++;
        }
      }
    }

    const ms = Math.round(t);
    const taskIndex = currentTask ? currentTask.index : 0;

    let xOut="", yOut="";
    if (hadRaw && fixed.x != null && fixed.y != null){
      xOut = Math.round(fixed.x);
      yOut = Math.round(fixed.y);
    }

    let dirSample = "";
    if (onFlag===0 && offState.dir) dirSample = offState.dir;

    gazeTimeline.push({
      ms,
      task: taskIndex,
      zone: zoneNow,
      x: xOut,
      y: yOut,
      on: onFlag,
      dir: dirSample
    });

    gazeStats.lastZone = zoneNow;
    requestDraw();
  }

  // ======================= CSV builders =======================
  function buildEyeCsv(){
    const pid = (pidInput.value || "").trim();
    if (!gazeStats.hasStarted && gazeStats.totalSamples === 0) return "";
    const head = [
      "pid","total_on_ms","total_off_ms","total_samples","valid_samples","invalid_samples",
      "off_events","off_left_events","off_right_events","off_up_events","off_down_events",
      "time_task_ms","time_deviation_ms"
    ];
    const row = [
      pid,
      Math.round(gazeStats.totalOnMs),
      Math.round(gazeStats.totalOffMs),
      gazeStats.totalSamples,
      gazeStats.validSamples,
      gazeStats.invalidSamples,
      gazeStats.offEvents,
      gazeStats.offLeftEvents,
      gazeStats.offRightEvents,
      gazeStats.offUpEvents,
      gazeStats.offDownEvents,
      Math.round(gazeStats.timeTaskMs),
      Math.round(gazeStats.timeDeviationMs)
    ].join(",");
    return head.join(",") + "\n" + row + "\n";
  }

  function buildEyeTimelineCsv(){
    const pid = (pidInput.value || "").trim();
    if (!gazeTimeline.length) return "";
    const head = ["pid","task_index","ms","zone","x","y","on_screen","off_direction"];
    const rows = gazeTimeline.map(s =>
      [pid, s.task, s.ms, s.zone || "", s.x, s.y, s.on, s.dir].join(",")
    );
    return head.join(",") + "\n" + rows.join("\n");
  }

  function buildPointsLayoutCsv(){
    const pid = (pidInput.value || "").trim();
    if (!taskLayouts.length) return "";
    const head = ["pid","task_index","point_index","number","x_screen","y_screen"];
    const rows = taskLayouts.map(row =>
      [pid,row.task_index,row.point_index,row.number,Math.round(row.x_screen),Math.round(row.y_screen)].join(",")
    );
    return head.join(",") + "\n" + rows.join("\n");
  }

  // ======================= WebGazer + Calibration =======================
  function startWebgazerAndCalibration(){
    if (!window.webgazer){
      alert("×¡×¤×¨×™×™×ª WebGazer ×œ× × ×˜×¢× ×”. × ×™×ª×Ÿ ×œ×”××©×™×š ×¢× ×”××©×™××” ×‘×œ×™ ××¢×§×‘ ×¢×™× ×™×™×.");
      startBtn.disabled = false;
      return;
    }

    window.saveDataAcrossSessions = false;

    try{
      if (webgazer.applyKalmanFilter) webgazer.applyKalmanFilter(true);
      if (webgazer.setRegression) webgazer.setRegression("ridge");

      webgazer
        .setGazeListener(handleGaze)
        .showVideo(false)
        .showFaceOverlay(false)
        .showPredictionPoints(false)
        .begin();

    } catch(e){
      console.error("WebGazer error:", e);
      alert("×œ× × ×™×ª×Ÿ ×œ×”×¤×¢×™×œ ××ª ××¢×§×‘ ×”×¢×™× ×™×™×. × ×™×ª×Ÿ ×œ×”××©×™×š ×‘××©×™××” ×œ×œ× ×”××¢×¨×›×ª.");
      startBtn.disabled = false;
      return;
    }

    setTimeout(startCalibrationSequence, 900);
  }

  function generateCalibrationPoints(count){
    const rect = canvas.getBoundingClientRect();
    const m = 30;
    const W = Math.max(rect.width - 2*m, 220);
    const H = Math.max(rect.height - 2*m, 220);
    const pattern = [
      [0.10,0.10],[0.50,0.10],[0.90,0.10],
      [0.10,0.50],[0.50,0.50],[0.90,0.50],
      [0.10,0.90],[0.50,0.90],[0.90,0.90],
      [0.05,0.20],[0.95,0.20],[0.05,0.80],[0.95,0.80],
      [0.20,0.05],[0.80,0.05],[0.20,0.95],[0.80,0.95]
    ];
    const needed = Math.min(count, pattern.length);
    const pts = [];
    for (let i=0; i<needed; i++){
      const [nx,ny] = pattern[i];
      pts.push({ x: m + nx*W, y: m + ny*H });
    }
    return pts;
  }

  function startCalibrationSequence(){
    calibrationPoints = generateCalibrationPoints(CALIB_POINTS_TOTAL);
    calibrationIndex = 0;
    calibrationActive = true;
    draw();
  }

  function handleCalibrationClick(ev){
    if (!calibrationActive || !calibrationPoints.length) return;
    const rect = canvas.getBoundingClientRect();
    const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
    const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    const current = calibrationPoints[calibrationIndex];
    if (!current) return;
    const d = Math.hypot(current.x - x, current.y - y);
    if (d > 40) return;

    try{
      if (window.webgazer && webgazer.recordScreenPosition){
        const vx = rect.left + current.x;
        const vy = rect.top  + current.y;
        webgazer.recordScreenPosition(vx, vy, "click");
      }
    } catch(e){}

    calibrationIndex++;
    if (calibrationIndex >= calibrationPoints.length){
      calibrationActive = false;
      startCenterHold(CENTER_HOLD_MS, false);
    } else {
      draw();
    }
  }

  function startCenterHold(durationMs, isRetry){
    centerHoldActive = true;
    centerHoldStart = performance.now();
    centerHoldDurationMs = durationMs;
    centerSamples = [];
    resetSmoothing();

    overlayTitle.textContent = "×©×œ×‘ ××—×¨×•×Ÿ ×‘×›×™×•×œ";
    overlayText.textContent = isRetry
      ? "× ×¨××” ×©×”××¢×§×‘ ×œ× ×™×¦×™×‘ ××¡×¤×™×§ (×¨×™×¦×•×“/×ª××•×¨×”/×ª× ×•×—×”). × × ×œ×©×‘×ª ×™×©×¨ ××•×œ ×”××¡×š, ×œ×”×“×œ×™×§ ×ª××•×¨×”, ×•×œ×”×ª××™×“ ×‘××‘×˜ ×¢×œ ×”× ×§×•×“×” ×‘××¨×›×–. × ××©×™×š ×¢×•×“ ×›××” ×©× ×™×•×ª."
      : "×›×¢×ª ×¢×œ×™×š ×œ×”×ª××™×“ ×‘××‘×˜ ×¢×œ ×”× ×§×•×“×” ×‘××¨×›×– (×‘×œ×™ ×œ×”×–×™×– ××ª ×”×¨××©).";
    overlayContinue.textContent = "×”×ª×—×œ";
    overlay.style.display = "grid";

    overlayContinue.onclick = () => {
      overlay.style.display = "none";

      const step = () => {
        if (!centerHoldActive) return;
        const elapsed = performance.now() - centerHoldStart;
        requestDraw();

        if (elapsed >= centerHoldDurationMs){
          finalizeCenterHold();
          return;
        }
        setTimeout(step, 50);
      };
      step();
    };
  }

  function stdOf(arr){
    if (arr.length < 2) return 9999;
    const m = arr.reduce((a,v)=>a+v,0)/arr.length;
    const v = arr.reduce((a,vv)=>a+(vv-m)*(vv-m),0)/(arr.length-1);
    return Math.sqrt(v);
  }

  function finalizeCenterHold(){
    centerHoldActive = false;

    if (centerSamples.length < CENTER_MIN_SAMPLES){
      // ×œ× ××¡×¤×™×§ ×“×’×™××•×ª -> ×¢×•×“ ×–××Ÿ + ×”×“×¨×›×”
      startCenterHold(CENTER_EXTRA_MS, true);
      return;
    }

    // ×‘×•×“×§×™× ×™×¦×™×‘×•×ª (×¨×™×¦×•×“)
    const xs = centerSamples.map(s=>s.x);
    const ys = centerSamples.map(s=>s.y);
    const sx = stdOf(xs);
    const sy = stdOf(ys);

    if (sx > CENTER_MAX_STD_PX || sy > CENTER_MAX_STD_PX){
      // ×¨×™×¦×•×“ ×’×‘×•×” -> ×¢×•×“ ×–××Ÿ + ×”×“×¨×›×”
      startCenterHold(CENTER_EXTRA_MS, true);
      return;
    }

    // ××—×©×‘×™× offset ×œ×¤×™ ×××•×¦×¢ ×¤×©×•×˜ (×›×™ ×›×‘×¨ ×™×¦×™×‘)
    const avgX = xs.reduce((a,v)=>a+v,0)/xs.length;
    const avgY = ys.reduce((a,v)=>a+v,0)/ys.length;

    const { innerRect } = getZoneRects();
    const targetCx = (innerRect.left + innerRect.right) / 2;
    const targetCy = (innerRect.top  + innerRect.bottom) / 2;

    gazeFix.offsetX = (targetCx - avgX);
    gazeFix.offsetY = (targetCy - avgY);
    gazeFix.hasOffset = true;

    resetSmoothing();

    isCalibrated = true;
    startBtn.disabled = false;

    // enable debug toggles (×¨×§ ×¢×›×©×™×•, ×›×“×™ ×œ× ×œ×©×’×¢ ×œ×¤× ×™ ×›×™×•×œ)
    flipXBtn.disabled = false;
    flipYBtn.disabled = false;
    swapBtn.disabled  = false;

    overlayTitle.textContent = "×”××¢×¨×›×ª ××›×•×™×™×œ×ª";
    overlayText.textContent = `×”×›×™×•×œ ×”×•×©×œ× + ×™×™×©×•×¨ ××¨×›×–. (samples=${centerSamples.length}, stdX=${sx.toFixed(0)}, stdY=${sy.toFixed(0)})`;
    overlayContinue.textContent = "×”×ª×—×œ ×”××©×™××”";
    overlay.style.display = "grid";
    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      startSession();
    };

    draw();
  }

  function showCalibrationIntro(){
    overlayTitle.textContent = "×›×™×•×œ ××¦×œ××” ×•××¢×¨×›×ª ××¢×§×‘ ×¢×™× ×™×™×";
    overlayText.textContent = "×™×© ×œ××©×¨ ×¤×ª×™×—×ª ××¦×œ××”. ×œ××—×¨ ××›×Ÿ ×™×•×¤×™×¢×• 17 × ×§×•×“×•×ª ××“×•××•×ª â€“ ×™×© ×œ×”×‘×™×˜ ×‘×›×œ × ×§×•×“×” ×•×œ×œ×—×•×¥ ×¢×œ×™×”.";
    overlayContinue.textContent = "×¤×ª×— ××¦×œ××” ×•×›×™×™×œ";
    overlay.style.display = "grid";
    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      startWebgazerAndCalibration();
    };
  }

  // ======================= Tasks =======================
  function now(){ return performance.now(); }
  function randomBetween(min,max){ return min + Math.random() * (max - min); }

  function pointToSegmentDistance(p,a,b){
    const vx=b.x-a.x, vy=b.y-a.y;
    const wx=p.x-a.x, wy=p.y-a.y;
    const c1=vx*wx+vy*wy;
    if(c1<=0) return Math.hypot(p.x-a.x,p.y-a.y);
    const c2=vx*vx+vy*vy;
    if(c2<=c1) return Math.hypot(p.x-b.x,p.y-b.y);
    const tt=c1/c2;
    const projX=a.x+tt*vx, projY=a.y+tt*vy;
    return Math.hypot(p.x-projX,p.y-projY);
  }

  function generatePoints(n){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    const frameMarginX = Math.max(w * FRAME_MARGIN_X_RATIO, 40);
    const frameMarginY = Math.max(h * FRAME_MARGIN_Y_RATIO, 40);

    const left = frameMarginX + POINT_INNER_PADDING;
    const top  = frameMarginY + POINT_INNER_PADDING;
    const W = w - 2 * (frameMarginX + POINT_INNER_PADDING);
    const H = h - 2 * (frameMarginY + POINT_INNER_PADDING);

    const pts = [];
    let attempts = 0;
    const maxAttempts = 4000;

    while (pts.length < n && attempts < maxAttempts){
      attempts++;
      const candidate = { x: randomBetween(left, left + W), y: randomBetween(top, top + H) };

      let ok = true;
      for (const p of pts){
        if (Math.hypot(p.x-candidate.x, p.y-candidate.y) < CONFIG.minDistance){ ok = false; break; }
      }
      if (!ok) continue;

      for (let i = 1; i < pts.length; i++){
        const d = pointToSegmentDistance(candidate, pts[i-1], pts[i]);
        if (d < CONFIG.lineAvoidDistance){ ok = false; break; }
      }
      if (!ok) continue;

      pts.push(candidate);
    }

    while (pts.length < n){
      pts.push({ x: randomBetween(left, left + W), y: randomBetween(top, top + H) });
    }
    return pts;
  }

  function openNewTask(n){
    pendingNextTaskPoints = null;
    const pts = generatePoints(n);

    currentTask = {
      index: ++taskCounter,
      points: pts,
      selected: new Set(),
      selectionOrder: [],
      errors: 0,
      startTime: now()
    };

    try {
      const rect = canvas.getBoundingClientRect();
      const layoutRows = pts.map((p, idx) => ({
        task_index: currentTask.index,
        point_index: idx + 1,
        number: idx + 1,
        x_screen: rect.left + p.x,
        y_screen: rect.top  + p.y
      }));
      taskLayouts.push(...layoutRows);
    } catch (e) {}

    draw();
  }

  function hitTest(x,y){
    if (!currentTask) return -1;
    const pts = currentTask.points;
    for(let i=0;i<pts.length;i++){
      const p = pts[i];
      if (Math.hypot(p.x-x, p.y-y) <= 18) return i;
    }
    return -1;
  }

  function isPerfectSequence(task){
    const order = task.selectionOrder;
    const n = task.points.length;
    if (order.length !== n) return false;
    for (let i=0; i<n; i++){
      if (order[i] !== i) return false;
    }
    return true;
  }

  function resetAttempt(task){
    task.selected.clear();
    task.selectionOrder = [];
    draw();
  }

  function handlePointerDown(ev){
    if (calibrationActive){
      handleCalibrationClick(ev);
      return;
    }
    if (centerHoldActive) return;
    if (!running || !currentTask || pendingNextTaskPoints !== null) return;

    const rect = canvas.getBoundingClientRect();
    const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
    const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    const idx = hitTest(x,y);
    if (idx === -1) return;

    const task = currentTask;
    const selected = task.selected;

    if (selected.has(idx)){
      selected.delete(idx);
      task.selectionOrder = task.selectionOrder.filter(i => i !== idx);
      draw();
      return;
    }

    selected.add(idx);
    task.selectionOrder.push(idx);
    draw();

    if (task.selectionOrder.length === task.points.length){
      if (isPerfectSequence(task)){
        completeCurrentTask();
      } else {
        task.errors += 1;
        resetAttempt(task);
      }
    }
  }

  canvas.addEventListener("pointerdown", handlePointerDown);
  canvas.addEventListener("touchstart", handlePointerDown, {passive:true});

  // ======================= Log tasks =======================
  function sendTaskToLogForm(row){
    const params = new URLSearchParams();
    params.set(LOG_ENTRY_PID,       row.pid);
    params.set(LOG_ENTRY_TASK,      String(row.task));
    params.set(LOG_ENTRY_N_POINTS,  String(row.n_points));
    params.set(LOG_ENTRY_ERRORS,    String(row.errors));
    params.set(LOG_ENTRY_DURATION,  String(row.duration_ms));
    params.set(LOG_ENTRY_COMPLETED, String(row.completed));
    params.set(LOG_ENTRY_TIMESTAMP, row.ts);
    const url = LOG_FORM_BASE + params.toString();
    if (navigator.sendBeacon) navigator.sendBeacon(url);
    else fetch(url, { method:"GET", mode:"no-cors" }).catch(()=>{});
  }

  function logTask(completed){
    if (!currentTask) return;
    const dur = Math.round(now() - currentTask.startTime);
    const pid = (pidInput.value || "").trim();
    const row = {
      pid,
      task: currentTask.index,
      n_points: currentTask.points.length,
      errors: currentTask.errors,
      duration_ms: dur,
      completed: completed ? 1 : 0,
      ts: new Date().toISOString()
    };
    tasks.push(row);
    sendTaskToLogForm(row);
  }

  function completeCurrentTask(){
    logTask(true);
    const nextN = currentTask.points.length + CONFIG.incrementBy;
    pendingNextTaskPoints = nextN;
    currentTask = null;
    draw();

    overlayTitle.textContent = "×¡×™×™××ª ××©×™××”";
    overlayText.textContent = "×œ×—×¥/×™ ×¢×œ \"××©×™××” ×”×‘××”\" ×›×“×™ ×œ×”××©×™×š.";
    overlayContinue.textContent = "××©×™××” ×”×‘××”";
    overlay.style.display = "grid";

    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      if (running && pendingNextTaskPoints !== null){
        openNewTask(pendingNextTaskPoints);
      }
    };
  }

  // ======================= Session =======================
  function tick(){
    if (!running) return;
    const elapsedSec = (now() - sessionStart) / 1000;
    if (elapsedSec >= CONFIG.sessionMinutes * 60){
      endSession(true);
    }
  }

  function buildCsv(){
    if (!tasks.length) return "";
    const head = ["pid","task","n_points","errors","duration_ms","completed","ts"];
    const rows = tasks.map(t =>
      [t.pid, t.task, t.n_points, t.errors, t.duration_ms, t.completed, t.ts].join(",")
    );
    return head.join(",") + "\n" + rows.join("\n");
  }

  function buildFormSummary(){
    const completedTasks = tasks.filter(t => t.completed === 1);
    const totalTasksCompleted = completedTasks.length;
    let pointsPerTask = "", errorsPerTask = "", durPerTask = "";
    if (completedTasks.length > 0){
      pointsPerTask = completedTasks.map(t => t.n_points).join(",");
      errorsPerTask = completedTasks.map(t => t.errors).join(",");
      durPerTask = completedTasks.map(t => t.duration_ms).join(",");
    }
    return {
      totalTasksCompleted,
      pointsPerTask,
      errorsPerTask,
      durPerTask,
      experimentTime: experimentStartIso || ""
    };
  }

  function redirectToForm(){
    const pid = (pidInput.value || "").trim();
    const s = buildFormSummary();
    const params = new URLSearchParams();
    params.set(ENTRY_PID, pid || "");
    params.set(ENTRY_TOTAL_TASKS, String(s.totalTasksCompleted));
    params.set(ENTRY_POINTS_PER_TASK, s.pointsPerTask);
    params.set(ENTRY_ERRORS_PER_TASK, s.errorsPerTask);
    params.set(ENTRY_DUR_PER_TASK, s.durPerTask);
    params.set(ENTRY_EXPERIMENT_TIME, s.experimentTime);
    const target = FORM_BASE_URL + params.toString();
    window.location.href = target;
  }

  function endSession(autoEnded){
    if (sessionEnded){
      redirectToForm();
      return;
    }
    sessionEnded = true;
    running = false;
    if (tickId) clearInterval(tickId);
    startBtn.disabled = false;
    endBtn.disabled = true;

    if (currentTask) logTask(false);

    const csv = buildCsv();
    if (csv) sendCsvToDrive(csv, "connect_the_dots_tasks");

    const eyeCsv = buildEyeCsv();
    if (eyeCsv) sendCsvToDrive(eyeCsv, "webgazer_eye_summary");

    const eyeTimelineCsv = buildEyeTimelineCsv();
    if (eyeTimelineCsv) sendCsvToDrive(eyeTimelineCsv, "webgazer_eye_timeline");

    const layoutCsv = buildPointsLayoutCsv();
    if (layoutCsv) sendCsvToDrive(layoutCsv, "points_layout");

    if (window.webgazer){
      try { webgazer.end(); } catch(e){}
    }

    overlayTitle.textContent = autoEnded ? "×”××©×™××” ×”×¡×ª×™×™××”" : "×”××©×™××” ×”×•×¤×¡×§×”";
    overlayText.textContent = "×ª×•×“×” ×¢×œ ×‘×™×¦×•×¢ ×”××©×™××”. ×›×¢×ª × ×¢×‘×•×¨ ×œ×©××œ×•×Ÿ ×§×¦×¨ × ×•×¡×£.";
    overlayContinue.textContent = "×”××©×š ×œ×©××œ×•×Ÿ";
    overlay.style.display = "grid";
    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      redirectToForm();
    };
  }

  function startSession(){
    const pid = (pidInput.value || "").trim();
    if (!pid){
      alert("× × ×œ××œ× ××–×”×” × ×‘×“×§ ×œ×¤× ×™ ×ª×—×™×œ×ª ×”××©×™××”.");
      return;
    }
    running = true;
    sessionEnded = false;
    sessionStart = now();
    experimentStartIso = new Date().toISOString();
    tasks = [];
    taskCounter = 0;
    currentTask = null;
    pendingNextTaskPoints = null;

    overlay.style.display = "none";
    startBtn.disabled = true;
    endBtn.disabled = false;

    resetGazeStats();
    openNewTask(CONFIG.initialPoints);

    if (tickId) clearInterval(tickId);
    tickId = setInterval(tick, 500);
  }

  // ======================= Init =======================
  function getPidFromUrl(){
    const params = new URLSearchParams(window.location.search);
    return params.get("pid") || "";
  }

  const urlPid = getPidFromUrl();
  if (urlPid){
    pidInput.value = urlPid;
    pidInput.readOnly = true;
  }

  flipXBtn.addEventListener("click", () => {
    FLIP_X = !FLIP_X;
    flipXBtn.textContent = `Flip X: ${FLIP_X ? "ON" : "OFF"}`;
    resetSmoothing();
    requestDraw();
  });

  flipYBtn.addEventListener("click", () => {
    FLIP_Y = !FLIP_Y;
    flipYBtn.textContent = `Flip Y: ${FLIP_Y ? "ON" : "OFF"}`;
    resetSmoothing();
    requestDraw();
  });

  swapBtn.addEventListener("click", () => {
    SWAP_XY = !SWAP_XY;
    swapBtn.textContent = `Swap Xâ†”Y: ${SWAP_XY ? "ON" : "OFF"}`;
    resetSmoothing();
    requestDraw();
  });

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  window.addEventListener("resize", resizeCanvas);

  startBtn.addEventListener("click", () => {
    if (!isCalibrated){
      showCalibrationIntro();
      return;
    }
    startSession();
  });

  endBtn.addEventListener("click", () => endSession(false));

  resizeCanvas();
  showCalibrationIntro();
})();
</script>
</body>
</html>
 â€“ × ×™×¡×•×™ ×§×©×‘ + ××¢×§×‘ ×¢×™× ×™×™×</title>
  <style>
    :root{
      --bg:#020617;
      --panel:#0b1120;
      --ink:#e5e7eb;
      --muted:#94a3b8;
      --stroke:#64748b;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      display:grid;
      grid-template-rows:auto 1fr auto;
    }
    header,footer{
      background:var(--panel);
      padding:10px 16px;
      border-bottom:1px solid #111827;
    }
    footer{
      border-top:1px solid #111827;
      border-bottom:none;
      font-size:0.8rem;
      color:var(--muted);
      text-align:center;
    }
    .top{
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:center;
    }
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      justify-content:center;
      align-items:center;
    }
    label{font-size:0.9rem;color:var(--muted);}
    input{
      background:#020617;
      border:1px solid #334155;
      color:var(--ink);
      padding:4px 8px;
      border-radius:8px;
      min-width:140px;
    }
    input[readonly]{opacity:0.8;}
    button{
      border-radius:999px;
      border:1px solid #334155;
      background:#111827;
      color:var(--ink);
      padding:6px 14px;
      cursor:pointer;
      font-size:0.9rem;
      white-space:nowrap;
    }
    button:disabled{ opacity:0.4; cursor:not-allowed; }
    button:hover:not(:disabled){ border-color:#60a5fa; }

    #stageWrap{
      padding:10px 16px 16px;
      position:relative;
    }
    #stage{
      width:100%;
      height:70vh;
      display:block;
      background:#020617;
      border-radius:18px;
      border:1px solid #1f2937;
      touch-action:none;
    }

    #overlay{
      position:absolute;
      inset:10px 16px 16px;
      display:none;
      place-items:center;
      background:rgba(15,23,42,0.82);
      border-radius:18px;
      z-index:10;
    }
    #overlay .box{
      background:#020617;
      border-radius:16px;
      border:1px solid #1f2937;
      padding:20px 24px;
      max-width:560px;
      text-align:center;
    }
    #overlay h2{ margin:0 0 8px; }
    .muted{ color:var(--muted); }
  </style>

  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
</head>
<body>
  <header>
    <div class="top">
      <div class="muted">
        ×”××©×™××” ×ª×™××©×š ×¢×“ <b>10 ×“×§×•×ª</b> ××• ×¢×“ ×œ×—×™×¦×” ×¢×œ "×¡×™×•× ××•×§×“×".
      </div>

      <div class="controls">
        <label for="pid">××–×”×” × ×‘×“×§:</label>
        <input id="pid" type="text" placeholder="×œ×“×•×’××” ABC123" />

        <button id="startBtn" disabled>×”×ª×—×œ ××©×™××”</button>
        <button id="endBtn" disabled>×¡×™×•× ××•×§×“×</button>

        <button id="flipBtn" type="button" disabled>×”×™×¤×•×š ×™××™×Ÿ/×©×××œ: OFF</button>
      </div>
    </div>
  </header>

  <div id="stageWrap">
    <canvas id="stage"></canvas>

    <div id="overlay">
      <div class="box">
        <h2 id="overlayTitle">×”×•×“×¢×”</h2>
        <p id="overlayText" class="muted"></p>
        <button id="overlayContinue">×”××©×š</button>
      </div>
    </div>
  </div>

  <footer>
    ×™×© ×œ×œ×—×•×¥ ×¢×œ ×”××¡×¤×¨×™× ×œ×¤×™ ×¡×“×¨ ×¢×•×œ×”. × ×™×ª×Ÿ ×œ×”×¡×™×¨ ×‘×—×™×¨×” ×¢×œ ×™×“×™ ×œ×—×™×¦×” ×—×•×–×¨×ª ×¢×œ ××•×ª×• ××¡×¤×¨.
  </footer>

<script>
(() => {
  // ======================= ×”×’×“×¨×•×ª ×›×œ×œ×™×•×ª =======================
  const CONFIG = {
    sessionMinutes: 10,
    initialPoints: 16,
    incrementBy: 0,
    minDistance: 30,
    lineAvoidDistance: 16
  };

  const FRAME_MARGIN_X_RATIO = 0.06;
  const FRAME_MARGIN_Y_RATIO = 0.10;
  const POINT_INNER_PADDING = 40;

  // ======================= ×™×¦×™×‘×•×ª/×¨×’×™×©×•×ª =======================
  const OFF_MIN_MS = 900;

  const DIR_WINDOW_MS = 450;
  const DIR_MIN_VOTES = 8;
  const DIR_DEADZONE_RATIO = 0.28;

  // ğŸ”¥ ×©×™× ×•×™: smoothing ×™×•×ª×¨ ××”×™×¨ (×¤×—×•×ª lag)
  const SMOOTH_ALPHA = 0.35;

  // ğŸ”¥ ×©×™× ×•×™: ×‘××§×•× "×”×§×¤××”" ×›×©×§×•×¤×¥ - ×¢×•×©×™× step ×œ×›×™×•×•×Ÿ ×”×™×¢×“
  const MAX_STEP_PX = 120;

  // --- × ×§×•×“×ª ××¨×›×– ---
  const CENTER_HOLD_MS = 5000;
  const CENTER_MIN_SAMPLES = 15;  // ×§×¦×ª ×™×•×ª×¨ ×›×“×™ ×©-offset ×™×¦× ×™×¦×™×‘

  const DRAW_GAZE_DOT = true;

  // ======================= ×©×œ×™×—×” ×œÖ¾Drive =======================
  const SCRIPT_URL =
    "https://script.google.com/macros/s/AKfycbzVinB7VZA9P3mkKYpfYuykv6JXF62w70s7I98iOqU2YhRyigD0lcBndONHsx5rdhRnRA/exec";

  function sendCsvToDrive(csvContent, label) {
    if (!csvContent) return;
    const rawPid = (pidInput.value || "").trim();
    const safePid = rawPid ? rawPid.replace(/[^a-zA-Z0-9_-]/g, "") : "PID";
    const ts = new Date().toISOString().replace(/[:.]/g, "");
    const filename = `${safePid}_${label}_${ts}.csv`;
    const payload = { filename, mimeType: "text/csv", content: csvContent };

    fetch(SCRIPT_URL, {
      method: "POST",
      mode: "no-cors",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    }).catch(err => console.error("Failed to send CSV to Drive:", err));
  }

  // ======================= ×˜×¤×¡×™× =======================
  const FORM_ID = "1FAIpQLSdTCgLVjt4LXsNAkXP1H8jxIC5MPsdv1sD93v5lmglckCAzrA";
  const ENTRY_PID             = "entry.404955311";
  const ENTRY_TOTAL_TASKS     = "entry.1331557537";
  const ENTRY_POINTS_PER_TASK = "entry.742152065";
  const ENTRY_ERRORS_PER_TASK = "entry.1634677467";
  const ENTRY_DUR_PER_TASK    = "entry.529234118";
  const ENTRY_EXPERIMENT_TIME = "entry.883845532";
  const FORM_BASE_URL =
    "https://docs.google.com/forms/d/e/" + FORM_ID + "/viewform?usp=pp_url&";

  const LOG_FORM_ID = "1FAIpQLSdrl006D8HAWo0YfsdWUMppGEewGOp8Snm3ANot8OxzSBkusA";
  const LOG_FORM_BASE =
    "https://docs.google.com/forms/d/e/" + LOG_FORM_ID + "/formResponse?";
  const LOG_ENTRY_PID        = "entry.152946855";
  const LOG_ENTRY_TASK       = "entry.781109584";
  const LOG_ENTRY_N_POINTS   = "entry.347168050";
  const LOG_ENTRY_ERRORS     = "entry.1932703164";
  const LOG_ENTRY_DURATION   = "entry.1227866932";
  const LOG_ENTRY_COMPLETED  = "entry.1100470565";
  const LOG_ENTRY_TIMESTAMP  = "entry.1243807469";

  // ======================= DOM =======================
  const canvas = document.getElementById("stage");
  const ctx = canvas.getContext("2d");

  const pidInput = document.getElementById("pid");
  const startBtn = document.getElementById("startBtn");
  const endBtn = document.getElementById("endBtn");
  const flipBtn = document.getElementById("flipBtn");

  const overlay = document.getElementById("overlay");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlayText = document.getElementById("overlayText");
  const overlayContinue = document.getElementById("overlayContinue");

  // ======================= STATE =======================
  let running = false;
  let sessionStart = null;
  let experimentStartIso = null;
  let tickId = null;
  let tasks = [];
  let taskCounter = 0;
  let currentTask = null;
  let pendingNextTaskPoints = null;
  let sessionEnded = false;

  let isCalibrated = false;
  const CALIB_POINTS_TOTAL = 17;
  let calibrationActive = false;
  let calibrationPoints = [];
  let calibrationIndex = 0;

  let centerHoldActive = false;
  let centerHoldStart = null;
  let centerSamples = [];

  const taskLayouts = [];

  // ======================= ×ª×™×§×•× ×™ WebGazer =======================
  let FLIP_X = false;

  const gazeFix = {
    offsetX: 0,
    offsetY: 0,
    hasOffset: false,
    smoothX: null,
    smoothY: null
  };

  const dbg = {
    x: null, y: null,
    zone: "O",
    dir: "",
    lastZone: "O"
  };

  function getScreenSize(){ return { w: window.innerWidth, h: window.innerHeight }; }

  function resetSmoothing(){
    gazeFix.smoothX = null;
    gazeFix.smoothY = null;
  }

  // ğŸ”¥ ×©×™× ×•×™: applyFixes ××—×–×™×¨ ×’× "rawFixed" (×œ×›×™×•×œ ××¨×›×– × ×§×™)
  function applyFixes(rawX, rawY, mode){
    if (rawX == null || rawY == null) return { x:null, y:null, rawX:null, rawY:null };

    // ×©×œ×‘ 1: flip ××•×¤×¦×™×•× ×œ×™
    let x = rawX, y = rawY;
    if (FLIP_X){
      const { w } = getScreenSize();
      x = w - x;
    }

    // ×©×œ×‘ 2: offset (×× ×§×™×™×)
    if (gazeFix.hasOffset){
      x += gazeFix.offsetX;
      y += gazeFix.offsetY;
    }

    // ×©××™×¨×” ×©×œ "fixed but not smoothed"
    const rawFixedX = x;
    const rawFixedY = y;

    // ××¦×‘ ×›×™×•×œ ××¨×›×–: ×‘×œ×™ smoothing ×•×‘×œ×™ step-limit
    if (mode === "calib"){
      return { x: rawFixedX, y: rawFixedY, rawX: rawFixedX, rawY: rawFixedY };
    }

    // ×©×œ×‘ 3: step-limit (×œ× ×œ×”×§×¤×™×!)
    if (gazeFix.smoothX != null && gazeFix.smoothY != null){
      const dx = rawFixedX - gazeFix.smoothX;
      const dy = rawFixedY - gazeFix.smoothY;
      const d = Math.hypot(dx, dy);
      if (d > MAX_STEP_PX){
        x = gazeFix.smoothX + (dx / d) * MAX_STEP_PX;
        y = gazeFix.smoothY + (dy / d) * MAX_STEP_PX;
      } else {
        x = rawFixedX;
        y = rawFixedY;
      }
    }

    // ×©×œ×‘ 4: smoothing ××”×™×¨ ×™×•×ª×¨
    if (gazeFix.smoothX == null){
      gazeFix.smoothX = x;
      gazeFix.smoothY = y;
    } else {
      gazeFix.smoothX = gazeFix.smoothX + SMOOTH_ALPHA * (x - gazeFix.smoothX);
      gazeFix.smoothY = gazeFix.smoothY + SMOOTH_ALPHA * (y - gazeFix.smoothY);
    }

    return { x: gazeFix.smoothX, y: gazeFix.smoothY, rawX: rawFixedX, rawY: rawFixedY };
  }

  function getZoneRects(){
    const rect = canvas.getBoundingClientRect();
    const marginX = Math.max(rect.width  * FRAME_MARGIN_X_RATIO, 40);
    const marginY = Math.max(rect.height * FRAME_MARGIN_Y_RATIO, 40);
    const innerRect = {
      left:   rect.left + marginX,
      right:  rect.right - marginX,
      top:    rect.top  + marginY,
      bottom: rect.bottom - marginY
    };
    return { canvasRect: rect, innerRect, marginX, marginY };
  }

  function classifyZone(hadRaw, x, y){
    if (!hadRaw || x == null || y == null) return "O";

    const { canvasRect, innerRect } = getZoneRects();
    const inCanvas =
      x >= canvasRect.left && x <= canvasRect.right &&
      y >= canvasRect.top  && y <= canvasRect.bottom;
    if (!inCanvas) return "O";

    const inTask =
      x >= innerRect.left && x <= innerRect.right &&
      y >= innerRect.top  && y <= innerRect.bottom;
    if (inTask) return "T";

    const cx = (innerRect.left + innerRect.right) / 2;
    const cy = (innerRect.top  + innerRect.bottom) / 2;

    const dx = x - cx;
    const dy = y - cy;

    const deadX = (innerRect.right - innerRect.left) * DIR_DEADZONE_RATIO;
    const deadY = (innerRect.bottom - innerRect.top) * DIR_DEADZONE_RATIO;

    if (Math.abs(dx) < deadX && Math.abs(dy) < deadY) return "O";

    if (Math.abs(dx) >= Math.abs(dy)) return dx >= 0 ? "R" : "L";
    return dy >= 0 ? "D" : "U";
  }

  // ======================= ×¡×˜×˜×™×¡×˜×™×§×•×ª/×˜×™×™××œ×™×™×Ÿ =======================
  const gazeStats = {
    hasStarted: false,
    lastTime: null,
    lastZone: "O",
    totalOnMs: 0,
    totalOffMs: 0,
    totalSamples: 0,
    validSamples: 0,
    invalidSamples: 0,
    offEvents: 0,
    offLeftEvents: 0,
    offRightEvents: 0,
    offUpEvents: 0,
    offDownEvents: 0,
    timeTaskMs: 0,
    timeDeviationMs: 0
  };

  const offState = {
    candidate: false,
    candidateStart: null,
    inOff: false,
    dir: "",
    votes: { L:0, R:0, U:0, D:0 },
    votesStart: null
  };

  const gazeTimeline = [];

  function resetGazeStats(){
    Object.assign(gazeStats,{
      hasStarted:false,lastTime:null,lastZone:"O",
      totalOnMs:0,totalOffMs:0,totalSamples:0,validSamples:0,invalidSamples:0,
      offEvents:0,offLeftEvents:0,offRightEvents:0,offUpEvents:0,offDownEvents:0,
      timeTaskMs:0,timeDeviationMs:0
    });
    offState.candidate=false; offState.candidateStart=null;
    offState.inOff=false; offState.dir="";
    offState.votes={L:0,R:0,U:0,D:0}; offState.votesStart=null;
    gazeTimeline.length=0;
    resetSmoothing();
  }

  // ======================= ×¦×™×•×¨ =======================
  function drawGazeDotAndStatus(){
    if (!DRAW_GAZE_DOT) return;

    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const { marginX, marginY } = getZoneRects();

    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.lineWidth = 1.2;
    ctx.strokeRect(marginX, marginY, w - 2*marginX, h - 2*marginY);

    if (dbg.x != null && dbg.y != null){
      const rect = canvas.getBoundingClientRect();
      const gx = dbg.x - rect.left;
      const gy = dbg.y - rect.top;
      ctx.fillStyle = "rgba(239,68,68,0.95)";
      ctx.beginPath();
      ctx.arc(gx, gy, 6, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "12px system-ui, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const offTxt = gazeFix.hasOffset ? `offset=(${Math.round(gazeFix.offsetX)},${Math.round(gazeFix.offsetY)})` : "offset=none";
    ctx.fillText(`zone=${dbg.zone} dir=${offState.dir||"-"} flipX=${FLIP_X?"ON":"OFF"} ${offTxt}`, 12, 12);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

    if (calibrationActive && calibrationPoints.length){
      const p = calibrationPoints[calibrationIndex] || calibrationPoints[calibrationPoints.length-1];
      ctx.fillStyle = "#ef4444";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "14px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(`× ×§×•×“×” ${calibrationIndex+1} ××ª×•×š ${calibrationPoints.length} â€“ ×œ×—×¥ ×¢×œ ×”× ×§×•×“×” ×”××“×•××”`, p.x, p.y + 18);

      drawGazeDotAndStatus();
      return;
    }

    if (centerHoldActive){
      const { marginX, marginY } = getZoneRects();
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      const cx = marginX + (w - 2*marginX)/2;
      const cy = marginY + (h - 2*marginY)/2;

      ctx.fillStyle = "#ef4444";
      ctx.beginPath();
      ctx.arc(cx, cy, 14, 0, Math.PI*2);
      ctx.fill();

      const elapsed = performance.now() - centerHoldStart;
      const leftMs = Math.max(0, CENTER_HOLD_MS - elapsed);
      const leftSec = Math.ceil(leftMs/1000);

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "14px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(`× × ×œ×”×ª××™×“ ×‘××‘×˜ ×¢×œ ×”× ×§×•×“×” ×‘××¨×›×– (${leftSec})`, cx, cy + 20);

      drawGazeDotAndStatus();
      return;
    }

    if (!currentTask){
      drawGazeDotAndStatus();
      return;
    }

    const pts = currentTask.points;
    const order = currentTask.selectionOrder;

    if (order.length > 1){
      ctx.strokeStyle = "#e5e7eb";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const first = pts[order[0]];
      ctx.moveTo(first.x, first.y);
      for (let i=1;i<order.length;i++){
        const p = pts[order[i]];
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "14px system-ui, Arial";

    pts.forEach((p, idx) => {
      const isSelected = currentTask.selected.has(idx);
      const radius = 13;
      if (isSelected){
        ctx.fillStyle = "#e5e7eb";
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#020617";
        ctx.fillText(String(idx+1), p.x, p.y);
      } else {
        ctx.fillStyle = "#020617";
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "#64748b";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.fillStyle = "#e5e7eb";
        ctx.fillText(String(idx+1), p.x, p.y);
      }
    });

    drawGazeDotAndStatus();
  }

  let drawQueued=false;
  function requestDraw(){
    if(drawQueued) return;
    drawQueued=true;
    requestAnimationFrame(()=>{ drawQueued=false; draw(); });
  }

  // ======================= WebGazer listener =======================
  function handleGaze(data, elapsedTime){
    if (sessionEnded) return;

    const hadRaw = !!data;
    const rawX = hadRaw ? data.x : null;
    const rawY = hadRaw ? data.y : null;

    // ×‘×–××Ÿ centerHold: ××©×ª××©×™× ×‘××¦×‘ calib (×‘×œ×™ smoothing/step-limit)
    const mode = centerHoldActive ? "calib" : "run";
    const fixed = hadRaw ? applyFixes(rawX, rawY, mode) : {x:null,y:null,rawX:null,rawY:null};

    dbg.x = fixed.x;
    dbg.y = fixed.y;

    // ××™×¡×•×£ ×“×’×™××•×ª ×œ-offset: × ×™×§×— ×“×•×•×§× rawFixed (×œ×¤× ×™ smoothing) ×‘×©×‘×™×œ ×“×™×•×§
    if (centerHoldActive && hadRaw && fixed.rawX != null && fixed.rawY != null){
      centerSamples.push({x: fixed.rawX, y: fixed.rawY});
    }

    // ×× ×œ× ×¨×¦×™× ×¢×“×™×™×Ÿ â€” ×¨×§ ×¦×™×•×¨
    if (!running || !currentTask){
      dbg.zone = classifyZone(hadRaw, fixed.x, fixed.y);
      requestDraw();
      return;
    }

    const t = elapsedTime;
    const zoneNow = classifyZone(hadRaw, fixed.x, fixed.y);
    dbg.zone = zoneNow;

    const onFlag = (zoneNow === "T") ? 1 : 0;

    if (!gazeStats.hasStarted){
      gazeStats.hasStarted=true;
      gazeStats.lastTime=t;
      gazeStats.lastZone=zoneNow;
      gazeStats.totalSamples=1;
      if (hadRaw) gazeStats.validSamples=1; else gazeStats.invalidSamples=1;
    } else {
      const dt = t - (gazeStats.lastTime || t);
      gazeStats.lastTime = t;

      if (gazeStats.lastZone === "T"){
        gazeStats.totalOnMs += dt;
        gazeStats.timeTaskMs += dt;
      } else {
        gazeStats.totalOffMs += dt;
        gazeStats.timeDeviationMs += dt;
      }

      gazeStats.totalSamples++;
      if (hadRaw) gazeStats.validSamples++;
      else gazeStats.invalidSamples++;
    }

    // OFF logic
    if (onFlag === 1){
      if (offState.candidate || offState.inOff || offState.votesStart != null){
        offState.candidate=false; offState.candidateStart=null;
        offState.inOff=false; offState.dir="";
        offState.votes={L:0,R:0,U:0,D:0}; offState.votesStart=null;
      }
    } else {
      if (gazeStats.lastZone === "T" && !offState.candidate){
        offState.candidate=true;
        offState.candidateStart=t;
        offState.inOff=false;
        offState.dir="";
        offState.votes={L:0,R:0,U:0,D:0};
        offState.votesStart=t;
      }

      if (zoneNow === "L") offState.votes.L++;
      else if (zoneNow === "R") offState.votes.R++;
      else if (zoneNow === "U") offState.votes.U++;
      else if (zoneNow === "D") offState.votes.D++;

      if (offState.votesStart != null && (t - offState.votesStart) >= DIR_WINDOW_MS){
        const arr = [
          ["L", offState.votes.L],
          ["R", offState.votes.R],
          ["U", offState.votes.U],
          ["D", offState.votes.D],
        ].sort((a,b)=>b[1]-a[1]);

        const [bestDir, bestVotes] = arr[0];
        if (bestVotes >= DIR_MIN_VOTES) offState.dir = bestDir;

        offState.votes={L:0,R:0,U:0,D:0};
        offState.votesStart=t;
      }

      if (offState.candidate && !offState.inOff &&
          offState.candidateStart != null &&
          (t - offState.candidateStart) >= OFF_MIN_MS){

        offState.inOff=true;
        if (offState.dir){
          gazeStats.offEvents++;
          if (offState.dir==="L") gazeStats.offLeftEvents++;
          else if (offState.dir==="R") gazeStats.offRightEvents++;
          else if (offState.dir==="U") gazeStats.offUpEvents++;
          else if (offState.dir==="D") gazeStats.offDownEvents++;
        }
      }
    }

    const ms = Math.round(t);
    const taskIndex = currentTask ? currentTask.index : 0;

    let xOut="", yOut="";
    if (hadRaw && fixed.x != null && fixed.y != null){
      xOut = Math.round(fixed.x);
      yOut = Math.round(fixed.y);
    }

    let dirSample = "";
    if (onFlag===0 && offState.dir) dirSample = offState.dir;

    gazeTimeline.push({
      ms,
      task: taskIndex,
      zone: zoneNow,
      x: xOut,
      y: yOut,
      on: onFlag,
      dir: dirSample
    });

    gazeStats.lastZone = zoneNow;
    requestDraw();
  }

  // ======================= CSV builders =======================
  function buildEyeCsv(){
    const pid = (pidInput.value || "").trim();
    if (!gazeStats.hasStarted && gazeStats.totalSamples === 0) return "";
    const head = [
      "pid","total_on_ms","total_off_ms","total_samples","valid_samples","invalid_samples",
      "off_events","off_left_events","off_right_events","off_up_events","off_down_events",
      "time_task_ms","time_deviation_ms"
    ];
    const row = [
      pid,
      Math.round(gazeStats.totalOnMs),
      Math.round(gazeStats.totalOffMs),
      gazeStats.totalSamples,
      gazeStats.validSamples,
      gazeStats.invalidSamples,
      gazeStats.offEvents,
      gazeStats.offLeftEvents,
      gazeStats.offRightEvents,
      gazeStats.offUpEvents,
      gazeStats.offDownEvents,
      Math.round(gazeStats.timeTaskMs),
      Math.round(gazeStats.timeDeviationMs)
    ].join(",");
    return head.join(",") + "\n" + row + "\n";
  }

  function buildEyeTimelineCsv(){
    const pid = (pidInput.value || "").trim();
    if (!gazeTimeline.length) return "";
    const head = ["pid","task_index","ms","zone","x","y","on_screen","off_direction"];
    const rows = gazeTimeline.map(s =>
      [pid, s.task, s.ms, s.zone || "", s.x, s.y, s.on, s.dir].join(",")
    );
    return head.join(",") + "\n" + rows.join("\n");
  }

  function buildPointsLayoutCsv(){
    const pid = (pidInput.value || "").trim();
    if (!taskLayouts.length) return "";
    const head = ["pid","task_index","point_index","number","x_screen","y_screen"];
    const rows = taskLayouts.map(row =>
      [pid,row.task_index,row.point_index,row.number,Math.round(row.x_screen),Math.round(row.y_screen)].join(",")
    );
    return head.join(",") + "\n" + rows.join("\n");
  }

  // ======================= WebGazer + Calibration =======================
  function startWebgazerAndCalibration(){
    if (!window.webgazer){
      alert("×¡×¤×¨×™×™×ª WebGazer ×œ× × ×˜×¢× ×”. × ×™×ª×Ÿ ×œ×”××©×™×š ×¢× ×”××©×™××” ×‘×œ×™ ××¢×§×‘ ×¢×™× ×™×™×.");
      startBtn.disabled = false;
      return;
    }

    window.saveDataAcrossSessions = false;

    try{
      // âœ… ×—×©×•×‘: Kalman ××•×‘× ×”
      if (webgazer.applyKalmanFilter) webgazer.applyKalmanFilter(true);

      // âœ… Regression ×™×¦×™×‘ ×™×—×¡×™×ª
      if (webgazer.setRegression) webgazer.setRegression("ridge");

      webgazer
        .setGazeListener(handleGaze)
        .showVideo(false)
        .showFaceOverlay(false)
        .showPredictionPoints(false)
        .begin();

    } catch(e){
      console.error("WebGazer error:", e);
      alert("×œ× × ×™×ª×Ÿ ×œ×”×¤×¢×™×œ ××ª ××¢×§×‘ ×”×¢×™× ×™×™×. × ×™×ª×Ÿ ×œ×”××©×™×š ×‘××©×™××” ×œ×œ× ×”××¢×¨×›×ª.");
      startBtn.disabled = false;
      return;
    }

    setTimeout(startCalibrationSequence, 900);
  }

  function generateCalibrationPoints(count){
    const rect = canvas.getBoundingClientRect();
    const m = 30;
    const W = Math.max(rect.width - 2*m, 220);
    const H = Math.max(rect.height - 2*m, 220);
    const pattern = [
      [0.10,0.10],[0.50,0.10],[0.90,0.10],
      [0.10,0.50],[0.50,0.50],[0.90,0.50],
      [0.10,0.90],[0.50,0.90],[0.90,0.90],
      [0.05,0.20],[0.95,0.20],[0.05,0.80],[0.95,0.80],
      [0.20,0.05],[0.80,0.05],[0.20,0.95],[0.80,0.95]
    ];
    const needed = Math.min(count, pattern.length);
    const pts = [];
    for (let i=0; i<needed; i++){
      const [nx,ny] = pattern[i];
      pts.push({ x: m + nx*W, y: m + ny*H });
    }
    return pts;
  }

  function startCalibrationSequence(){
    calibrationPoints = generateCalibrationPoints(CALIB_POINTS_TOTAL);
    calibrationIndex = 0;
    calibrationActive = true;
    draw();
  }

  function handleCalibrationClick(ev){
    if (!calibrationActive || !calibrationPoints.length) return;
    const rect = canvas.getBoundingClientRect();
    const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
    const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    const current = calibrationPoints[calibrationIndex];
    if (!current) return;
    const d = Math.hypot(current.x - x, current.y - y);
    if (d > 40) return;

    try{
      if (window.webgazer && webgazer.recordScreenPosition){
        const vx = rect.left + current.x;
        const vy = rect.top  + current.y;
        webgazer.recordScreenPosition(vx, vy, "click");
      }
    } catch(e){}

    calibrationIndex++;
    if (calibrationIndex >= calibrationPoints.length){
      calibrationActive = false;
      startCenterHold();
    } else {
      draw();
    }
  }

  function startCenterHold(){
    centerHoldActive = true;
    centerHoldStart = performance.now();
    centerSamples = [];
    resetSmoothing();

    overlayTitle.textContent = "×©×œ×‘ ××—×¨×•×Ÿ ×‘×›×™×•×œ";
    overlayText.textContent = "×›×¢×ª ×¢×œ×™×š ×œ×”×ª××™×“ ×‘××‘×˜ ×¢×œ ×”× ×§×•×“×” ×‘××¨×›×– ×œ××©×š ××¡×¤×¨ ×©× ×™×•×ª (×‘×œ×™ ×œ×”×–×™×– ××ª ×”×¨××©).";
    overlayContinue.textContent = "×”×ª×—×œ";
    overlay.style.display = "grid";

    overlayContinue.onclick = () => {
      overlay.style.display = "none";

      const step = () => {
        if (!centerHoldActive) return;

        const elapsed = performance.now() - centerHoldStart;
        requestDraw();

        if (elapsed >= CENTER_HOLD_MS){
          finalizeCenterHold();
          return;
        }
        setTimeout(step, 50);
      };

      step();
    };
  }

  // robust median/trim
  function median(arr){
    if (!arr.length) return null;
    const a = [...arr].sort((x,y)=>x-y);
    const m = Math.floor(a.length/2);
    return a.length % 2 ? a[m] : (a[m-1]+a[m])/2;
  }

  function finalizeCenterHold(){
    centerHoldActive = false;

    if (centerSamples.length >= CENTER_MIN_SAMPLES){
      const { innerRect } = getZoneRects();
      const targetCx = (innerRect.left + innerRect.right) / 2;
      const targetCy = (innerRect.top  + innerRect.bottom) / 2;

      // ×—×•×ª×›×™× outliers: × ×©××•×¨ ×¨×§ ×“×’×™××•×ª ×§×¨×•×‘×•×ª ×œ××¨×›×– (×œ×¤×™ ××¨×—×§ ×œ××™×“×™××Ÿ)
      const xs = centerSamples.map(s=>s.x);
      const ys = centerSamples.map(s=>s.y);
      const mx = median(xs);
      const my = median(ys);

      const withDist = centerSamples.map(s => ({...s, d: Math.hypot(s.x-mx, s.y-my)}))
                                    .sort((a,b)=>a.d-b.d);

      const keepN = Math.max(CENTER_MIN_SAMPLES, Math.floor(withDist.length * 0.70)); // ××©××™×¨×™× 70%
      const kept = withDist.slice(0, keepN);

      const avgX = kept.reduce((a,s)=>a+s.x,0) / kept.length;
      const avgY = kept.reduce((a,s)=>a+s.y,0) / kept.length;

      gazeFix.offsetX = (targetCx - avgX);
      gazeFix.offsetY = (targetCy - avgY);
      gazeFix.hasOffset = true;

      resetSmoothing();
    } else {
      console.warn("Center hold: not enough samples", centerSamples.length);
    }

    isCalibrated = true;
    startBtn.disabled = false;
    flipBtn.disabled = false;

    overlayTitle.textContent = "×”××¢×¨×›×ª ××›×•×™×™×œ×ª";
    overlayText.textContent = `×”×›×™×•×œ ×”×•×©×œ× + ×™×™×©×•×¨ ××¨×›×– (samples=${centerSamples.length}).`;
    overlayContinue.textContent = "×”×ª×—×œ ×”××©×™××”";
    overlay.style.display = "grid";
    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      startSession();
    };

    draw();
  }

  function showCalibrationIntro(){
    overlayTitle.textContent = "×›×™×•×œ ××¦×œ××” ×•××¢×¨×›×ª ××¢×§×‘ ×¢×™× ×™×™×";
    overlayText.textContent = "×™×© ×œ××©×¨ ×¤×ª×™×—×ª ××¦×œ××”. ×œ××—×¨ ××›×Ÿ ×™×•×¤×™×¢×• 17 × ×§×•×“×•×ª ××“×•××•×ª â€“ ×™×© ×œ×”×‘×™×˜ ×‘×›×œ × ×§×•×“×” ×•×œ×œ×—×•×¥ ×¢×œ×™×”.";
    overlayContinue.textContent = "×¤×ª×— ××¦×œ××” ×•×›×™×™×œ";
    overlay.style.display = "grid";
    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      startWebgazerAndCalibration();
    };
  }

  // ======================= ××©×™××•×ª =======================
  function now(){ return performance.now(); }

  function randomBetween(min,max){ return min + Math.random() * (max - min); }

  function pointToSegmentDistance(p,a,b){
    const vx=b.x-a.x, vy=b.y-a.y;
    const wx=p.x-a.x, wy=p.y-a.y;
    const c1=vx*wx+vy*wy;
    if(c1<=0) return Math.hypot(p.x-a.x,p.y-a.y);
    const c2=vx*vx+vy*vy;
    if(c2<=c1) return Math.hypot(p.x-b.x,p.y-b.y);
    const tt=c1/c2;
    const projX=a.x+tt*vx, projY=a.y+tt*vy;
    return Math.hypot(p.x-projX,p.y-projY);
  }

  function generatePoints(n){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    const frameMarginX = Math.max(w * FRAME_MARGIN_X_RATIO, 40);
    const frameMarginY = Math.max(h * FRAME_MARGIN_Y_RATIO, 40);

    const left = frameMarginX + POINT_INNER_PADDING;
    const top  = frameMarginY + POINT_INNER_PADDING;
    const W = w - 2 * (frameMarginX + POINT_INNER_PADDING);
    const H = h - 2 * (frameMarginY + POINT_INNER_PADDING);

    const pts = [];
    let attempts = 0;
    const maxAttempts = 4000;

    while (pts.length < n && attempts < maxAttempts){
      attempts++;
      const candidate = { x: randomBetween(left, left + W), y: randomBetween(top, top + H) };

      let ok = true;
      for (const p of pts){
        if (Math.hypot(p.x-candidate.x, p.y-candidate.y) < CONFIG.minDistance){ ok = false; break; }
      }
      if (!ok) continue;

      for (let i = 1; i < pts.length; i++){
        const d = pointToSegmentDistance(candidate, pts[i-1], pts[i]);
        if (d < CONFIG.lineAvoidDistance){ ok = false; break; }
      }
      if (!ok) continue;

      pts.push(candidate);
    }

    while (pts.length < n){
      pts.push({ x: randomBetween(left, left + W), y: randomBetween(top, top + H) });
    }
    return pts;
  }

  function openNewTask(n){
    pendingNextTaskPoints = null;
    const pts = generatePoints(n);

    currentTask = {
      index: ++taskCounter,
      points: pts,
      selected: new Set(),
      selectionOrder: [],
      errors: 0,
      startTime: now()
    };

    try {
      const rect = canvas.getBoundingClientRect();
      const layoutRows = pts.map((p, idx) => ({
        task_index: currentTask.index,
        point_index: idx + 1,
        number: idx + 1,
        x_screen: rect.left + p.x,
        y_screen: rect.top  + p.y
      }));
      taskLayouts.push(...layoutRows);
    } catch (e) {}

    draw();
  }

  function hitTest(x,y){
    if (!currentTask) return -1;
    const pts = currentTask.points;
    for(let i=0;i<pts.length;i++){
      const p = pts[i];
      if (Math.hypot(p.x-x, p.y-y) <= 18) return i;
    }
    return -1;
  }

  function isPerfectSequence(task){
    const order = task.selectionOrder;
    const n = task.points.length;
    if (order.length !== n) return false;
    for (let i=0; i<n; i++){
      if (order[i] !== i) return false;
    }
    return true;
  }

  function resetAttempt(task){
    task.selected.clear();
    task.selectionOrder = [];
    draw();
  }

  function handlePointerDown(ev){
    if (calibrationActive){
      handleCalibrationClick(ev);
      return;
    }
    if (centerHoldActive) return;
    if (!running || !currentTask || pendingNextTaskPoints !== null) return;

    const rect = canvas.getBoundingClientRect();
    const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
    const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    const idx = hitTest(x,y);
    if (idx === -1) return;

    const task = currentTask;
    const selected = task.selected;

    if (selected.has(idx)){
      selected.delete(idx);
      task.selectionOrder = task.selectionOrder.filter(i => i !== idx);
      draw();
      return;
    }

    selected.add(idx);
    task.selectionOrder.push(idx);
    draw();

    if (task.selectionOrder.length === task.points.length){
      if (isPerfectSequence(task)){
        completeCurrentTask();
      } else {
        task.errors += 1;
        resetAttempt(task);
      }
    }
  }

  canvas.addEventListener("pointerdown", handlePointerDown);
  canvas.addEventListener("touchstart", handlePointerDown, {passive:true});

  // ======================= ×œ×•×’ ××©×™××•×ª =======================
  function sendTaskToLogForm(row){
    const params = new URLSearchParams();
    params.set(LOG_ENTRY_PID,       row.pid);
    params.set(LOG_ENTRY_TASK,      String(row.task));
    params.set(LOG_ENTRY_N_POINTS,  String(row.n_points));
    params.set(LOG_ENTRY_ERRORS,    String(row.errors));
    params.set(LOG_ENTRY_DURATION,  String(row.duration_ms));
    params.set(LOG_ENTRY_COMPLETED, String(row.completed));
    params.set(LOG_ENTRY_TIMESTAMP, row.ts);
    const url = LOG_FORM_BASE + params.toString();
    if (navigator.sendBeacon) navigator.sendBeacon(url);
    else fetch(url, { method:"GET", mode:"no-cors" }).catch(()=>{});
  }

  function logTask(completed){
    if (!currentTask) return;
    const dur = Math.round(now() - currentTask.startTime);
    const pid = (pidInput.value || "").trim();
    const row = {
      pid,
      task: currentTask.index,
      n_points: currentTask.points.length,
      errors: currentTask.errors,
      duration_ms: dur,
      completed: completed ? 1 : 0,
      ts: new Date().toISOString()
    };
    tasks.push(row);
    sendTaskToLogForm(row);
  }

  function completeCurrentTask(){
    logTask(true);
    const nextN = currentTask.points.length + CONFIG.incrementBy;
    pendingNextTaskPoints = nextN;
    currentTask = null;
    draw();

    overlayTitle.textContent = "×¡×™×™××ª ××©×™××”";
    overlayText.textContent = "×œ×—×¥/×™ ×¢×œ \"××©×™××” ×”×‘××”\" ×›×“×™ ×œ×”××©×™×š.";
    overlayContinue.textContent = "××©×™××” ×”×‘××”";
    overlay.style.display = "grid";

    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      if (running && pendingNextTaskPoints !== null){
        openNewTask(pendingNextTaskPoints);
      }
    };
  }

  // ======================= Session =======================
  function tick(){
    if (!running) return;
    const elapsedSec = (now() - sessionStart) / 1000;
    if (elapsedSec >= CONFIG.sessionMinutes * 60){
      endSession(true);
    }
  }

  function buildCsv(){
    if (!tasks.length) return "";
    const head = ["pid","task","n_points","errors","duration_ms","completed","ts"];
    const rows = tasks.map(t =>
      [t.pid, t.task, t.n_points, t.errors, t.duration_ms, t.completed, t.ts].join(",")
    );
    return head.join(",") + "\n" + rows.join("\n");
  }

  function buildFormSummary(){
    const completedTasks = tasks.filter(t => t.completed === 1);
    const totalTasksCompleted = completedTasks.length;
    let pointsPerTask = "", errorsPerTask = "", durPerTask = "";
    if (completedTasks.length > 0){
      pointsPerTask = completedTasks.map(t => t.n_points).join(",");
      errorsPerTask = completedTasks.map(t => t.errors).join(",");
      durPerTask = completedTasks.map(t => t.duration_ms).join(",");
    }
    return {
      totalTasksCompleted,
      pointsPerTask,
      errorsPerTask,
      durPerTask,
      experimentTime: experimentStartIso || ""
    };
  }

  function redirectToForm(){
    const pid = (pidInput.value || "").trim();
    const s = buildFormSummary();
    const params = new URLSearchParams();
    params.set(ENTRY_PID, pid || "");
    params.set(ENTRY_TOTAL_TASKS, String(s.totalTasksCompleted));
    params.set(ENTRY_POINTS_PER_TASK, s.pointsPerTask);
    params.set(ENTRY_ERRORS_PER_TASK, s.errorsPerTask);
    params.set(ENTRY_DUR_PER_TASK, s.durPerTask);
    params.set(ENTRY_EXPERIMENT_TIME, s.experimentTime);
    const target = FORM_BASE_URL + params.toString();
    window.location.href = target;
  }

  function endSession(autoEnded){
    if (sessionEnded){
      redirectToForm();
      return;
    }
    sessionEnded = true;
    running = false;
    if (tickId) clearInterval(tickId);
    startBtn.disabled = false;
    endBtn.disabled = true;

    if (currentTask) logTask(false);

    const csv = buildCsv();
    if (csv) sendCsvToDrive(csv, "connect_the_dots_tasks");

    const eyeCsv = buildEyeCsv();
    if (eyeCsv) sendCsvToDrive(eyeCsv, "webgazer_eye_summary");

    const eyeTimelineCsv = buildEyeTimelineCsv();
    if (eyeTimelineCsv) sendCsvToDrive(eyeTimelineCsv, "webgazer_eye_timeline");

    const layoutCsv = buildPointsLayoutCsv();
    if (layoutCsv) sendCsvToDrive(layoutCsv, "points_layout");

    if (window.webgazer){
      try { webgazer.end(); } catch(e){}
    }

    overlayTitle.textContent = autoEnded ? "×”××©×™××” ×”×¡×ª×™×™××”" : "×”××©×™××” ×”×•×¤×¡×§×”";
    overlayText.textContent = "×ª×•×“×” ×¢×œ ×‘×™×¦×•×¢ ×”××©×™××”. ×›×¢×ª × ×¢×‘×•×¨ ×œ×©××œ×•×Ÿ ×§×¦×¨ × ×•×¡×£.";
    overlayContinue.textContent = "×”××©×š ×œ×©××œ×•×Ÿ";
    overlay.style.display = "grid";
    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      redirectToForm();
    };
  }

  function startSession(){
    const pid = (pidInput.value || "").trim();
    if (!pid){
      alert("× × ×œ××œ× ××–×”×” × ×‘×“×§ ×œ×¤× ×™ ×ª×—×™×œ×ª ×”××©×™××”.");
      return;
    }
    running = true;
    sessionEnded = false;
    sessionStart = now();
    experimentStartIso = new Date().toISOString();
    tasks = [];
    taskCounter = 0;
    currentTask = null;
    pendingNextTaskPoints = null;

    overlay.style.display = "none";
    startBtn.disabled = true;
    endBtn.disabled = false;

    resetGazeStats();
    openNewTask(CONFIG.initialPoints);

    if (tickId) clearInterval(tickId);
    tickId = setInterval(tick, 500);
  }

  // ======================= Init =======================
  function getPidFromUrl(){
    const params = new URLSearchParams(window.location.search);
    return params.get("pid") || "";
  }

  const urlPid = getPidFromUrl();
  if (urlPid){
    pidInput.value = urlPid;
    pidInput.readOnly = true;
  }

  flipBtn.addEventListener("click", () => {
    FLIP_X = !FLIP_X;
    flipBtn.textContent = `×”×™×¤×•×š ×™××™×Ÿ/×©×××œ: ${FLIP_X ? "ON" : "OFF"}`;
    resetSmoothing();
    requestDraw();
  });

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  window.addEventListener("resize", resizeCanvas);

  startBtn.addEventListener("click", () => {
    if (!isCalibrated){
      showCalibrationIntro();
      return;
    }
    startSession();
  });

  endBtn.addEventListener("click", () => endSession(false));

  // init
  resizeCanvas();
  showCalibrationIntro();
})();
</script>
</body>
</html>
