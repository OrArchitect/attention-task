<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>משימת חיבור נקודות – ניסוי קשב + מעקב עיניים</title>
  <style>
    :root{
      --bg:#020617;
      --panel:#0b1120;
      --ink:#e5e7eb;
      --muted:#94a3b8;
      --accent:#e5e7eb;
      --stroke:#64748b;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      display:grid;
      grid-template-rows:auto 1fr auto;
    }
    header,footer{
      background:var(--panel);
      padding:10px 16px;
      border-bottom:1px solid #111827;
    }
    footer{
      border-top:1px solid #111827;
      border-bottom:none;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    header h1{
      margin:0;
      font-size:16px;
      font-weight:700;
    }
    .muted{color:var(--muted); font-size:13px;}
    .wrap{
      display:grid;
      grid-template-columns: 340px 1fr;
      gap:14px;
      padding:14px 16px 16px;
      min-height:0;
    }
    .panel{
      background:rgba(255,255,255,0.03);
      border:1px solid #111827;
      border-radius:14px;
      padding:14px;
      min-height:0;
    }
    label{display:block; font-size:13px; color:var(--muted); margin:10px 0 6px;}
    input,select,button{
      font:inherit;
    }
    input,select{
      width:100%;
      padding:10px 12px;
      border-radius:10px;
      border:1px solid #1f2937;
      background:#0b1220;
      color:var(--ink);
      outline:none;
    }
    input:focus,select:focus{border-color:#334155;}
    button{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid #334155;
      background:#0b1220;
      color:var(--ink);
      cursor:pointer;
      font-weight:650;
      width:100%;
      margin-top:10px;
    }
    button:disabled{opacity:0.55; cursor:not-allowed;}
    .row{display:flex; gap:10px; align-items:center;}
    .row > *{flex:1;}
    .tiny{font-size:12px; color:var(--muted); line-height:1.35;}
    canvas{
      width:100%;
      height:100%;
      background:rgba(255,255,255,0.02);
      border:1px solid #111827;
      border-radius:16px;
      display:block;
      touch-action: manipulation;
    }
    .overlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.75);
      display:none;
      place-items:center;
      z-index:1000;
      padding:18px;
    }
    .overlay .card{
      width:min(720px, 94vw);
      background:#0b1220;
      border:1px solid #1f2937;
      border-radius:16px;
      padding:16px 16px 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.35);
    }
    .overlay h2{margin:0 0 8px; font-size:18px;}
    .overlay p{margin:0 0 10px; color:var(--muted); white-space:pre-line;}
    .overlay .actions{display:flex; justify-content:flex-end; gap:10px; margin-top:10px;}
    .overlay .actions button{width:auto; margin-top:0;}
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid #1f2937;
      background:rgba(255,255,255,0.03);
      font-size:12px;
      color:var(--muted);
    }
    .sep{height:1px; background:#111827; margin:12px 0;}
    .kpi{display:flex; gap:8px; flex-wrap:wrap;}
    .kpi .pill b{color:var(--ink);}
  </style>

  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>

  <!-- MediaPipe FaceMesh (Head direction) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

</head>
<body>
  <header>
    <h1>משימת חיבור נקודות – ניסוי קשב + מעקב עיניים</h1>
    <div class="kpi">
      <span class="pill">סטטוס: <b id="miniStatus">ממתין</b></span>
      <span class="pill">PID: <b id="miniPid">—</b></span>
      <span class="pill">משימה: <b id="miniTask">—</b></span>
      <span class="pill">OFF: <b id="miniOff">0</b></span>
    </div>
  </header>

  <div class="wrap">
    <div class="panel">
      <div class="row">
        <div>
          <label for="pidInput">PID (מזהה נבדק)</label>
          <input id="pidInput" placeholder="לדוגמה: O12" />
          <div class="tiny">מומלץ PID באנגלית/מספרים בלבד (לשם קובץ). אפשר גם בעברית.</div>
        </div>
      </div>

      <div class="sep"></div>

      <label for="difficultySel">רמת קושי (נקודות)</label>
      <select id="difficultySel">
        <option value="12">קל – 12 נקודות</option>
        <option value="16" selected>בינוני – 16 נקודות</option>
        <option value="20">קשה – 20 נקודות</option>
      </select>

      <label for="taskCountSel">מספר משימות (סשן)</label>
      <select id="taskCountSel">
        <option value="1">1</option>
        <option value="2" selected>2</option>
        <option value="3">3</option>
      </select>

      <button id="startBtn">התחל כיול</button>
      <button id="beginTaskBtn" disabled>התחל משימה</button>
      <button id="endBtn" disabled>סיים ושמור</button>

      <div class="sep"></div>

      <div class="tiny">
        <b>מה נרשם?</b><br>
        1) נקודת מבט (x,y) כשהעיניים על המסך<br>
        2) OFF Events + כיוון (L/R/U/D) לפי אזורי מסגרת<br>
        3) Head Direction (FaceMesh) + אירועי “Head-away” לפי ספים יחסיים למבט מרכזי<br><br>
        אם Head tracking לא עולה – עדיין אפשר להריץ את המשימה עם WebGazer בלבד.
      </div>
    </div>

    <div class="panel" style="min-height:0;">
      <canvas id="c"></canvas>
    </div>
  </div>

  <footer>
    <div class="muted">טיפ: רצוי מסך מלא, תאורה טובה, ושבתנאי הכיול הראש יציב.</div>
    <div class="muted">© Or Regev – Attention Task</div>
  </footer>

  <div class="overlay" id="overlay">
    <div class="card">
      <h2 id="overlayTitle">כותרת</h2>
      <p id="overlayText">טקסט</p>
      <div class="actions">
        <button id="overlayContinue">המשך</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ======================= הגדרות בסיס =======================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const pidInput = document.getElementById("pidInput");
  const difficultySel = document.getElementById("difficultySel");
  const taskCountSel = document.getElementById("taskCountSel");
  const startBtn = document.getElementById("startBtn");
  const beginTaskBtn = document.getElementById("beginTaskBtn");
  const endBtn = document.getElementById("endBtn");

  const miniStatus = document.getElementById("miniStatus");
  const miniPid = document.getElementById("miniPid");
  const miniTask = document.getElementById("miniTask");
  const miniOff = document.getElementById("miniOff");

  const overlay = document.getElementById("overlay");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlayText = document.getElementById("overlayText");
  const overlayContinue = document.getElementById("overlayContinue");

  const SETTINGS = {
    dotRadius: 16,
    dotTextSize: 14,
    lineWidth: 4.5,
    minDistance: 30,
    lineAvoidDistance: 16
  };

  // מסגרת פנימית (אזור המשימה)
  const FRAME_MARGIN_X_RATIO = 0.06;
  const FRAME_MARGIN_Y_RATIO = 0.10;
  const POINT_INNER_PADDING = 40;

  // OFF "אמיתי" – סף זמן
  const OFF_MIN_MS = 900;

  // Voting לכיוון הבריחה כדי להפחית "רנדומלי"
  const DIR_WINDOW_MS = 350;
  const DIR_MIN_VOTES = 6;
  const DIR_DEADZONE_RATIO = 0.20;

  // סינון לתצוגת הנקודה האדומה בלבד
  const SMOOTH_ALPHA = 0.35;
  const MAX_STEP_PX  = 260;
  const MEDIAN_WIN   = 3;

  // שלב מרכז
  const CENTER_HOLD_MS = 5000;
  const CENTER_MIN_SAMPLES = 12; // פחות מחמיר כדי לא להיתקע
  const CENTER_MAX_STD_PX = 120; // פחות מחמיר
  let centerAttempts = 0;
  const MAX_CENTER_ATTEMPTS = 1; // מקסימום ניסיון "ידני" אחד
  const UNSTABLE_AUTO_MS = 2000; // אם לא יציב – ממשיכים אוטומטית אחרי 2ש'

  // שלב בדיקת X (ימין/שמאל) – עם נקודה ימנית/שמאלית
  const XCHECK_RIGHT_MS = 4000;
  const XCHECK_LEFT_MS  = 4000;
  const XCHECK_MIN_SAMPLES = 12;
  const XCHECK_MIN_DELTA_PX = 30;

  // להשאיר נקודה אדומה
  const DRAW_GAZE_DOT = true;

  // ======================= Head tracking (MediaPipe FaceMesh) =======================
  // Goal: detect head direction (L/R/U/D) even when WebGazer gaze point still appears "on screen".
  // Thresholds are relative to neutral head pose captured during center-hold (5s).
  const HEAD_YAW_THRESHOLD   = 0.18; // smaller => more sensitive
  const HEAD_PITCH_THRESHOLD = 0.16;
  const HEAD_AWAY_MIN_MS     = 450;  // require sustained head-away before counting an event
  const HEAD_SMOOTH_ALPHA    = 0.25;

  const head = {
    ready:false,
    face:false,
    yaw:0, pitch:0,
    yawSm:0, pitchSm:0,
    neutralYaw:0, neutralPitch:0,
    calibrated:false,
    // sustained-away detector
    awayStart:null,
    awayDir:"CENTER",
    awayEvents:0,
    left:0, right:0, up:0, down:0, unknown:0,
    _calSamples:[]
  };

  function ema(prev,next,a){ return prev + a*(next-prev); }
  function lm(landmarks, idx){ const p = landmarks[idx]; return {x:p.x, y:p.y}; }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  // yaw/pitch proxy: nose relative to eyes (normalized by eye distance)
  function computeYawPitch(landmarks){
    const leftEye = lm(landmarks, 33);
    const rightEye = lm(landmarks, 263);
    const nose = lm(landmarks, 1);
    const midEyes = { x:(leftEye.x+rightEye.x)/2, y:(leftEye.y+rightEye.y)/2 };
    const eyeDist = Math.max(1e-6, dist(leftEye, rightEye));
    const yaw = (nose.x - midEyes.x) / eyeDist;   // <0 => head to left, >0 => head to right (relative)
    const pitch = (nose.y - midEyes.y) / eyeDist; // <0 => up, >0 => down
    return {yaw, pitch};
  }

  function classifyHeadDir(yawRel, pitchRel){
    const ay = Math.abs(yawRel);
    const ap = Math.abs(pitchRel);
    const yawOff = ay >= HEAD_YAW_THRESHOLD;
    const pitOff = ap >= HEAD_PITCH_THRESHOLD;
    if (!yawOff && !pitOff) return "CENTER";
    if (ay >= ap) return yawRel < 0 ? "L" : "R";
    return pitchRel < 0 ? "U" : "D";
  }

  function updateHeadAway(t, dir){
    if (dir === "CENTER"){
      head.awayStart = null;
      head.awayDir = "CENTER";
      return {away:0, dir:"CENTER"};
    }
    if (head.awayStart == null){
      head.awayStart = t;
      head.awayDir = dir;
      return {away:0, dir};
    }
    head.awayDir = dir;
    if ((t - head.awayStart) >= HEAD_AWAY_MIN_MS){
      head.awayEvents++;
      if (dir==="L") head.left++;
      else if (dir==="R") head.right++;
      else if (dir==="U") head.up++;
      else if (dir==="D") head.down++;
      else head.unknown++;
      head.awayStart = null;
      head.awayDir = "CENTER";
      return {away:1, dir};
    }
    return {away:0, dir};
  }

  function startHeadNeutralCalibration(){
    head._calSamples = [];
    head.calibrated = false;
  }
  function sampleHeadNeutral(){
    if (!head.ready || !head.face) return;
    head._calSamples.push({yaw: head.yawSm, pitch: head.pitchSm});
  }
  function finalizeHeadNeutral(){
    const s = head._calSamples || [];
    if (!s.length){ head.calibrated = false; return; }
    const my = s.reduce((a,p)=>a+p.yaw,0)/s.length;
    const mp = s.reduce((a,p)=>a+p.pitch,0)/s.length;
    head.neutralYaw = my;
    head.neutralPitch = mp;
    head.calibrated = true;
  }
  function getHeadRel(){
    return {
      yawRel: head.yawSm - head.neutralYaw,
      pitRel: head.pitchSm - head.neutralPitch
    };
  }

  let faceMesh = null;

  // IMPORTANT: use the SAME webcam stream as WebGazer (avoid double camera conflict).
  async function initFaceMesh(){
    if (head.ready) return;
    try{
      if (!window.FaceMesh){ throw new Error("MediaPipe FaceMesh not loaded"); }
      if (!window.webgazer || !webgazer.getVideoElement){
        throw new Error("WebGazer video element not available");
      }
      const sharedVideo = webgazer.getVideoElement();
      if (!sharedVideo){ throw new Error("sharedVideo is null"); }

      faceMesh = new FaceMesh.FaceMesh({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
      });
      faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });

      faceMesh.onResults((results) => {
        const faces = results.multiFaceLandmarks || [];
        if (!faces.length){ head.face = false; return; }
        head.face = true;

        const {yaw, pitch} = computeYawPitch(faces[0]);
        head.yaw = yaw;
        head.pitch = pitch;
        head.yawSm = ema(head.yawSm, yaw, HEAD_SMOOTH_ALPHA);
        head.pitchSm = ema(head.pitchSm, pitch, HEAD_SMOOTH_ALPHA);
      });

      head.ready = true;

      const loop = async () => {
        if (!head.ready) return;
        try{ await faceMesh.send({image: sharedVideo}); }catch(e){}
        requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);

      miniStatus.textContent = "Head tracking פעיל (מצלמה משותפת עם WebGazer)";
    } catch(e){
      head.ready = false;
      miniStatus.textContent = "Head tracking לא הופעל (ממשיך ללא Head)";
      console.error("Head tracking init error:", e);
    }
  }

  // ======================= שליחה ל־Drive =======================
  const SCRIPT_URL =
    "https://script.google.com/macros/s/AKfycbzVinB7VZA9P3mkKYpfYuykv6JXF62w70s7I98iOqU2YhRyigD0lcBndONHsx5rdhRnRA/exec";

  function sendCsvToDrive(csvContent, label) {
    if (!csvContent) return;
    const rawPid = (pidInput.value || "").trim();
    const safePid = rawPid ? rawPid.replace(/[^a-zA-Z0-9_-]/g, "") : "PID";
    const ts = new Date().toISOString().replace(/[:.]/g, "");
    const filename = `${safePid}_${label}_${ts}.csv`;
    const payload = { filename, mimeType: "text/csv", content: csvContent };

    fetch(SCRIPT_URL, {
      method: "POST",
      mode: "no-cors",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    }).catch(()=>{});
  }

  // ======================= Utilities =======================
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", () => { resizeCanvas(); draw(); });

  function meanOf(arr){
    if (!arr || !arr.length) return null;
    return arr.reduce((a,b)=>a+b,0) / arr.length;
  }
  function stdOf(arr){
    if (!arr || arr.length < 2) return 0;
    const m = meanOf(arr);
    const v = arr.reduce((a,b)=>a+(b-m)*(b-m),0)/(arr.length-1);
    return Math.sqrt(v);
  }
  function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

  // ======================= Zones =======================
  function getZoneRects(){
    const rect = canvas.getBoundingClientRect();
    const mx = rect.width  * FRAME_MARGIN_X_RATIO;
    const my = rect.height * FRAME_MARGIN_Y_RATIO;

    const outerRect = { left:0, top:0, right:rect.width, bottom:rect.height };
    const innerRect = {
      left: mx,
      top:  my,
      right: rect.width - mx,
      bottom: rect.height - my
    };
    return { outerRect, innerRect };
  }

  function classifyZone(hasData, x, y){
    if (!hasData || x==null || y==null) return "N";
    const { innerRect } = getZoneRects();
    if (x >= innerRect.left && x <= innerRect.right && y >= innerRect.top && y <= innerRect.bottom){
      return "T"; // task (on)
    }
    // outside inner => determine side
    const cx = (innerRect.left + innerRect.right)/2;
    const cy = (innerRect.top + innerRect.bottom)/2;
    const dx = x - cx;
    const dy = y - cy;
    const deadX = (innerRect.right-innerRect.left)*DIR_DEADZONE_RATIO;
    const deadY = (innerRect.bottom-innerRect.top)*DIR_DEADZONE_RATIO;

    if (Math.abs(dx) > Math.abs(dy)){
      if (dx > deadX) return "R";
      if (dx < -deadX) return "L";
      return "N";
    } else {
      if (dy > deadY) return "D";
      if (dy < -deadY) return "U";
      return "N";
    }
  }

  // ======================= Gaze smoothing & fixes =======================
  const gazeFix = { hasOffset:false, offsetX:0, offsetY:0 };
  let FLIP_X = false;

  const medianBufX = [];
  const medianBufY = [];
  let smoothX = null;
  let smoothY = null;

  function resetSmoothing(){
    medianBufX.length = 0;
    medianBufY.length = 0;
    smoothX = null;
    smoothY = null;
  }

  function medianOf(arr){
    const a = arr.slice().sort((x,y)=>x-y);
    const mid = Math.floor(a.length/2);
    return a.length%2 ? a[mid] : (a[mid-1]+a[mid])/2;
  }

  function applyFixes(rawX, rawY, mode){
    // rawX/rawY are screen coordinates (client)
    let x = rawX, y = rawY;
    if (x==null || y==null) return {x:null,y:null,rawX:null,rawY:null};

    const { innerRect } = getZoneRects();
    // optionally flip x if needed
    if (FLIP_X){
      const rect = canvas.getBoundingClientRect();
      x = rect.left + (rect.width - (x - rect.left));
    }

    // apply offset correction (best-effort)
    if (gazeFix.hasOffset){
      x += gazeFix.offsetX;
      y += gazeFix.offsetY;
    }

    // convert to canvas-local coords for display/logging
    const rect = canvas.getBoundingClientRect();
    const cx = x - rect.left;
    const cy = y - rect.top;

    // smoothing for dot
    medianBufX.push(cx); if (medianBufX.length > MEDIAN_WIN) medianBufX.shift();
    medianBufY.push(cy); if (medianBufY.length > MEDIAN_WIN) medianBufY.shift();
    const mx = medianOf(medianBufX);
    const my = medianOf(medianBufY);

    if (smoothX == null){ smoothX = mx; smoothY = my; }
    const step = Math.hypot(mx - smoothX, my - smoothY);
    if (step > MAX_STEP_PX){
      smoothX = mx; smoothY = my;
    } else {
      smoothX = ema(smoothX, mx, SMOOTH_ALPHA);
      smoothY = ema(smoothY, my, SMOOTH_ALPHA);
    }

    return { x: smoothX, y: smoothY, rawX: x - rect.left, rawY: y - rect.top };
  }

  // ======================= Calibration click points =======================
  const CALIB_POINTS_TOTAL = 16;
  let calibrationPoints = [];
  let calibrationIndex = 0;
  let calibrationActive = false;

  let holdActive = false;
  let holdStart = 0;
  let holdSamples = [];
  let holdWatchdogId = null;

  let xCheckActive = false;
  let xCheckPhase = "right";
  let xCheckStart = 0;
  let xCheckSamplesRight = [];
  let xCheckSamplesLeft  = [];

  let isCalibrated = false;

  // ======================= Task state =======================
  let running = false;
  let sessionEnded = false;

  let tasksTotal = 2;
  let pointsPerTask = 16;

  let currentTask = null;
  let taskIndex = 0;

  const gazeTimeline = [];
  const gazeStats = {
    hasStarted:false,
    lastTime:0,
    lastZone:"N",
    totalOnMs:0,
    totalOffMs:0,
    totalSamples:0,
    validSamples:0,
    invalidSamples:0,
    offEvents:0,
    offLeft:0,
    offRight:0,
    offUp:0,
    offDown:0,
    timeTaskMs:0,
    timeDeviationMs:0,
    // off detector
    offStart:null,
    offDirVotes:[],
    offDirStart:null
  };

  const dbg = { x:null, y:null };

  // ======================= Task generation =======================
  function rand(min,max){ return Math.random()*(max-min)+min; }

  function generatePoints(n){
    const rect = canvas.getBoundingClientRect();
    const { innerRect } = getZoneRects();
    const pts = [];
    let attempts = 0;
    while (pts.length < n && attempts < 4000){
      attempts++;
      const x = rand(innerRect.left + POINT_INNER_PADDING, innerRect.right - POINT_INNER_PADDING);
      const y = rand(innerRect.top  + POINT_INNER_PADDING, innerRect.bottom - POINT_INNER_PADDING);
      const ok = pts.every(p => Math.hypot(p.x-x,p.y-y) >= SETTINGS.minDistance);
      if (ok) pts.push({x,y});
    }
    return pts;
  }

  function makeTask(){
    const pts = generatePoints(pointsPerTask);
    return {
      points: pts,
      current: 0,
      lines: [],
      startedAt: performance.now(),
      finishedAt: null
    };
  }

  // ======================= Drawing =======================
  function drawFrame(){
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width,rect.height);

    const { innerRect } = getZoneRects();

    // outer border (canvas)
    ctx.strokeStyle = "#111827";
    ctx.lineWidth = 1;
    ctx.strokeRect(0.5,0.5,rect.width-1,rect.height-1);

    // inner task frame
    ctx.strokeStyle = "#334155";
    ctx.lineWidth = 2;
    ctx.strokeRect(innerRect.left, innerRect.top, innerRect.right-innerRect.left, innerRect.bottom-innerRect.top);
  }

  function drawCalibration(){
    drawFrame();
    const rect = canvas.getBoundingClientRect();
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillStyle="#e5e7eb";

    if (holdActive){
      const { innerRect } = getZoneRects();
      const cx = (innerRect.left + innerRect.right)/2;
      const cy = (innerRect.top + innerRect.bottom)/2;

      ctx.beginPath();
      ctx.arc(cx, cy, 18, 0, Math.PI*2);
      ctx.fillStyle="#f43f5e";
      ctx.fill();
      ctx.fillStyle="#e5e7eb";
      ctx.font="600 14px system-ui";
      ctx.fillText("•", cx, cy);

      const elapsed = performance.now() - holdStart;
      const left = Math.max(0, (CENTER_HOLD_MS - elapsed)/1000).toFixed(0);
      ctx.fillStyle="#94a3b8";
      ctx.font="600 13px system-ui";
      ctx.fillText(`הבט למרכז ${left}s`, rect.width/2, innerRect.bottom + 20);
      drawGazeDot();
      return;
    }

    if (xCheckActive){
      const { innerRect } = getZoneRects();
      const x = (xCheckPhase === "right") ? (innerRect.right - 30) : (innerRect.left + 30);
      const y = (innerRect.top + innerRect.bottom)/2;
      ctx.beginPath();
      ctx.arc(x, y, 18, 0, Math.PI*2);
      ctx.fillStyle="#f59e0b";
      ctx.fill();
      ctx.fillStyle="#0b1220";
      ctx.font="700 12px system-ui";
      ctx.fillText(xCheckPhase === "right" ? "ימין" : "שמאל", x, y);

      ctx.fillStyle="#94a3b8";
      ctx.font="600 13px system-ui";
      ctx.fillText(`הבט לנקודה (${xCheckPhase==="right"?"ימין":"שמאל"})`, rect.width/2, innerRect.bottom + 20);

      drawGazeDot();
      return;
    }

    if (calibrationActive && calibrationPoints.length){
      const p = calibrationPoints[calibrationIndex];
      ctx.beginPath();
      ctx.arc(p.x, p.y, 18, 0, Math.PI*2);
      ctx.fillStyle="#22c55e";
      ctx.fill();
      ctx.strokeStyle="#bbf7d0";
      ctx.lineWidth=2;
      ctx.stroke();

      ctx.fillStyle="#94a3b8";
      ctx.font="600 13px system-ui";
      ctx.fillText(`קליק על הנקודה (${calibrationIndex+1}/${calibrationPoints.length})`, rect.width/2, rect.height - 24);

      drawGazeDot();
      return;
    }

    // idle
    ctx.fillStyle="#94a3b8";
    ctx.font="600 14px system-ui";
    ctx.fillText("לחץ 'התחל כיול' כדי להתחיל", rect.width/2, rect.height/2);
    drawGazeDot();
  }

  function drawTask(){
    drawFrame();
    if (!currentTask) return;

    // lines
    ctx.strokeStyle="#e5e7eb";
    ctx.lineWidth = SETTINGS.lineWidth;
    ctx.lineCap="round";
    currentTask.lines.forEach(([a,b])=>{
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.lineTo(b.x,b.y);
      ctx.stroke();
    });

    // points
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.font=`700 ${SETTINGS.dotTextSize}px system-ui`;

    currentTask.points.forEach((p,idx)=>{
      const done = idx < currentTask.current;
      ctx.beginPath();
      ctx.arc(p.x,p.y, SETTINGS.dotRadius, 0, Math.PI*2);
      ctx.fillStyle = done ? "rgba(34,197,94,0.9)" : "rgba(148,163,184,0.15)";
      ctx.fill();
      ctx.strokeStyle = "#64748b";
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.fillStyle = "#e5e7eb";
      ctx.fillText(String(idx+1), p.x, p.y);
    });

    drawGazeDot();
  }

  function drawGazeDot(){
    if (!DRAW_GAZE_DOT) return;
    if (dbg.x==null || dbg.y==null) return;
    ctx.beginPath();
    ctx.arc(dbg.x, dbg.y, 7, 0, Math.PI*2);
    ctx.fillStyle = "rgba(239,68,68,0.85)";
    ctx.fill();
  }

  function draw(){
    resizeCanvas();
    if (running) drawTask();
    else drawCalibration();
  }

  // ======================= Calibration flow =======================
  function generateCalibrationPoints(count){
    const rect = canvas.getBoundingClientRect();
    const m = 30;
    const W = Math.max(rect.width - 2*m, 220);
    const H = Math.max(rect.height - 2*m, 220);
    const pattern = [
      [0.10,0.10],[0.50,0.10],[0.90,0.10],
      [0.10,0.50],[0.50,0.50],[0.90,0.50],
      [0.10,0.90],[0.50,0.90],[0.90,0.90],
      [0.05,0.20],[0.95,0.20],[0.05,0.80],[0.95,0.80],
      [0.20,0.05],[0.80,0.05],[0.20,0.95],[0.80,0.95]
    ];
    const needed = Math.min(count, pattern.length);
    const pts = [];
    for (let i=0; i<needed; i++){
      const [nx,ny] = pattern[i];
      pts.push({ x: m + nx*W, y: m + ny*H });
    }
    return pts;
  }

  function startCalibrationSequence(){
    calibrationPoints = generateCalibrationPoints(CALIB_POINTS_TOTAL);
    calibrationIndex = 0;
    calibrationActive = true;
    draw();
  }

  function handleCalibrationClick(ev){
    if (!calibrationActive || !calibrationPoints.length) return;
    const rect = canvas.getBoundingClientRect();
    const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
    const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    const current = calibrationPoints[calibrationIndex];
    if (!current) return;
    const d = Math.hypot(current.x - x, current.y - y);
    if (d > 40) return;

    try{
      if (window.webgazer && webgazer.recordScreenPosition){
        const vx = rect.left + current.x;
        const vy = rect.top  + current.y;
        webgazer.recordScreenPosition(vx, vy, "click");
      }
    }catch(e){}

    calibrationIndex++;
    if (calibrationIndex >= calibrationPoints.length){
      calibrationActive = false;
      startCenterHold();
    }
    draw();
  }

  // ======================= כיול מרכז: תמיד נגמר ולא נתקע =======================
  function startCenterHold(){
    if (holdWatchdogId) clearTimeout(holdWatchdogId);

    holdActive = true;
    holdStart = performance.now();
    holdSamples = [];
    resetSmoothing();
    startHeadNeutralCalibration();
    draw();

    // watchdog: גם אם משהו משתבש – אחרי 7 שניות סוגרים בכוח
    holdWatchdogId = setTimeout(() => {
      if (holdActive){
        holdActive = false;
        finalizeCenterHold(holdSamples, true);
      }
    }, CENTER_HOLD_MS + 2000);

    const loop = () => {
      if (!holdActive) return;
      const elapsed = performance.now() - holdStart;
      sampleHeadNeutral();
      draw();
      if (elapsed >= CENTER_HOLD_MS){
        holdActive = false;
        finalizeCenterHold(holdSamples, false);
        return;
      }
      requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);
  }

  function finalizeCenterHold(collected, forced){
    if (holdWatchdogId) { clearTimeout(holdWatchdogId); holdWatchdogId = null; }

    finalizeHeadNeutral();

    centerAttempts++;

    const xs = collected.map(s=>s.x);
    const ys = collected.map(s=>s.y);
    const avgX = meanOf(xs);
    const avgY = meanOf(ys);
    const sx = stdOf(xs);
    const sy = stdOf(ys);

    const unstable = (
      forced ||
      collected.length < CENTER_MIN_SAMPLES ||
      sx > CENTER_MAX_STD_PX ||
      sy > CENTER_MAX_STD_PX ||
      avgX == null || avgY == null
    );

    // תמיד נגדיר offset Best-Effort (גם אם לא יציב)
    const { innerRect } = getZoneRects();
    const targetCx = (innerRect.left + innerRect.right) / 2;
    const targetCy = (innerRect.top  + innerRect.bottom) / 2;

    gazeFix.offsetX = targetCx - (avgX ?? targetCx);
    gazeFix.offsetY = targetCy - (avgY ?? targetCy);
    gazeFix.hasOffset = true;
    resetSmoothing();

    if (!unstable){
      startXCheck();
      return;
    }

    // אם לא יציב – לכל היותר ניסיון אחד "ידני", אבל גם אז יש AUTO-continue
    if (centerAttempts <= MAX_CENTER_ATTEMPTS){
      overlayTitle.textContent = "המעקב מעט לא יציב";
      overlayText.textContent =
        "ננסה עוד פעם אחת (אם תרצה).\n" +
        "אם לא ילך — נמשיך בכל מקרה תוך 2 שניות.";
      overlayContinue.textContent = "נסה שוב";
      overlay.style.display = "grid";

      const autoGo = setTimeout(() => {
        if (overlay.style.display === "grid"){
          overlay.style.display = "none";
          startXCheck();
        }
      }, UNSTABLE_AUTO_MS);

      overlayContinue.onclick = () => {
        clearTimeout(autoGo);
        overlay.style.display = "none";
        startCenterHold();
      };
      return;
    }

    // כבר ניסינו — ממשיכים
    overlayTitle.textContent = "ממשיכים בכל מקרה";
    overlayText.textContent = "הכיול הושלם בצורה חלקית. נמשיך עם בדיקת ימין/שמאל.";
    overlayContinue.textContent = "המשך";
    overlay.style.display = "grid";
    const autoGo2 = setTimeout(() => {
      if (overlay.style.display === "grid"){
        overlay.style.display = "none";
        startXCheck();
      }
    }, 1200);
    overlayContinue.onclick = () => {
      clearTimeout(autoGo2);
      overlay.style.display = "none";
      startXCheck();
    };
  }

  // ======================= XCheck (ימין ואז שמאל) =======================
  function startXCheck(){
    xCheckActive = true;
    xCheckPhase = "right";
    xCheckStart = performance.now();
    xCheckSamplesRight = [];
    xCheckSamplesLeft  = [];
    resetSmoothing();
    draw();

    const loop = () => {
      if (!xCheckActive) return;

      const nowT = performance.now();
      const elapsed = nowT - xCheckStart;
      const total = (xCheckPhase === "right") ? XCHECK_RIGHT_MS : XCHECK_LEFT_MS;

      draw();

      if (elapsed >= total){
        if (xCheckPhase === "right"){
          xCheckPhase = "left";
          xCheckStart = performance.now();
          requestAnimationFrame(loop);
          return;
        } else {
          xCheckActive = false;
          finalizeXCheck();
          return;
        }
      }
      requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);
  }

  function finalizeXCheck(){
    if (xCheckSamplesRight.length < XCHECK_MIN_SAMPLES || xCheckSamplesLeft.length < XCHECK_MIN_SAMPLES){
      finishCalibration();
      return;
    }
    const rx = meanOf(xCheckSamplesRight.map(s=>s.x));
    const lx = meanOf(xCheckSamplesLeft.map(s=>s.x));
    if (rx == null || lx == null || Math.abs(rx - lx) < XCHECK_MIN_DELTA_PX){
      finishCalibration();
      return;
    }
    if (rx < lx){
      FLIP_X = !FLIP_X;
      resetSmoothing();
    }
    finishCalibration();
  }

  function finishCalibration(){
    isCalibrated = true;
    startBtn.disabled = false;
    beginTaskBtn.disabled = false;

    overlayTitle.textContent = "המערכת מכויילת";
    overlayText.textContent = "הכיול הושלם. לחץ על \"התחל משימה\" כדי להתחיל.";
    overlayContinue.textContent = "סגור";
    overlay.style.display = "grid";
    overlayContinue.onclick = () => overlay.style.display = "none";

    draw();
  }

  // ======================= WebGazer listener =======================
  function handleGaze(data, elapsedTime){
    if (sessionEnded) return;

    const hadRaw = !!data;
    const rawX = hadRaw ? data.x : null;
    const rawY = hadRaw ? data.y : null;

    const mode = (holdActive || xCheckActive) ? "calib" : "run";
    const fixed = hadRaw ? applyFixes(rawX, rawY, mode) : {x:null,y:null,rawX:null,rawY:null};

    dbg.x = fixed.x;
    dbg.y = fixed.y;

    if (holdActive && hadRaw && fixed.rawX != null && fixed.rawY != null){
      holdSamples.push({x: fixed.rawX, y: fixed.rawY});
      return;
    }
    if (xCheckActive && hadRaw && fixed.rawX != null && fixed.rawY != null){
      if (xCheckPhase === "right") xCheckSamplesRight.push({x: fixed.rawX, y: fixed.rawY});
      else xCheckSamplesLeft.push({x: fixed.rawX, y: fixed.rawY});
      return;
    }

    if (!running || !currentTask){
      return;
    }

    const zoneNow = classifyZone(hadRaw, fixed.rawX, fixed.rawY);
    const onFlag = (zoneNow === "T") ? 1 : 0;
    const t = elapsedTime;

    // ---- head direction sample (relative to neutral) ----
    let facePresent = (head.ready && head.face) ? 1 : 0;
    let headDir = "CENTER";
    let headYawRel = "";
    let headPitchRel = "";
    let headAwayEvent = 0;

    if (head.ready && head.calibrated && head.face){
      const rel = getHeadRel();
      headYawRel = rel.yawRel.toFixed(4);
      headPitchRel = rel.pitRel.toFixed(4);
      headDir = classifyHeadDir(rel.yawRel, rel.pitRel);
      headAwayEvent = updateHeadAway(t, headDir).away;
    }

    if (!gazeStats.hasStarted){
      gazeStats.hasStarted=true;
      gazeStats.lastTime=t;
      gazeStats.lastZone=zoneNow;
      gazeStats.totalSamples=1;
      if (hadRaw) gazeStats.validSamples=1; else gazeStats.invalidSamples=1;
    } else {
      const dt = t - (gazeStats.lastTime || t);
      gazeStats.lastTime = t;

      if (gazeStats.lastZone === "T"){
        gazeStats.totalOnMs += dt;
        gazeStats.timeTaskMs += dt;
      } else {
        gazeStats.totalOffMs += dt;
        gazeStats.timeDeviationMs += dt;
      }

      gazeStats.totalSamples++;
      if (hadRaw) gazeStats.validSamples++; else gazeStats.invalidSamples++;
      gazeStats.lastZone = zoneNow;
    }

    // OFF detector (time threshold)
    if (zoneNow === "T" || zoneNow === "N"){
      gazeStats.offStart = null;
      gazeStats.offDirStart = null;
      gazeStats.offDirVotes = [];
    } else {
      if (gazeStats.offStart == null){
        gazeStats.offStart = t;
        gazeStats.offDirStart = t;
        gazeStats.offDirVotes = [];
      }

      // collect votes within window
      if ((t - (gazeStats.offDirStart || t)) <= DIR_WINDOW_MS){
        gazeStats.offDirVotes.push(zoneNow);
      } else {
        gazeStats.offDirStart = t;
        gazeStats.offDirVotes = [zoneNow];
      }

      if ((t - gazeStats.offStart) >= OFF_MIN_MS){
        // vote final direction
        let dirSample = zoneNow;
        const votes = gazeStats.offDirVotes || [];
        if (votes.length >= DIR_MIN_VOTES){
          const counts = {L:0,R:0,U:0,D:0};
          votes.forEach(v => { if (counts[v]!=null) counts[v]++; });
          dirSample = Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0] || zoneNow;
        }

        gazeStats.offEvents++;
        if (dirSample==="L") gazeStats.offLeft++;
        else if (dirSample==="R") gazeStats.offRight++;
        else if (dirSample==="U") gazeStats.offUp++;
        else if (dirSample==="D") gazeStats.offDown++;

        gazeStats.offStart = null;
        gazeStats.offDirStart = null;
        gazeStats.offDirVotes = [];

        miniOff.textContent = String(gazeStats.offEvents);

        // log timeline sample at event time too (optional)
      }
    }

    const ms = Math.round(performance.now());
    const xOut = (fixed.x==null) ? "" : fixed.x.toFixed(1);
    const yOut = (fixed.y==null) ? "" : fixed.y.toFixed(1);

    // for timeline we also want off direction sample (current)
    let dirSample = (zoneNow==="T"||zoneNow==="N") ? "" : zoneNow;

    gazeTimeline.push({
      ms,
      task: taskIndex,
      zone: zoneNow,
      x: xOut,
      y: yOut,
      on: onFlag,
      dir: dirSample,
      face: facePresent,
      hdir: headDir,
      hyaw: headYawRel,
      hpit: headPitchRel,
      haway: headAwayEvent
    });
  }

  // ======================= Build CSV =======================
  function buildEyeCsv(){
    const header = [
      "pid","total_on_ms","total_off_ms","total_samples","valid_samples","invalid_samples",
      "off_events","off_left_events","off_right_events","off_up_events","off_down_events",
      "time_task_ms","time_deviation_ms",
      "head_away_events","head_left_events","head_right_events","head_up_events","head_down_events","head_unknown_events"
    ].join(",");

    const row = [
      (pidInput.value||"").trim(),
      Math.round(gazeStats.totalOnMs),
      Math.round(gazeStats.totalOffMs),
      gazeStats.totalSamples,
      gazeStats.validSamples,
      gazeStats.invalidSamples,
      gazeStats.offEvents,
      gazeStats.offLeft,
      gazeStats.offRight,
      gazeStats.offUp,
      gazeStats.offDown,
      Math.round(gazeStats.timeTaskMs),
      Math.round(gazeStats.timeDeviationMs),
      head.awayEvents, head.left, head.right, head.up, head.down, head.unknown
    ].join(",");

    return header + "\n" + row + "\n";
  }

  function buildEyeTimelineCsv(){
    const header = [
      "ms","task","zone","x_fixed","y_fixed","on_screen","off_direction",
      "face_present","head_dir","head_yaw_rel","head_pitch_rel","head_away_event"
    ].join(",");

    const lines = gazeTimeline.map(s => [
      s.ms, s.task, (s.zone||""), s.x, s.y, s.on, (s.dir||""),
      s.face, (s.hdir||""), (s.hyaw||""), (s.hpit||""), (s.haway||0)
    ].join(","));

    return header + "\n" + lines.join("\n") + "\n";
  }

  // ======================= Start/End Flow =======================
  function startWebgazerAndCalibration(){
    startBtn.disabled = true;
    beginTaskBtn.disabled = true;
    endBtn.disabled = true;
    isCalibrated = false;
    miniOff.textContent = "0";

    miniPid.textContent = (pidInput.value||"—").trim() || "—";
    miniTask.textContent = "—";
    miniStatus.textContent = "מבקש הרשאת מצלמה…";

    if (!window.webgazer){
      alert("WebGazer לא נטען. בדוק חיבור אינטרנט.");
      startBtn.disabled = false;
      return;
    }

    window.saveDataAcrossSessions = false;

    try{
      if (webgazer.applyKalmanFilter) webgazer.applyKalmanFilter(true);
      if (webgazer.setRegression) webgazer.setRegression("ridge");

      webgazer
        .setGazeListener(handleGaze)
        .showVideo(false)
        .showFaceOverlay(false)
        .showPredictionPoints(false)
        .begin();

      // start FaceMesh on the SAME video stream (no extra camera request)
      setTimeout(() => { initFaceMesh(); }, 300);

    } catch(e){
      alert("לא ניתן להפעיל את מעקב העיניים. ניתן להמשיך במשימה ללא המערכת.");
      startBtn.disabled = false;
      return;
    }

    miniStatus.textContent = "כיול…";
    setTimeout(startCalibrationSequence, 900);
  }

  function beginTasks(){
    if (!isCalibrated){
      alert("יש להשלים כיול קודם.");
      return;
    }
    running = true;
    sessionEnded = false;
    taskIndex = 1;
    tasksTotal = parseInt(taskCountSel.value,10) || 2;
    pointsPerTask = parseInt(difficultySel.value,10) || 16;

    // reset stats
    Object.assign(gazeStats,{
      hasStarted:false,lastTime:0,lastZone:"N",
      totalOnMs:0,totalOffMs:0,totalSamples:0,
      validSamples:0,invalidSamples:0,
      offEvents:0,offLeft:0,offRight:0,offUp:0,offDown:0,
      timeTaskMs:0,timeDeviationMs:0,
      offStart:null,offDirVotes:[],offDirStart:null
    });
    gazeTimeline.length = 0;

    currentTask = makeTask();
    miniTask.textContent = `${taskIndex}/${tasksTotal}`;
    miniStatus.textContent = "ריצה";
    beginTaskBtn.disabled = true;
    endBtn.disabled = false;

    draw();
  }

  function endSession(){
    if (sessionEnded) return;
    sessionEnded = true;
    running = false;
    miniStatus.textContent = "שומר…";
    endBtn.disabled = true;

    const csv = buildEyeCsv();
    const csvTimeline = buildEyeTimelineCsv();

    sendCsvToDrive(csv, "summary");
    sendCsvToDrive(csvTimeline, "timeline");

    overlayTitle.textContent = "הסשן הסתיים";
    overlayText.textContent =
      "הנתונים נשמרו (נשלחו ל-Drive דרך Apps Script).\n" +
      "אפשר להתחיל שוב עם PID חדש/אותו PID.";
    overlayContinue.textContent = "סגור";
    overlay.style.display = "grid";
    overlayContinue.onclick = () => overlay.style.display = "none";

    startBtn.disabled = false;
    beginTaskBtn.disabled = true;

    draw();
  }

  // ======================= Task interaction =======================
  function canvasPosFromEvent(ev){
    const rect = canvas.getBoundingClientRect();
    const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
    const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top };
  }

  function onCanvasClick(ev){
    if (calibrationActive){
      handleCalibrationClick(ev);
      return;
    }
    if (!running || !currentTask) return;

    const p = canvasPosFromEvent(ev);
    const target = currentTask.points[currentTask.current];
    if (!target) return;

    const d = Math.hypot(target.x - p.x, target.y - p.y);
    if (d > SETTINGS.dotRadius + 14) return;

    // connect
    if (currentTask.current > 0){
      const prev = currentTask.points[currentTask.current - 1];
      currentTask.lines.push([prev, target]);
    }
    currentTask.current++;

    if (currentTask.current >= currentTask.points.length){
      // finished this task
      currentTask.finishedAt = performance.now();
      if (taskIndex < tasksTotal){
        taskIndex++;
        currentTask = makeTask();
        miniTask.textContent = `${taskIndex}/${tasksTotal}`;
      } else {
        endSession();
        return;
      }
    }
    draw();
  }

  // ======================= Wire up =======================
  canvas.addEventListener("click", onCanvasClick);
  canvas.addEventListener("touchstart", (ev)=>{ ev.preventDefault(); onCanvasClick(ev); }, {passive:false});

  startBtn.addEventListener("click", startWebgazerAndCalibration);
  beginTaskBtn.addEventListener("click", beginTasks);
  endBtn.addEventListener("click", endSession);

  // init
  resizeCanvas();
  draw();

})();
</script>
</body>
</html>
