<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>משימת חיבור נקודות – ניסוי קשב + מעקב עיניים + כיוון ראש</title>
  <style>
    :root{
      --bg:#020617;
      --panel:#0b1120;
      --ink:#e5e7eb;
      --muted:#94a3b8;
      --stroke:#64748b;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;
      display:grid;
      grid-template-rows:auto 1fr auto;
    }
    header,footer{
      background:var(--panel);
      padding:10px 16px;
      border-bottom:1px solid #111827;
    }
    footer{
      border-top:1px solid #111827;
      border-bottom:none;
      font-size:0.8rem;
      color:var(--muted);
      text-align:center;
    }
    .top{
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:center;
    }
    .controls{
      display:flex;
      gap:8px;
      justify-content:center;
      align-items:center;
      flex-wrap:nowrap;
      overflow-x:auto;
      max-width:100%;
      padding-bottom:2px;
    }
    label{font-size:0.9rem;color:var(--muted);}
    input{
      background:#020617;
      border:1px solid #334155;
      color:var(--ink);
      padding:4px 8px;
      border-radius:8px;
      min-width:140px;
      flex:0 0 auto;
    }
    input[readonly]{opacity:0.8;}
    button{
      border-radius:999px;
      border:1px solid #334155;
      background:#111827;
      color:var(--ink);
      padding:6px 14px;
      cursor:pointer;
      font-size:0.9rem;
      white-space:nowrap;
      flex:0 0 auto;
    }
    button:disabled{ opacity:0.4; cursor:not-allowed; }
    button:hover:not(:disabled){ border-color:#60a5fa; }

    #stageWrap{
      padding:10px 16px 16px;
      position:relative;
    }
    #stage{
      width:100%;
      height:70vh;
      display:block;
      background:#020617;
      border-radius:18px;
      border:1px solid #1f2937;
      touch-action:none;
    }
    #overlay{
      position:absolute;
      inset:10px 16px 16px;
      display:none;
      place-items:center;
      background:rgba(15,23,42,0.82);
      border-radius:18px;
      z-index:10;
    }
    #overlay .box{
      background:#020617;
      border-radius:16px;
      border:1px solid #1f2937;
      padding:20px 24px;
      max-width:560px;
      text-align:center;
      white-space:pre-line;
    }
    #overlay h2{ margin:0 0 8px; }
    .muted{ color:var(--muted); }

    /* video element for FaceMesh (hidden) */
    #fmVideo{
      position:absolute;
      width:1px;height:1px;
      left:-9999px;top:-9999px;
      opacity:0;
      pointer-events:none;
    }
  </style>

  <!-- WebGazer -->
  <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>

  <!-- MediaPipe FaceMesh (Head direction) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
</head>

<body>
  <header>
    <div class="top">
      <div class="muted">
        המשימה תימשך עד <b>10 דקות</b> או עד לחיצה על "סיום מוקדם".
      </div>

      <div class="controls">
        <label for="pid">מזהה נבדק:</label>
        <input id="pid" type="text" placeholder="לדוגמה ABC123" />
        <button id="startBtn" disabled>התחל משימה</button>
        <button id="endBtn" disabled>סיום מוקדם</button>
      </div>
      <div class="muted" id="miniStatus" style="font-size:0.85rem;">
        סטטוס: ממתין להתחלה
      </div>
    </div>
  </header>

  <div id="stageWrap">
    <canvas id="stage"></canvas>
    <video id="fmVideo" playsinline muted></video>

    <div id="overlay">
      <div class="box">
        <h2 id="overlayTitle">הודעה</h2>
        <p id="overlayText" class="muted"></p>
        <button id="overlayContinue">המשך</button>
      </div>
    </div>
  </div>

  <footer>
    יש ללחוץ על המספרים לפי סדר עולה. ניתן להסיר בחירה על ידי לחיצה חוזרת על אותו מספר.
  </footer>

<script>
(() => {
  // ======================= הגדרות כלליות =======================
  const CONFIG = {
    sessionMinutes: 10,
    initialPoints: 16,
    incrementBy: 0,
    minDistance: 30,
    lineAvoidDistance: 16
  };

  // מסגרת פנימית (אזור המשימה) – נשאר רק בשביל פריסה ויזואלית
  const FRAME_MARGIN_X_RATIO = 0.06;
  const FRAME_MARGIN_Y_RATIO = 0.10;
  const POINT_INNER_PADDING = 40;

  // OFF "אמיתי" – סף זמן
  const OFF_MIN_MS = 1000;

  // סינון לתצוגת הנקודה האדומה
  const SMOOTH_ALPHA = 0.35;
  const MAX_STEP_PX  = 260;
  const MEDIAN_WIN   = 3;

  // שלב מרכז (ל־offset gaze)
  const CENTER_HOLD_MS = 5000;
  const CENTER_MIN_SAMPLES = 12;
  const CENTER_MAX_STD_PX = 120;
  let centerAttempts = 0;
  const MAX_CENTER_ATTEMPTS = 1;
  const UNSTABLE_AUTO_MS = 2000;

  // בדיקת ימין/שמאל לעיניים
  const XCHECK_RIGHT_MS = 2500;
  const XCHECK_LEFT_MS  = 2500;

  // UI debug
  const DRAW_GAZE_DOT = true;

  // ======================= DOM =======================
  const canvas = document.getElementById("stage");
  const ctx = canvas.getContext("2d");

  const pidInput = document.getElementById("pid");
  const startBtn = document.getElementById("startBtn");
  const endBtn = document.getElementById("endBtn");

  const overlay = document.getElementById("overlay");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlayText = document.getElementById("overlayText");
  const overlayContinue = document.getElementById("overlayContinue");
  const miniStatusEl = document.getElementById("miniStatus");

  function miniStatus(txt){
    miniStatusEl.textContent = txt;
  }

  // ======================= STATE =======================
  let running = false;
  let sessionStart = null;
  let tickId = null;
  let taskCounter = 0;
  let currentTask = null;
  let sessionEnded = false;

  // כיול נקודות (17 לחיצות)
  let isCalibrated = false;
  const CALIB_POINTS_TOTAL = 17;
  let calibrationActive = false;
  let calibrationPoints = [];
  let calibrationIndex = 0;

  // שלב מרכז / שלב בדיקת X
  let holdActive = false;
  let holdStart = null;
  let holdSamples = [];
  let holdWatchdogId = null;

  let xCheckActive = false;
  let xCheckPhase = "right";
  let xCheckStart = null;
  let xCheckSamplesRight = [];
  let xCheckSamplesLeft  = [];

  // mapping פנימי (נשארים למקרה הצורך)
  let FLIP_X = false;
  let FLIP_Y = false;
  let SWAP_XY = false;

  // ======================= Fix / smoothing =======================
  const gazeFix = {
    offsetX: 0,
    offsetY: 0,
    hasOffset: false,
    smoothX: null,
    smoothY: null,
    medBufX: [],
    medBufY: []
  };

  const dbg = { x:null, y:null };

  function resetSmoothing(){
    gazeFix.smoothX = null;
    gazeFix.smoothY = null;
    gazeFix.medBufX.length = 0;
    gazeFix.medBufY.length = 0;
  }

  function medianOf(arr){
    if (!arr.length) return null;
    const a = [...arr].sort((x,y)=>x-y);
    const m = Math.floor(a.length/2);
    return a.length % 2 ? a[m] : (a[m-1] + a[m]) / 2;
  }

  function applyFixes(rawX, rawY, mode){
    if (rawX == null || rawY == null) return { x:null, y:null, rawX:null, rawY:null };

    let x = rawX, y = rawY;

    if (SWAP_XY){ const t=x; x=y; y=t; }

    const w = window.innerWidth, h = window.innerHeight;
    if (FLIP_X) x = w - x;
    if (FLIP_Y) y = h - y;

    if (gazeFix.hasOffset){
      x += gazeFix.offsetX;
      y += gazeFix.offsetY;
    }

    const rawFixedX = x;
    const rawFixedY = y;

    if (mode === "calib"){
      return { x: rawFixedX, y: rawFixedY, rawX: rawFixedX, rawY: rawFixedY };
    }

    gazeFix.medBufX.push(rawFixedX);
    gazeFix.medBufY.push(rawFixedY);
    if (gazeFix.medBufX.length > MEDIAN_WIN) gazeFix.medBufX.shift();
    if (gazeFix.medBufY.length > MEDIAN_WIN) gazeFix.medBufY.shift();

    const mx = medianOf(gazeFix.medBufX) ?? rawFixedX;
    const my = medianOf(gazeFix.medBufY) ?? rawFixedY;

    let sx = mx, sy = my;
    if (gazeFix.smoothX != null && gazeFix.smoothY != null){
      const dx = mx - gazeFix.smoothX;
      const dy = my - gazeFix.smoothY;
      const d  = Math.hypot(dx, dy);
      if (d > MAX_STEP_PX){
        sx = gazeFix.smoothX + (dx / d) * MAX_STEP_PX;
        sy = gazeFix.smoothY + (dy / d) * MAX_STEP_PX;
      }
    }

    if (gazeFix.smoothX == null){
      gazeFix.smoothX = sx;
      gazeFix.smoothY = sy;
    } else {
      gazeFix.smoothX = gazeFix.smoothX + SMOOTH_ALPHA * (sx - gazeFix.smoothX);
      gazeFix.smoothY = gazeFix.smoothY + SMOOTH_ALPHA * (sy - gazeFix.smoothY);
    }

    return { x: gazeFix.smoothX, y: gazeFix.smoothY, rawX: rawFixedX, rawY: rawFixedY };
  }

  // ======================= Head tracking (MediaPipe FaceMesh) =======================
  // ברירת מחדל: הופכים ימין/שמאל כי ברוב המצלמות הוידאו "מראה" (זה תיקן אצלך: ימינה נכתב שמאלה)
  const head = {
    ok: false,
    lastTs: 0,
    yaw: 0,    // normalized
    pitch: 0,  // normalized
    yawSign: -1,
    pitchSign: 1,
    // ספים (תוכל לכוונן):
    // קטן יותר => רגיש יותר; גדול יותר => צריך הטיה חזקה יותר
    yawThr: 0.18,
    pitchThr: 0.18,
    dir: "C"
  };

  let faceMesh = null;
  let headLoopRunning = false;

  function classifyHeadDir(){
    if (!head.ok) return "C";
    const y = head.yaw * head.yawSign;
    const p = head.pitch * head.pitchSign;

    const ay = Math.abs(y);
    const ap = Math.abs(p);

    if (ay < head.yawThr && ap < head.pitchThr) return "C";
    if (ay >= ap) return y > 0 ? "R" : "L";
    return p > 0 ? "D" : "U";
  }

  async function initHeadTracking(){
    try{
      // משתמשים בוידאו של WebGazer כדי לא לפתוח מצלמה נוספת
      const wgVideo = document.getElementById("webgazerVideoFeed");
      if (!wgVideo){
        miniStatus("סטטוס: Head tracking לא פעיל (לא נמצא webgazerVideoFeed)");
        return;
      }

      faceMesh = new FaceMesh.FaceMesh({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
      });

      faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      faceMesh.onResults((results) => {
        const now = performance.now();
        head.lastTs = now;

        const lm = results.multiFaceLandmarks && results.multiFaceLandmarks[0];
        if (!lm){
          head.ok = false;
          head.dir = "C";
          return;
        }

        // 33 ו-263: קצוות עיניים; 1: קצה אף
        const L = lm[33], R = lm[263], N = lm[1];
        const midX = (L.x + R.x) / 2;
        const midY = (L.y + R.y) / 2;
        const dx = (R.x - L.x);
        const dy = (R.y - L.y);
        const faceW = Math.hypot(dx, dy) || 1e-6;

        head.yaw   = (N.x - midX) / faceW;
        head.pitch = (N.y - midY) / faceW;
        head.ok = true;
        head.dir = classifyHeadDir();
      });

      if (headLoopRunning) return;
      headLoopRunning = true;

      const loop = async () => {
        if (!headLoopRunning) return;
        const v = document.getElementById("webgazerVideoFeed");
        if (v && v.readyState >= 2 && !v.paused && !v.ended){
          try { await faceMesh.send({image: v}); } catch(e){}
        }
        requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);

      miniStatus("סטטוס: Head tracking פעיל");
    }catch(e){
      console.error("Head tracking init error:", e);
      miniStatus("סטטוס: Head tracking לא פעיל (שגיאת אתחול)");
    }
  }

  // ======================= Task rects (למיקום/כיול/מסגרת) =======================
  function getTaskRects(){
    const rect = canvas.getBoundingClientRect();
    const marginX = Math.max(rect.width  * FRAME_MARGIN_X_RATIO, 40);
    const marginY = Math.max(rect.height * FRAME_MARGIN_Y_RATIO, 40);
    const innerRect = {
      left:   rect.left + marginX,
      right:  rect.right - marginX,
      top:    rect.top  + marginY,
      bottom: rect.bottom - marginY
    };
    return { canvasRect: rect, innerRect, marginX, marginY };
  }

  function isInsideRect(x,y,r){
    return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
  }

  // ======================= Stats / timeline =======================
  const gazeStats = {
    hasStarted: false,
    lastTime: null,
    totalOnMs: 0,
    totalOffMs: 0,
    totalSamples: 0,
    validSamples: 0,
    invalidSamples: 0,
    offEvents: 0,
    offLeftEvents: 0,
    offRightEvents: 0,
    offUpEvents: 0,
    offDownEvents: 0,
    timeTaskMs: 0,
    timeDeviationMs: 0
  };

  const offState = {
    candidate: false,
    candidateStart: null,
    inOff: false,
    dir: ""
  };

  const gazeTimeline = [];

  function resetGazeStats(){
    Object.assign(gazeStats,{
      hasStarted:false,lastTime:null,
      totalOnMs:0,totalOffMs:0,totalSamples:0,validSamples:0,invalidSamples:0,
      offEvents:0,offLeftEvents:0,offRightEvents:0,offUpEvents:0,offDownEvents:0,
      timeTaskMs:0,timeDeviationMs:0
    });
    offState.candidate=false; offState.candidateStart=null;
    offState.inOff=false; offState.dir="";
    gazeTimeline.length=0;
    resetSmoothing();
  }

  function meanOf(arr){
    if (!arr.length) return null;
    return arr.reduce((a,v)=>a+v,0)/arr.length;
  }
  function stdOf(arr){
    if (arr.length < 2) return 9999;
    const m = arr.reduce((a,v)=>a+v,0)/arr.length;
    const v = arr.reduce((a,vv)=>a+(vv-m)*(vv-m),0)/(arr.length-1);
    return Math.sqrt(v);
  }

  function buildEyeCsv(){
    const pid = (pidInput.value || "").trim();
    if (!gazeStats.hasStarted && gazeStats.totalSamples === 0) return "";
    const headRow = [
      "pid","total_on_ms","total_off_ms","total_samples","valid_samples","invalid_samples",
      "off_events","off_left_events","off_right_events","off_up_events","off_down_events",
      "time_task_ms","time_deviation_ms"
    ];
    const row = [
      pid,
      Math.round(gazeStats.totalOnMs),
      Math.round(gazeStats.totalOffMs),
      gazeStats.totalSamples,
      gazeStats.validSamples,
      gazeStats.invalidSamples,
      gazeStats.offEvents,
      gazeStats.offLeftEvents,
      gazeStats.offRightEvents,
      gazeStats.offUpEvents,
      gazeStats.offDownEvents,
      Math.round(gazeStats.timeTaskMs),
      Math.round(gazeStats.timeDeviationMs)
    ].join(",");
    return headRow.join(",") + "\n" + row + "\n";
  }

  function buildEyeTimelineCsv(){
    const pid = (pidInput.value || "").trim();
    if (!gazeTimeline.length) return "";
    const headRow = ["pid","task_index","ms","x_rawfixed","y_rawfixed","gaze_valid","on_screen","off_direction","head_yaw","head_pitch","head_ok"];
    const rows = gazeTimeline.map(s =>
      [pid, s.task, s.ms, s.x, s.y, s.v, s.on, s.dir, s.hy, s.hp, s.hok].join(",")
    );
    return headRow.join(",") + "\n" + rows.join("\n");
  }

  // ======================= Drawing helpers =======================
  function drawGazeDot(){
    if (!DRAW_GAZE_DOT) return;
    if (dbg.x == null || dbg.y == null) return;
    const rect = canvas.getBoundingClientRect();
    const gx = dbg.x - rect.left;
    const gy = dbg.y - rect.top;
    ctx.fillStyle = "rgba(239,68,68,0.95)";
    ctx.beginPath();
    ctx.arc(gx, gy, 6, 0, Math.PI*2);
    ctx.fill();
  }

  function clampCountdownMs(totalMs, elapsedMs){
    const remain = totalMs - elapsedMs;
    const sec = Math.ceil(remain / 1000);
    return Math.max(1, sec);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

    // -------- קליק-כיול 17 נקודות
    if (calibrationActive && calibrationPoints.length){
      const p = calibrationPoints[calibrationIndex] || calibrationPoints[calibrationPoints.length-1];
      ctx.fillStyle = "#ef4444";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "14px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(`נקודה ${calibrationIndex+1} מתוך ${calibrationPoints.length} – לחץ על הנקודה האדומה`, p.x, p.y + 18);

      drawGazeDot();
      return;
    }

    // -------- החזקת מרכז
    if (holdActive){
      const { marginX, marginY } = getTaskRects();
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      const cx = marginX + (w - 2*marginX)/2;
      const cy = marginY + (h - 2*marginY)/2;

      ctx.fillStyle = "#ef4444";
      ctx.beginPath();
      ctx.arc(cx, cy, 14, 0, Math.PI*2);
      ctx.fill();

      const elapsed = performance.now() - holdStart;
      const leftSec = clampCountdownMs(CENTER_HOLD_MS, elapsed);

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "14px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(`נא להתמיד במבט על הנקודה במרכז (${leftSec})`, cx, cy + 20);

      drawGazeDot();
      return;
    }

    // -------- XCheck: נקודה ימינה/שמאלה
    if (xCheckActive){
      const { marginX, marginY } = getTaskRects();
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;

      const y = marginY + (h - 2*marginY)/2;
      const xRight = w - Math.max(18, marginX * 0.45);
      const xLeft  = Math.max(18, marginX * 0.45);
      const targetX = (xCheckPhase === "right") ? xRight : xLeft;

      ctx.fillStyle = "#ef4444";
      ctx.beginPath();
      ctx.arc(targetX, y, 14, 0, Math.PI*2);
      ctx.fill();

      const nowT = performance.now();
      const elapsed = nowT - xCheckStart;
      const total = (xCheckPhase === "right") ? XCHECK_RIGHT_MS : XCHECK_LEFT_MS;
      const leftSec = clampCountdownMs(total, elapsed);

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "14px system-ui, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";

      const txt = (xCheckPhase === "right")
        ? `כעת הבט ימינה לנקודה למשך ${leftSec} שניות`
        : `כעת הבט שמאלה לנקודה למשך ${leftSec} שניות`;

      ctx.fillText(txt, w/2, y + 24);

      drawGazeDot();
      return;
    }

    if (!currentTask){
      drawGazeDot();
      return;
    }

    // -------- ציור משימה רגיל
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const frameMarginX = Math.max(w * FRAME_MARGIN_X_RATIO, 40);
    const frameMarginY = Math.max(h * FRAME_MARGIN_Y_RATIO, 40);

    ctx.strokeStyle = "rgba(255,255,255,0.7)";
    ctx.lineWidth = 1.2;
    ctx.strokeRect(frameMarginX, frameMarginY, w - 2*frameMarginX, h - 2*frameMarginY);

    const pts = currentTask.points;
    const order = currentTask.selectionOrder;

    if (order.length > 1){
      ctx.strokeStyle = "#e5e7eb";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const first = pts[order[0]];
      ctx.moveTo(first.x, first.y);
      for (let i=1;i<order.length;i++){
        const p = pts[order[i]];
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "14px system-ui, Arial";

    pts.forEach((p, idx) => {
      const isSelected = currentTask.selected.has(idx);
      const radius = 13;
      if (isSelected){
        ctx.fillStyle = "#e5e7eb";
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#020617";
        ctx.fillText(String(idx+1), p.x, p.y);
      } else {
        ctx.fillStyle = "#020617";
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "#64748b";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.fillStyle = "#e5e7eb";
        ctx.fillText(String(idx+1), p.x, p.y);
      }
    });

    drawGazeDot();
  }

  // ======================= כיול מרכז (offset) =======================
  function startCenterHold(){
    if (holdWatchdogId) clearTimeout(holdWatchdogId);

    holdActive = true;
    holdStart = performance.now();
    holdSamples = [];
    resetSmoothing();
    draw();

    // watchdog: גם אם משהו משתבש – אחרי 7 שניות סוגרים בכוח
    holdWatchdogId = setTimeout(() => {
      if (holdActive){
        holdActive = false;
        finalizeCenterHold([...holdSamples], true);
      }
    }, CENTER_HOLD_MS + 2000);

    const loop = () => {
      if (!holdActive) return;
      const elapsed = performance.now() - holdStart;
      draw();
      if (elapsed >= CENTER_HOLD_MS){
        holdActive = false;
        finalizeCenterHold([...holdSamples], false);
        return;
      }
      requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);
  }

  function finalizeCenterHold(collected, forced){
    if (holdWatchdogId) { clearTimeout(holdWatchdogId); holdWatchdogId = null; }

    centerAttempts++;

    const xs = collected.map(s=>s.x);
    const ys = collected.map(s=>s.y);
    const avgX = meanOf(xs);
    const avgY = meanOf(ys);
    const sx = stdOf(xs);
    const sy = stdOf(ys);

    const unstable = (
      forced ||
      collected.length < CENTER_MIN_SAMPLES ||
      sx > CENTER_MAX_STD_PX ||
      sy > CENTER_MAX_STD_PX ||
      avgX == null || avgY == null
    );

    // תמיד נגדיר offset Best-Effort
    const { innerRect } = getTaskRects();
    const targetCx = (innerRect.left + innerRect.right) / 2;
    const targetCy = (innerRect.top  + innerRect.bottom) / 2;

    gazeFix.offsetX = targetCx - (avgX ?? targetCx);
    gazeFix.offsetY = targetCy - (avgY ?? targetCy);
    gazeFix.hasOffset = true;
    resetSmoothing();

    if (!unstable){
      startXCheck();
      return;
    }

    if (centerAttempts <= MAX_CENTER_ATTEMPTS){
      overlayTitle.textContent = "המעקב מעט לא יציב";
      overlayText.textContent =
        "ננסה עוד פעם אחת (אם תרצה).\n" +
        "אם לא ילך — נמשיך בכל מקרה תוך 2 שניות.";
      overlayContinue.textContent = "נסה שוב";
      overlay.style.display = "grid";

      const autoGo = setTimeout(() => {
        if (overlay.style.display === "grid"){
          overlay.style.display = "none";
          startXCheck();
        }
      }, UNSTABLE_AUTO_MS);

      overlayContinue.onclick = () => {
        clearTimeout(autoGo);
        overlay.style.display = "none";
        startCenterHold();
      };
      return;
    }

    startXCheck();
  }

  // ======================= XCheck =======================
  function startXCheck(){
    xCheckActive = true;
    xCheckPhase = "right";
    xCheckStart = performance.now();
    xCheckSamplesRight = [];
    xCheckSamplesLeft = [];
    resetSmoothing();

    const loop = () => {
      if (!xCheckActive) return;
      draw();

      const now = performance.now();
      const elapsed = now - xCheckStart;
      const total = (xCheckPhase === "right") ? XCHECK_RIGHT_MS : XCHECK_LEFT_MS;

      if (elapsed >= total){
        if (xCheckPhase === "right"){
          xCheckPhase = "left";
          xCheckStart = performance.now();
        } else {
          xCheckActive = false;
          finalizeXCheck();
          return;
        }
      }
      requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);
  }

  function finalizeXCheck(){
    const mr = meanOf(xCheckSamplesRight.map(s=>s.x));
    const ml = meanOf(xCheckSamplesLeft.map(s=>s.x));

    // אם נראה שהכיוונים הפוכים בעיניים – הופכים FLIP_X (לא חובה תמיד)
    if (mr != null && ml != null && mr < ml){
      FLIP_X = !FLIP_X;
      resetSmoothing();
    }

    isCalibrated = true;
    startBtn.disabled = false;
    miniStatus("סטטוס: מוכן להתחלה (עיניים + ראש)");
  }

  // ======================= WebGazer gaze listener =======================
  function handleGaze(data, elapsedTime){
    if (!data) return;

    const hadRaw = (data.x != null && data.y != null);
    const rawX = hadRaw ? data.x : null;
    const rawY = hadRaw ? data.y : null;

    const mode = (holdActive || xCheckActive) ? "calib" : "run";
    const fixed = hadRaw ? applyFixes(rawX, rawY, mode) : {x:null,y:null,rawX:null,rawY:null};

    dbg.x = fixed.x;
    dbg.y = fixed.y;

    if (holdActive && hadRaw && fixed.rawX != null && fixed.rawY != null){
      holdSamples.push({x: fixed.rawX, y: fixed.rawY});
      return;
    }
    if (xCheckActive && hadRaw && fixed.rawX != null && fixed.rawY != null){
      if (xCheckPhase === "right") xCheckSamplesRight.push({x: fixed.rawX, y: fixed.rawY});
      else xCheckSamplesLeft.push({x: fixed.rawX, y: fixed.rawY});
      return;
    }

    if (!running || !currentTask){
      return;
    }

    // on_screen לפי עיניים (בתוך הקנבס) + head direction
    const { canvasRect } = getTaskRects();
    const gazeValid = !!hadRaw && fixed.rawX != null && fixed.rawY != null;
    const gazeOnCanvas = gazeValid && isInsideRect(fixed.rawX, fixed.rawY, canvasRect);

    const headDir = head.dir || "C";
    const onFlag = (gazeOnCanvas && headDir === "C") ? 1 : 0;
    const t = elapsedTime;

    if (!gazeStats.hasStarted){
      gazeStats.hasStarted=true;
      gazeStats.lastTime=t;
      gazeStats.totalSamples=1;
      if (hadRaw) gazeStats.validSamples=1; else gazeStats.invalidSamples=1;
    } else {
      const dt = t - (gazeStats.lastTime || t);
      gazeStats.lastTime = t;

      if (onFlag === 1){
        gazeStats.totalOnMs += dt;
        gazeStats.timeTaskMs += dt;
      } else {
        gazeStats.totalOffMs += dt;
        gazeStats.timeDeviationMs += dt;
      }

      gazeStats.totalSamples++;
      if (hadRaw) gazeStats.validSamples++;
      else gazeStats.invalidSamples++;
    }

    // OFF לפי זמן: אם headDir != C או שאין gaze תקין/על קנבס
    const offNow = (onFlag === 0);

    if (!offNow){
      offState.candidate=false; offState.candidateStart=null;
      offState.inOff=false; offState.dir="";
    } else {
      if (!offState.candidate){
        offState.candidate = true;
        offState.candidateStart = t;
        offState.inOff = false;
      }
      let dirNow = "";
      if (head.ok && headDir !== "C") dirNow = headDir;
      offState.dir = dirNow;

      if (!offState.inOff && offState.candidateStart != null && (t - offState.candidateStart) >= OFF_MIN_MS){
        offState.inOff = true;
        gazeStats.offEvents++;
        if (offState.dir==="L") gazeStats.offLeftEvents++;
        else if (offState.dir==="R") gazeStats.offRightEvents++;
        else if (offState.dir==="U") gazeStats.offUpEvents++;
        else if (offState.dir==="D") gazeStats.offDownEvents++;
      }
    }

    const ms = Math.round(t);
    const taskIndex = currentTask ? currentTask.index : 0;

    let xOut="", yOut="";
    if (hadRaw && fixed.rawX != null && fixed.rawY != null){
      xOut = Math.round(fixed.rawX);
      yOut = Math.round(fixed.rawY);
    }

    let dirSample = "";
    if (onFlag===0 && offState.dir) dirSample = offState.dir;

    gazeTimeline.push({
      ms,
      task: taskIndex,
      x: xOut,
      y: yOut,
      v: gazeValid?1:0,
      on: onFlag,
      dir: dirSample,
      hy: +(head.yaw||0).toFixed(4),
      hp: +(head.pitch||0).toFixed(4),
      hok: head.ok?1:0
    });
  }

  // ======================= WebGazer + כיול נקודות =======================
  function startWebgazerAndCalibration(){
    if (!window.webgazer){
      alert("ספריית WebGazer לא נטענה. ניתן להמשיך עם המשימה בלי מעקב עיניים.");
      startBtn.disabled = false;
      return;
    }

    window.saveDataAcrossSessions = false;

    try{
      if (webgazer.applyKalmanFilter) webgazer.applyKalmanFilter(true);
      if (webgazer.setRegression) webgazer.setRegression("ridge");

      webgazer
        .setGazeListener(handleGaze)
        .showVideo(false)
        .showFaceOverlay(false)
        .showPredictionPoints(false)
        .begin();

      // Head tracking רץ על הוידאו של WebGazer (ללא מצלמה נוספת)
      setTimeout(initHeadTracking, 500);
    } catch(e){
      alert("לא ניתן להפעיל את מעקב העיניים. ניתן להמשיך במשימה ללא המערכת.");
      startBtn.disabled = false;
      return;
    }

    setTimeout(startCalibrationSequence, 900);
  }

  function generateCalibrationPoints(){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const frameMarginX = Math.max(w * FRAME_MARGIN_X_RATIO, 40);
    const frameMarginY = Math.max(h * FRAME_MARGIN_Y_RATIO, 40);

    const cols = 5;
    const rows = 4;
    const pts = [];
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        if (pts.length >= CALIB_POINTS_TOTAL-1) break;
        const x = frameMarginX + (c/(cols-1))*(w-2*frameMarginX);
        const y = frameMarginY + (r/(rows-1))*(h-2*frameMarginY);
        pts.push({x,y});
      }
    }
    pts.push({x: w/2, y: h/2});
    return pts.slice(0, CALIB_POINTS_TOTAL);
  }

  function startCalibrationSequence(){
    calibrationPoints = generateCalibrationPoints();
    calibrationIndex = 0;
    calibrationActive = true;
    miniStatus("סטטוס: כיול עיניים (לחץ על הנקודות)");
    draw();
  }

  canvas.addEventListener("click", (ev) => {
    if (!calibrationActive) return;
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;

    const p = calibrationPoints[calibrationIndex];
    const d = Math.hypot(x - p.x, y - p.y);
    if (d > 40) return;

    try{ webgazer.recordScreenPosition(ev.clientX, ev.clientY, "click"); }catch(e){}

    calibrationIndex++;
    if (calibrationIndex >= calibrationPoints.length){
      calibrationActive = false;
      miniStatus("סטטוס: כיול מרכז (החזק מבט)");
      startCenterHold();
      return;
    }
    draw();
  });

  // ======================= Task logic (connect-the-dots) =======================
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * devicePixelRatio);
    canvas.height = Math.floor(rect.height * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }

  function createTask(nPoints){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    const frameMarginX = Math.max(w * FRAME_MARGIN_X_RATIO, 40);
    const frameMarginY = Math.max(h * FRAME_MARGIN_Y_RATIO, 40);

    const innerLeft = frameMarginX + POINT_INNER_PADDING;
    const innerTop  = frameMarginY + POINT_INNER_PADDING;
    const innerW = (w - 2*frameMarginX) - 2*POINT_INNER_PADDING;
    const innerH = (h - 2*frameMarginY) - 2*POINT_INNER_PADDING;

    const points = [];
    const tryPlace = () => ({
      x: innerLeft + Math.random()*innerW,
      y: innerTop  + Math.random()*innerH
    });

    let guard = 0;
    while(points.length < nPoints && guard < 10000){
      guard++;
      const p = tryPlace();
      let ok = true;
      for (const q of points){
        if (Math.hypot(p.x-q.x, p.y-q.y) < CONFIG.minDistance){
          ok = false; break;
        }
      }
      if (ok) points.push(p);
    }

    return {
      index: taskCounter,
      nPoints,
      points,
      selected: new Set(),
      selectionOrder: [],
      startedAt: performance.now()
    };
  }

  function startSession(){
    if (running || sessionEnded) return;
    running = true;
    sessionStart = performance.now();
    taskCounter = 0;
    resetGazeStats();
    startBtn.disabled = true;
    endBtn.disabled = false;
    nextTask(CONFIG.initialPoints);
    tickId = setInterval(tick, 200);
    miniStatus("סטטוס: רץ");
  }

  function nextTask(nPoints){
    currentTask = createTask(nPoints);
    taskCounter++;
    draw();
  }

  function endSession(completed){
    if (sessionEnded) return;
    sessionEnded = true;
    running = false;
    clearInterval(tickId);
    tickId = null;
    endBtn.disabled = true;

    try{ if (webgazer && webgazer.end) webgazer.end(); }catch(e){}
    headLoopRunning = false;

    // כאן אתה יכול לשלוח/להוריד CSV. כרגע: מורידים לקובץ מקומי.
    const sumCsv = buildEyeCsv();
    const tlCsv  = buildEyeTimelineCsv();

    downloadText(sumCsv, `${(pidInput.value||"PID")}_summary.csv`);
    downloadText(tlCsv,  `${(pidInput.value||"PID")}_timeline.csv`);

    overlayTitle.textContent = "הסתיים";
    overlayText.textContent =
      completed ? "תודה! המשימה הסתיימה." : "סיום מוקדם. תודה!";
    overlayContinue.textContent = "סגור";
    overlay.style.display = "grid";
    overlayContinue.onclick = () => {
      overlay.style.display = "none";
    };

    miniStatus("סטטוס: הסתיים");
  }

  function tick(){
    if (!running) return;
    const now = performance.now();
    const maxMs = CONFIG.sessionMinutes * 60 * 1000;
    if ((now - sessionStart) >= maxMs){
      endSession(true);
    }
  }

  function downloadText(text, filename){
    if (!text) return;
    const blob = new Blob([text], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // קליק על נקודות במשימה
  canvas.addEventListener("pointerdown", (ev) => {
    if (!running || !currentTask || calibrationActive || holdActive || xCheckActive) return;
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;

    const pts = currentTask.points;
    const hit = pts.findIndex(p => Math.hypot(p.x-x, p.y-y) < 16);
    if (hit < 0) return;

    if (currentTask.selected.has(hit)){
      currentTask.selected.delete(hit);
      const idx = currentTask.selectionOrder.indexOf(hit);
      if (idx >= 0) currentTask.selectionOrder.splice(idx,1);
    } else {
      currentTask.selected.add(hit);
      currentTask.selectionOrder.push(hit);
    }

    // סיום משימה אם נבחרו כולם
    if (currentTask.selected.size === currentTask.nPoints){
      // משימה הבאה / סיום
      // (כרגע נשאר על אותה כמות נקודות)
      nextTask(currentTask.nPoints + CONFIG.incrementBy);
    }

    draw();
  });

  // ======================= Init =======================
  function getPidFromUrl(){
    const params = new URLSearchParams(window.location.search);
    return params.get("pid") || "";
  }

  const urlPid = getPidFromUrl();
  if (urlPid){
    pidInput.value = urlPid;
    pidInput.readOnly = true;
  }

  function showCalibrationIntro(){
    overlayTitle.textContent = "התחלה";
    overlayText.textContent =
      "נבצע כיול קצר למעקב עיניים.\n" +
      "לאחר מכן תוכל להתחיל את המשימה.\n\n" +
      "חשוב: אם ימינה/שמאלה עדיין הפוכים בכיוון הראש — תגיד לי ונחליף סימן.";
    overlayContinue.textContent = "התחל כיול";
    overlay.style.display = "grid";
    overlayContinue.onclick = () => {
      overlay.style.display = "none";
      startWebgazerAndCalibration();
    };
  }

  startBtn.addEventListener("click", () => {
    if (!isCalibrated){
      showCalibrationIntro();
      return;
    }
    startSession();
  });

  endBtn.addEventListener("click", () => endSession(false));

  // redraw loop קטן כדי שהנקודה האדומה תזוז תמיד
  setInterval(() => { draw(); }, 33);

  window.addEventListener("resize", () => {
    resizeCanvas();
    draw();
  });

  resizeCanvas();
  showCalibrationIntro();
})();
</script>
</body>
</html>
